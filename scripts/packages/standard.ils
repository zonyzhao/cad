;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  cadObj.ils: base CAD class. Most all classes will be derived/Inherit from 
;              this class
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
; Program SKILL Lint started on Sep 13 13:43:12 2017.
; IQ score is 100 (best is 100).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defgeneric( clone (obj arg)
;  error( "Clone is a subclass responsibility\n")
;);defgeneric
defgeneric( diff (obj arg)
  error( "Clone is a subclass responsibility\n")
);defgeneric
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( cadObj ()
	  (
		( oid @reader getOid @writer setOid )
		( cid @reader getCid @writer setCid )
		( ref @reader getRef @writer setRef )
		( attributes @reader getAttributes  @writer setAttributes)
		( layer @reader getLayer @writer setLayer )
		( purpose @reader getPurpose @writer setPurpose )
		( grid @writer setGrid @reader getGrid )			
	  )
);defclass
;########################################################
;# Class Constructor
;########################################################
defmethod( initializeInstance @after ((obj cadObj)) 
	   obj->oid=nil
	   obj->cid=nil
	   obj->ref=nil
	   obj->attributes=nil
	   obj->layer = "text"
	   obj->purpose = "drawing"
	   obj->grid = 0.1
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clone ojbect
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( cloneCadObj (( cobj cadObj) arg )
  arg->oid        = cobj->oid
  arg->ref        = cobj->ref
  arg->attributes = cobj->attributes
  arg->layer      = cobj->layer
  arg->purpose    = cobj->purpose
  arg->grid       = cobj->grid
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Serialize ojbect
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( serializeCadObj (( cobj cadObj))
  let((rlist)
    rlist='()
    rlist = cons(cobj->oid rlist)
    rlist = cons(cobj->cid rlist)
    rlist
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Diff ojbect
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( diff (( cobj cadObj) (arg cadObj) )
  let((rlist)
    rlist='()
    if(cobj->oid == arg->oid then
    else
      rlist = cons(rlist list('oid cobj->oid arg->oid))
    );if
    rlist
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Stores a List of Attributes the attributes member given
; that the reference to that CAD object has been set
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( setAttrList (( cobj cadObj ))
	cobj->attributes = cobj->ref->?
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( gridCheck (( cobj cadObj ) arg)
	if(cobj->grid == arg then
	  't
        else
           nil
        )
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method selects an attribute from the attribute list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( getAttrByIndex (( cobj cadObj ) index)
		nth(index cobj->attributes)
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method selects an attribute's contents from the attribute list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( getAttrValueByIndex (( cobj cadObj ) index)
		nth(index cobj->attributes)->?
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Returns Attribute Based Upon the Attribute Name
; key value must be a string i.e. "prop"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getAttrValueByKey (( cobj cadObj ) key)
	let( (  vals
		value
		attribute
		m
		y
		rlist
	        hashlist
	        keyind )
		vals = cobj->ref->??
		;FIXME: Need to detect cv type reference or lib reference (ddGetObj)
		vals = cdr(vals) ;; peel off the redundant dbid
		attribute = '()
		value = '()
		m = 1
		foreach(x vals
	  	  if( (m > 0) then
	      	    attribute = cons(x attribute)
	      	    m = -1
	  	  else
		    value = cons(x value)
              	    m = 1
	  	  ) ; if
		) ; foreach
		hashlist = '()
		m=0
		foreach(z attribute
	          y = nth(m value)
	  	  m=m+1
	  	  rlist = '()
	  	  rlist = cons(y rlist)
	  	  rlist = cons(z rlist)	  
	  	  hashlist = cons(rlist hashlist)
		) ; foreach
		keyind = stringToSymbol(key)
        	nth(1 assq( keyind hashlist))
	);let
);defMethod
;############################################################
;############################################################
;############################################################
;###################################################################
;#   techfile.ils: techfile library class
;###################################################################
defclass( techfile (cadObj)
	  (
		( name @reader getName @writer setName )
		( techFileName )
		( techFileProcess )
		( techFilePath )
		( layerNames )
		( controlParams )
		( derived )
		( tf )		  
	  )
);defclass
;###############################################
;# Class Constructor
;###############################################
defmethod( initializeInstance @after ((obj techfile)) 
	   obj->name            = nil
           obj->techFileName    = nil
	   obj->techFileProcess = nil
	   obj->techFilePath    = nil
	   obj->tf              = nil
	   obj->controlParams   = nil
	   obj->derived         = nil
	   obj->cid             = "tech"
);defmethod
;###############################################
; Get techfile object from the library name
; FIXME: does this return a list of refs if 
;        there are multiple techfiles attached
;        to a library
;###############################################
defmethod( getTechFileRef (( tech techfile ))
	   tech->ref = techGetTechFile(ddGetObj(tech->name)) 
);defmethod
;###############################################
; Is this a derived tech file
;###############################################
defmethod( isDerived (( tech techfile ))
  tech->derived = getTechFileRef(tech)~>refs
  if(!null(tech->derived) then
      getTechFileRef(tech)~>refLibNames
  )
);defmethod
;###############################################
; Get the technology file control parameters
;###############################################
defmethod( getControls (( tech techfile ))
	   tech->controlParams = techGetParams(tid=getTechFileRef(tech)) 
);defmethod
;###############################################
; Get the technology file control parameters
;###############################################
defmethod( getControl (( tech techfile ) arg)
  let((ret)
    ret = nil
    foreach(cont  tech->controlParams
      if(nth(0 cont) == arg then
        ret=nth(1 cont)
      );if 
    );foreach
    ret
  );let
);defmethod
;###############################################
; Unattach all techfiles from the target library
; FIXME: getTechFileRef method may return a list 
;        of techfile references
;###############################################
defmethod( unattachAllTechFiles (( tech techfile ))
	   ;foreach( tf tech->ref
	   	    techUnattachTechFile(ddGetObj(tech->name))
	   ;);foreach
);defmethod
;###############################################
; Attach a techfile from another library by name
;###############################################
defmethod( attachTechFile (( tech techfile ) libname)
	   techBindTechFile(ddGetObj(tech->name) libname "tech.db" t)
);defmethod
;###############################################
; set techfile object name
;###############################################
defmethod( setTechFileName (( tech techfile ))
	   	tech->techFileName = tech->ref->libName
);defmethod
;###############################################
; set techfile object process
;###############################################
defmethod( setTechFileProcess (( tech techfile ))
	   	tech->techFileProcess = tech->ref->processFamily
);defmethod
;###############################################
; set techfile object techfile path
;###############################################
defmethod( setTechFilePath (( tech techfile ))
	   	tech->techFilePath = tech->ref->path
);defmethod
;###############################################
; Is grid set
;###############################################
defmethod( isGrid (( tech techfile ))
   techIsMfgGridResolutionSet(tech->ref)
);defmethod
;###############################################
; Get MFG grid resolution
;###############################################
defmethod( getMfgGrid (( tech techfile ))
   techGetMfgGridResolution(tech->ref)
);defmethod
;###############################################
; Set MFG grid resolution
;###############################################
defmethod( setMfgGrid (( tech techfile ) res)
   techSetMfgGridResolution(tech->ref res)
);defmethod
;###############################################
; Get User Units
;###############################################
defmethod( getUserUnit (( tech techfile ))
   techGetUserUnit(tech->ref "maskLayout")
);defmethod
;###############################################
; Get DBU per UU
;###############################################
defmethod( getDBUPerUU (( tech techfile ))
   techGetDBUPerUU(tech->ref "maskLayout")
);defmethod
;###############################################
; PHYSICAL CONSTRAINTS SECTION
; Returns a list of all spacing rules
;###############################################
defmethod( getSpacingRules (( tech techfile ))
   techGetSpacingRules(tech->ref)
);defmethod
;###############################################
; PHYSICAL CONSTRAINTS SECTION
; Returns the foundry width rule for a given layer
;###############################################
defmethod( getWidthRule (( tech techfile ) layer)
   techGetSpacingRule(tech->ref "minWidth" layer)
);defmethod
;###############################################
; PHYSICAL CONSTRAINTS SECTION
; Returns the foundry spacing rule for a given layer
;###############################################
defmethod( getSpacingRule (( tech techfile ) layer)
   techGetSpacingRule(tech->ref "minSpacing" layer)
);defmethod
;###############################################
; PHYSICAL CONSTRAINTS SECTION
; Returns the foundry separation rule between
; two layers
;###############################################
;defmethod( getSeparationRule (( tech techfile ) @key (layerA) (layerB))
;   techGetSpacingRule(tech->ref "minSpacing" layerA layerB)
;);defmethod
;###############################################
; PHYSICAL CONSTRAINTS SECTION
; Returns the foundry same neet spacing rule for a given layer
;###############################################
defmethod( getSameNetSpacingRule (( tech techfile ) layer)
   techGetSpacingRule(tech->ref "minSamNetSpacing" layer)
);defmethod
;###############################################
; DEVICE SECTION
; Returns a list of all extracted devices 
;###############################################
defmethod( getExtractedDevices (( tech techfile ))
   techGetExractedDevices(tech->ref "maskLayout")
);defmethod
;###############################################
; DEVICE SECTION
; Returns a supermaster cellviw of the specified
; device
;###############################################
defmethod( getDeviceCellViewe (( tech techfile ) name )
   techGetDeviceCellView(tech->ref name "symbolic")
);defmethod
;###############################################
; LAYER SECTION
; Returns a list of tech layers in the techfile
; name(LayerNumber) 
;###############################################
defmethod( setTechLayers (( tech techfile ))
  let( (layers names)
    layers = tech->ref~>layers
    tech->layerNames = '()
    foreach( layer layers
       tech->layerNames = cons(layer~>name tech->layerNames)	  
    );
    tech->layerNames
  );let
);defmethod
;###############################################
; LAYER SECTION
; Given a layer number get layer name
;###############################################
defmethod( getLayerName (( tech techfile ) number )
   techGetLayerName(tech->ref number)
);defmethod
;###############################################
; LAYER SECTION
; Given a layer name get layer number
;###############################################
defmethod( getLayerNumber (( tech techfile ) name )
   techGetLayerNum(tech->ref name)
);defmethod
;###############################################
; LAYER SECTION
; Given a layer name get layer number
;###############################################
defmethod( printLayers (( tech techfile ))
  println("Name (Num)")
  let( (num)
    foreach(name tech->layerNames
  	num = getLayerNumber(tech name)
        printf("%s (%d)\n" name num)
    );foreach
    t
  );let
);defmethod
;###################################################################
;###################################################################
;###################################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  list.ils: Some extensions to skill list functionality 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( listfun ()
	  (
		( elems @reader getElems)
		( len )	
		( cid )
		( oid )	  
	  )
);defClass

;#########################################################
; Class Constructor
;#########################################################
defmethod( initializeInstance @after ((obj listfun)) 
	   obj->elems = '()
	   obj->len = 1
	   obj->oid = nil
	   obj->cid = "lst"
);defmethod

;############################################################
; Clones a listfun
;#############################################################
defmethod( cloneListfun ((list listfun) arg)
   arg->elems = list->elems
   arg->len   = list->len
   arg->oid   = list->oid
   arg->cid   = list->cid
);defmethod

;#########################################################
; Initializes the elems and len
;#########################################################
defmethod( setElems (( list listfun ) elems)
	   list->elems = elems
	   list->len = sub1(length(list->elems))
	   length(elems)
);defmethod

;#########################################################
; Updates the list length member
;#########################################################
defmethod( getLen (( list listfun ))
	   list->len = sub1(length(list->elems))
);defmethod

;#########################################################
; Returns the list element at the index posiion in the list
; non-destructive operation
;#########################################################
defmethod( getElem (( list listfun ) ind)
  let( (lis tmp)
    if(ind > sub1(length(list->elems) || ind < 0) then
       nil
    else
       nth(ind list->elems)
    );if
  );let
);defmethod

;#########################################################
; Returns the "head" of a list up to the index position
; non-destructive operation
;#########################################################
defmethod( head (( list listfun ) ind)
  let( (lis tmp)
    if(ind > sub1(length(list->elems)) then
       nil
    else
       lis=list->elems
       tmp='()
       for( i 1 ind+1
         tmp = cons(popf(lis) tmp)
       );for
       list->len = sub1(length(list->elems))
       tmp=reverse(tmp)
    );if
  );let
);defmethod

;#########################################################
; Returns the "tail" of a list at the index position.
;#########################################################
defmethod( tail (( list listfun ) ind)
	   if(ind > sub1(length(list->elems)) then
	          nil
           else
	     nthcdr(ind+1 list->elems)
	   );if
);defmethod

;#########################################################
; Replaces an item in the list at the index with the method
; argument - list is zero indexed
;#########################################################
defmethod( replace (( list listfun ) @key (ind 0) (val 0)) 
	   let( (tmp0 tmp1)
	   	if(ind > sub1(length(list->elems)) then
	          nil
		else
		  tmp0 = head(list sub1(ind))
		  tmp1 = rplaca(tail(list sub1(ind)) val)
		  list->len = sub1(length(list->elems))
		  list->elems = append(tmp0 tmp1)
		);if
	   );let
);defmethod

;#########################################################
; Inserts an item in the list at the index with the method
; argument - list is 0 indexed
;#########################################################
defmethod( insert (( list listfun ) @key (ind 0) (val 0))
	   let( (tmp0 tmp1)
	   	if(ind > sub1(length(list->elems)) then
	          nil
		else
	   	  tmp0 = head(list ind)
		  tmp1 = cons(val tail(list ind))
		  list->elems = append(tmp0 tmp1)
		  list->len = sub1(length(list->elems))
		  list->elems
		);if
	  );let
);defmethod

;#########################################################
; Appends to end of list 
;#########################################################
defmethod( addTail (( list listfun ) elem)
	   list->elems = append1(list->elems elem )
);defmethod

;#########################################################
; Appends to beginning of list 
;#########################################################
defmethod( addHead (( list listfun ) elem)
	   list->elems = cons(elem list->elems)
);defmethod

;#########################################################
; Auxilliarry method Redundant item remover in a list (needs to be a flat list)
; If a recursive list use recursive flattenin method
;#########################################################
defmethod( removeRedundantItems (( list listfun ) @key elist rlist)
  prog( (item retList)
    retList = rlist
    printf("INFO: Entry List: %L\n" elist)
    if(length(elist)>0 then
      item = nth(0 elist)
      printf("INFO: Adding Item: %s\n" item)
      retList = cons(item retList)
      retList = append(removeRedundantItems(list ?elist remove(item elist) ?rlist '()) retList) 
      return(retList)
    else
      println("INFO: List expired. Redundancy Removed.")
      return(retList)	
    );if
  );prog
);defmethod

;#########################################################
; Remove Redundant Items - uses recursive method "removeRedundantItems"
;#########################################################
defmethod( removeRedundant (( list listfun ))
  list->elems = removeRedundantItems(list ?elist list->elems ?rlist '())
);defmethod

;#########################################################
; Auxilliary method for flatting a recursive list
;#########################################################
defmethod( flattenRecurseList (( list listfun ) @key hlist flist)
  prog( (retList)
    retList = '()
    printf("Recursed List: %L\n" flist)
    if(listp(hlist) then
      if( length(hlist) != 1 then
        for( i 0 sub1(length(hlist))
          if( listp(nth(i hlist)) then
	    printf("Detected List %L\n", nth(i hlist))
	    retList = append(flattenRecurseList(list ?hlist nth(i hlist) ?flist flist) retList)
	  else
            printf("Nested Layer added %L\n", nth(i hlist))
	    retList = cons(nth(i hlist) retList)		    
	  );if
        );for
        return(append(flist retList))
      else
        println("Nested List Detected")
        retList = append(flattenRecurseList(list ?hlist nth(0 hlist) ?flist flist) retList)
        return(retList)
      );if
      else 
        return(cons(hlist retList))
    );if
  );prog
);defmethod

;#########################################################
; Flattens a Recursive List - uses recursive method "flattenRecurseList"
;#########################################################
defmethod( flattenRecursive (( list listfun ))
  list->elems = flattenRecurseList(list ?hlist list->elems ?flist '())
);defmethod

;#########################################################
; Intersection of two lists
;#########################################################
defmethod( intersection (( list listfun ) lst)
  setof( element list->elems
  	 member( element lst )
  );setof
);defmethod

;#########################################################
; Removes one  elem from the class member's list
;#########################################################
defmethod( removeElem (( list listfun ) arg)
  list->elems = remove(arg list->elems)
  ;printf("%L\n" list->elems)
);defmethod

;#########################################################
; Removes elems of arg list from the class member's list
;#########################################################
defmethod( removeElems (( list listfun ) arglist)
  let( (i)
    i=0
    foreach(el arglist
      printf("Removing %L\n" el)
      removeElem(list el)
      i++
    );foreach
    printf("Removed %d elems from list\n" i)
    list->elems
  );let
);defmethod

;#########################################################
; Intersection "NOT" of two lists
; FIXME: Not working correctly
;#########################################################
;defmethod( intersectionNot (( list listfun ) lst)
;  let( (ilist nlist)
;   nlist = lst
;   ;first find the intersection of the two lists
;   ilist = intersection(list lst)
;   ; now remove the list intersection elems from the input
;   ; arg's elems
;   foreach(el ilist
;     printf("Removing intersecting element %s\n" el)
;     nlist = remove(el nlist)
;     ;printf("%L\n" nlist)
;   );foreach
;   nlist
;  );let
;);defmethod

;#########################################################
; Union of two lists
; FIXME: Does not return proper union - repeated elems!!
; proper union should represent the concatenation of
; the two lists with redundant elems removed
; 1.) Append the two lists 
; 2.) remove redundant elems
;#########################################################
defmethod( union (( list listfun ) lst)
  list->elems = nconc(
	setof( element lst
  	        member( element list->elems )
  	);setof
  );nconc
  list->elems
);defmethod

;#########################################################
; Is the elem arg an elem of the class memeber list
; returns nil if not in list or the index of the
; arguments position in the class member's list
;#########################################################
defmethod( isElem (( list listfun ) elem)
  lindex(list->elems elem)
);defmethod


;#########################################################
; Is list empty
;#########################################################
;defmethod( isEmpty (( list listfun ))
;  if( !null(car(list->elems)) then
;    't
;  else
;    nil
;  );if
;);defmethod

;#########################################################
; Remove redundant items from a flat list
;#########################################################
;defmethod( removeRedundantFlat (( list listfun ))
;  let( (rlist nlist)
;       rlist = list->elems
;       nlist = '()
;       foreach(el list->elems
;         
;;         nlist = cons(el nlist)
 ;        tlist = remove(el tlist)
;       );
;       list->elems = tlist
;  );let
;);defmethod

;#########################################################
; Checks to see if the arg is a Disembodied Property List
; The list needs to be odd and start with nil
;#########################################################
defmethod( isDPL (( list listfun ) arg)
  dplp(arg)
);defmethod

;#########################################################
; Resets the list contents to empy list
;#########################################################
defmethod( resetList (( list listfun ))
  list->elems = '()
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  collection.ils: object collection class. Collections are
;                  lists of objects that are homogeneous object
;                  lists
; FIXME: Enforce homogenous content via classOf(x) check after first entry
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Program SKILL Lint finished on Sep 13 14:51:51 2017 with status PASS.
;IQ score is 100 (best is 100).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( collection (cadObj)
  (
    ( n @reader getLen )
    ( list @reader getList @writer setList )
    ( cList )
    ( cType )		  
  )
);defclass

;############################################################
; Class Constructor 
;#############################################################
defmethod( initializeInstance @after ((obj collection)) 
	   obj->n = 0
           obj->list = makeInstance( 'listfun )
	   obj->cList = '()
	   obj->cid="col"
	   obj->oid=""
	   obj->cType = nil
);defmethod

;############################################################
; Clones a collection
;#############################################################
defmethod( cloneCollection ((col collection) arg)
   arg->n = col->n
   arg->cList = col->cList
   arg->oid = col->oid
   arg->cType = col->cType
   cloneListfun(col->list arg->list)  
);defmethod

;############################################################
; Serialize a collection
;#############################################################
defmethod( serializeCollection ((col collection))
  let((olist tlist)
    olist = '()
    tlist = '()
    olist = cons("collection" olist)
    tlist = cons(col->n tlist)
    tlist = cons(col->cList tlist)
    tlist = cons(col->oid tlist)
    tlist = cons(col->cType tlist)
    olist = cons("collection" olist)
    olist = cons("collection" tlist)
    olist = cons("collection" col->list)
  );let
);defmethod

;############################################################
; Deserialize a collection
;#############################################################
defmethod( deserializeCollection ((col collection) arg)
  let((olist tlist)
    tlist      = nth(1 arg)
    col->n     = nth(0 tlist)
    col->cList = nth(1 tlist)
    col->oid   = nth(2 tlist)
    col->cType = nth(3 tlist)
    col->list  = nth(2 arg)
  );let
);defmethod

;############################################################
; Resets the collection list to empty list
;#############################################################
defmethod( resetCollection ((col collection))
       resetList(col->list)
       col->n = 0
);defmethod

;############################################################
; Returns a reference to the collection list
;#############################################################
defmethod( getCollection ((col collection))
       col->list->elems
);defmethod

;############################################################
; Creates a list of N (objNum) unpopulated lib objects 
; in sequential order 
;#############################################################
defmethod( genCollection ((col collection) arg)
       for( i 0 sub1(col->n)
       	  lappendBeg(col->list makeInstance(stringToSymbol(arg)))
       );for
);defmethod

;############################################################
; Generate a listing of the class the objects belong to in
; the collection
;#############################################################
defmethod( class ((col collection))
  let( (i)
    i=0
    col->cList = '()
    foreach( obs getElems(col->list)
      col->cList = cons(classOf(obs) col->cList) 
      printf("%L\n" classOf(obs)) 
      i++   	  
    );foreach
  );let
);defmethod

;############################################################
; Add and object to the collection's list
; if first object perform no classOf check (isEmpty = t)
; if list is not empty (isEmpty = nil) enforce classOf test
;#############################################################
defmethod( add ((col collection) arg)
   if(isEmpty then
     addTail(col->list arg)
     col->cType = classOf(arg)
     col->n = col->n + 1
   else
     if(classp(arg col->cType) then
       addTail(col->list arg)
       col->n = col->n + 1
     else
       printf("ERROR(collection): Input Class, %L, not compatible with collection contents\n" classOf(arg))
     );if
   );if
   col->n
);defmethod

;############################################################
; Get an item from the collection at index arg 
;#############################################################
defmethod( getItem ((col collection) arg)
   getElem(col->list arg)
);defmethod

;############################################################
; Is collection list empty
;#############################################################
defmethod( isEmpty ((col collection))
    null(col->list->elems)
);defmethod

;############################################################
; Creates a list of N (objNum) unpopulated lib objects 
; in sequential order 
;#############################################################
;defmethod( genCon ((cont collection) obj)
;  let( (  vName
;	  estrng )
;       for( i 0 sub1(cont->num)
;	  sprintf(vName "obj%d" i)
;	  sprintf(estrng strcat(vName "=makeInstance( '" obj->cid " )"))
;	  evalstring(estrng)
;	  sprintf(estrng strcat(obj->cid "->objList=cons(" vName " " obj->cid "->objList)"))
;	  evalstring(estrng)
;       );for
;     );let
;);defmethod

;############################################################
; Adds an object to the container list 
; FIXME: WIP!
;#############################################################
;defmethod( add ((obj collection))
;  let( (  vName
;	  estrng 
;;	  i)
;	  sprintf(estrng strcat("i = length(" obj->cid "->objList"))
;	  evalstring(estrng)
;	  sprintf(vName "obj%d" i)
;	  sprintf(estrng strcat(vName "=makeInstance( '" obj->cid " )"))
;	  evalstring(estrng)
;	  sprintf(estrng strcat(obj->cid "->objList=cons(" vName " " obj->cid "->objList)"))
;	  evalstring(estrng)
;	  obj->objNum=obj->objNum+1
;     );let
;);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;######################################################
;# coord2.ils: 2-D Coordinate Class
;######################################################
defclass( coord2 ()
  (
    ( x @reader getX @writer setX )
    ( y @reader getY @writer setY )	
  )				  
) ; defclass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj coord2)) 
  obj->x = nil
  obj->y = nil
);defmethod
;#####################################################
; returns the coordinate in list form
;#####################################################
defmethod( getCoord (( c2 coord2 ))
  list(getX(c2) getY(c2))	   
);defmethod
;#####################################################
; Sets coordinated based upon a list argument
;#####################################################
defmethod( setCoord (( c2 coord2 ) arg )
  c2->x = xCoord(arg)
  c2->y = yCoord(arg)
  list(c2->x c2->y)	   
);defmethod
;#####################################################
; Diff: difference method
;#####################################################
defmethod( diff (( c2 coord2 ) arg )
  let((rlist)
    rlist = '()
    if(c2->x != arg->x then
      rlist = cons(rlist list('x c2->x arg->x))
    );if
    if(c2->y != arg->y then
      rlist = cons(rlist list('y c2->y arg->y))
    );if
    rlist
  );let	   
);defmethod
;######################################################
;######################################################
;######################################################



;######################################################
;# Primitive 2-D Point Class
;######################################################
defclass( point2 (coord2 cadObj)
  ()				  
);defclass

;#####################################################
; Constructor Method
;#####################################################
;defmethod( initializeInstance @after ((obj point2)) 
; obj->point = nil
;);defmethod

;#####################################################
;
;#####################################################
defmethod( setPoint (( pt point2 ) arg )
  pt->x = xCoord(arg)
  pt->y = yCoord(arg)
  list(getX(pt) getY(pt))	   
);defmethod

;#####################################################
;
;#####################################################
defmethod( getPoint (( pt point2 ))
  list(pt->x pt->y)	   
);defmethod

;#####################################################
; translate point in 2-D space. Argument is list:
; list( xTran ytran)
;#####################################################
defmethod( translate (( pt point2 ) arg )
	   setX(pt getX(pt)+xCoord(arg))
	   setY(pt getY(pt)+yCoord(arg))
);defmethod

;#####################################################
; rotate a point in 2-D space about the origin
; arg is in degress
;#####################################################
defmethod( rotate (( pt point2 ) arg )
  let( (pi xcd ycd theta thetaPrime)
    pi = 3.14159265
    xcd = xCoord(getCoord(pt))
    ycd = yCoord(getCoord(pt))
    mag = (xcd**2+ycd**2)**0.5
    theta = atan2(ycd xcd)
    thetaPrime = theta+arg/180*pi
    setCoord(pt list(mag*cos(thetaPrime) mag*sin(thetaPrime)))
  );let
);defmethod

;#####################################################
; scale a point in 2-D space. Argument is a scaler
;#####################################################
defmethod( scale (( pt point2 ) scale )
	   setX(pt getX(pt)*scale)
	   setY(pt getY(pt)*scale)
);defmethod

; FIXME: Need to update for new coord2 inheritance
;#####################################################
; This method indicates whether class member point2 point
; is located to the lower-left of the input point argument pnt
; (logically lower OR left )
;#####################################################
;defmethod( lowerLeftPoint ((pt point2) arg)
;  let( ( pt1y pt2y )
;       cond(
;  ( xCoord(pt->point) < xCoord(arg)
;	     t
;	   );xCoord(pt->point) ...
;	   ( xCoord(pt->point) == xCoord(arg)
;	     	   pt1y = yCoord(pt->point)
;		   pt2y = yCoord(arg)
;		   pt1y < pt2y
;;	   );
;	   ( xCoord(pt->point) < xCoord(arg)
;	     t
;	   );xCoord(pt->point) ...
;	   ( t
;	     nil
;	   );t
 ;      );cond
;  );let
;);defmethod

;#####################################################
; FIXME: Should be in shape class as this is where
;        we begin to recognize grid
;#####################################################
;defmethod( isOnGrid (( pt point2 ))
;  let( (compFactor ret) 
;    compFactor = 1 / pt->dbuPerUu
;    ret = t
;    if(float(pt->x) != round( ( float(pt->x) + compFactor ) / pt->mfg ) * pt->mfg then
;      printf("WARNING: X Coordinate is off the manufacturing grid of %f: %f\n" pt->mfg float(pt->x))
;      ret = nil
;      if(float(pt->y) != round( ( float(pt->y) + compFactor ) / pt->mfg ) * pt->mfg then	
;        printf("WARNING: Y Coordinate is off the manufacturing grid of %f: %f\n" pt->mfg float(pt->y))
;      else
;        printf("WARNING: Both X and Y Coordinates are off the manufacturing grid of %f: (%f,%f)\n" pt->mfg float(pt->x) float(pt->y))
;      );if
;    else
;      printf("INFO: X Coordinate is on the manufacturing grid of %f: %f\n" pt->mfg float(pt->x))
;      if(float(pt->y) != round( ( float(pt->y) + compFactor ) / pt->mfg ) * pt->mfg then	
;        printf("WARNING: Y Coordinate is off the manufacturing grid of %f: %f\n" pt->mfg float(pt->y))
;        ret = nil
;      else
;	 printf("INFO: Y Coordinate is on the manufacturing grid of %f: %f\n" float(pt->mfg) float(pt->y))
;      );if
;    );if
;    ret	       
;  );let	     
;);defmethod

;#####################################################
; FIXME: Should be in shape class as this is where
;        we begin to recognize grid
;#####################################################
;defmethod( setOnGrid (( pt point2 ))
;  let( (compFactor) 
;    compFactor = 1 / pt~>dbuPerUu 
;    pt->x=round( ( pt->x + compFactor ) / pt->mfg ) * pt->mfg
;    pt->y=round( ( pt->y + compFactor ) / pt->mfg ) * pt->mfg
;    list(  pt->x pt->y  ) 
;  );let  
;);defmethod

;#####################################################
; This method corrects machine dependent round-off error.
;#####################################################
defmethod( pcFixPoint (( pt point2 ))
           setX(pt pcFix(getX(pt)))
	   setY(pt pcFix(getY(pt)))	   
);defmethod

;#####################################################
; This method serializes this class to a file
;#####################################################
defmethod( serialize (( pt point2 ) fname)
  let( (pl fp)
    pl = list(pt->x pt->y)
    fp = outfile(fname "w")
    fprintf(fp "%L" pl)
    close(fp)
  );let
);defmethod

;#####################################################
; This method deserializes this class to a file
;#####################################################
defmethod( deserialize (( pt point2 ) fname)
  let((fp pl)
    fp = infile(fname)
    pl = car(lineread(fp))
    close(fp)
    pt->x = xCoord(pl)
    pt->y = yCoord(pl)
    pl
  );let	   
);defmethod
;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  points.ils: container class for 2-D points 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( points2 (cadObj)
  (
    ( points @reader getPoints @writer setCollection )		  
  )
);defclass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj points2)) 
  obj->points = makeInstance( 'collection )
);defmethod

;#####################################################
; Add point2 object to points collection
;#####################################################
defmethod( appendPoint ((pts points2) arg) 
  if(classp( arg 'point2) then
    add(pts->points arg)
  else
    println("ERROR(points2): Argument is not a point2 object")
  );if
);defmethod

;#####################################################
; Add a list of point2 object to points collection
; argument is a simple list of points
;#####################################################
defmethod( addPoints ((pts points2) arg)
  let( (temp) 
    if(listp(arg) then
      foreach(pt arg
        temp = makeInstance( 'point2 )
	setCoord(temp pt) 
        appendPoint(pts temp)
      );foreach
    else
      println("ERROR(points2): Argument is not a simple list")
    );if
  );let
);defmethod

;#####################################################
; Reset points points collection
;#####################################################
defmethod( resetPoints ((pts points2)) 
  resetCollection(pts->points)
);defmethod

;#####################################################
; Translate all points in the collection based
; upon a list coordinate input
;#####################################################
defmethod( translate ((pts points2) arg)
  if( listp(arg) then
    foreach(p2 getCollection(pts->points)
      translate(p2 arg)
    );foreach
  else
    println("ERROR(points2): argument must be a simple list")
  );if
);defmethod 

;#####################################################
; Translate all points in the collection based
; upon a list coordinate input
;#####################################################
defmethod( rotate ((pts points2) arg)
    foreach(p2 getCollection(pts->points)
      rotate(p2 arg)
    );foreach
);defmethod 

;#####################################################
; scale all points in the collection based
; upon a scalar argument
;#####################################################
defmethod( scale ((pts points2) arg)
  foreach(p2 getCollection(pts->points)
    scale(p2 arg)
  );foreach
);defmethod

;#####################################################
; mirror all points about the y axis referenced to
; origin. Origin of the points list should be translated
; to the centroid of it's rectTran
;#####################################################
defmethod( mirrory ((pts points2))
  let( (newpnts temp)
    newPnts = makeInstance( 'collection )
    foreach( pnt getCollection(pts->points)
      temp = makeInstance( 'point2 )
      setCoord(temp list(-1*xCoord(getCoord(pnt)) yCoord(getCoord(pnt))))
      add(newPnts temp)
    );foreach
    setCollection(pts newPnts)
  );let
);defmethod 

;#####################################################
; mirror all points about the x axis referenced to
; origin. Origin of the points list should be translated
; to the centroid of it's rectTran
;#####################################################
defmethod( mirrorx ((pts points2))
  let( (newpnts temp)
    newPnts = makeInstance( 'collection )
    foreach( pnt getCollection(pts->points)
      temp = makeInstance( 'point2 )
      setCoord(temp list(xCoord(getCoord(pnt)) -1*yCoord(getCoord(pnt))))
      add(newPnts temp)
    );foreach
    setCollection(pts newPnts)
  );let
);defmethod 

;#####################################################
; Check to see if points collection is equal to an
; input points object given by arg
; FIXME: need to handle out of order comparison
;#####################################################
defmethod( diff ((pts points2) arg)
  let( (ret)
    ret = 't
    if(length(getCollection(pts->points)) != length(getCollection(arg->points)) then
      ret=nil
    );if
    for(i 0 length(getCollection(pts->points))
      pnta = getItem(pts->points i)
      pntb = getItem(arg->points i)
      if(null(diff(pnta pntb)) then
        ret=nil
      );if
    );for
  );let
);defmethod 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; rotation2: Generic Point Class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( rotation2 ()
	  (
	  	( radius @reader getRadius @writer setRadius)
	  	( theta @reader getTheta @writer setTheta)
	  )				  
) ; defclass
;#####################################################
;
;#####################################################
defmethod( initializeInstance @after ((obj rotation2)) 
	   obj->radius=nil
	   obj->theta=nil	   
)
;######################################################
;######################################################
;######################################################


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  polygon2.ils: Layout Polygon Object 
; FIXME: This needs to inherit from points2 class. Refactoring necessary ...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( polygon2 (cadObj)
  (	
    ( vertices @reader getVertices )
    ( area )
    ( centroid )
    ( scale )
    ( rtran @reader getRectTran )
    ( points )			  	
  )
);defClass
;#####################################################
; Constructor method
;#####################################################
defmethod( initializeInstance @after ((obj polygon2)) 
	   obj->vertices = nil
	   obj->area = nil
	   obj->centroid = makeInstance( 'point2 )
	   obj->scale = 1.0
	   obj->rtran = makeInstance( 'rectTran )
	   obj->points = makeInstance( 'points2 )
);defmethod
;####################################################
; Checks to make sure that the centroid of the
; rectTran is at the origin
;####################################################
defmethod( isCentered (( poly polygon2 ))
  let( (c)
    c = getCentroid(poly->rtran)
    if( xCoord(c) < 0.000001 && yCoord(c) < 0.000001 then
      t
    else
      nil
    )	 
  );let	   
);defmethod
;####################################################
; Centers the polygon's rectTran at the origin
; if not already centered
;####################################################
defmethod( center (( poly polygon2 ))
  let( (c)
    if( !isCentered(poly) then
       c = getCentroid(poly->rtran)
       translate(poly list(-xCoord(c) -yCoord(c)))
       setCentroid(poly->rtran list(0.0 0.0))
       setCentroid(poly list(0.0 0.0))
       getCentroid(poly->rtran)
    else
      t
    );if
  );let	 	   
);defmethod
;####################################################
; Sets the polygon vertices and calculates the
; area and centroid of the polygon
;####################################################
defmethod( setVertices (( poly polygon2 ) arg)
  poly->vertices = arg
  centroid(poly)
  poly->vertices	 	   
);defmethod
;####################################################
; Sets the polygon centroid value
;####################################################
defmethod( setCentroid (( poly polygon2 ) arg)
  setCoord(poly->centroid arg)	   
);defmethod
;####################################################
; Gets the polygon centroid value
;####################################################
defmethod( getCentroid (( poly polygon2 ))
  getCoord(poly->centroid)	   
);defmethod
;###############################################################################
; Area of a closed non-self intersecting polygon
;###############################################################################
defmethod( area (( poly polygon2 ))
	   let( (term0
	   	 term1 
	   	 j
	   	 len)
		poly->area = 0.0
		len = length(poly->vertices)
	   	for( i 0 length( poly->vertices)-1
		     j = modulo(i+1 len)
		     term0 = xCoord(nth(i poly->vertices))*yCoord(nth(j poly->vertices))
		     term1 = xCoord(nth(j poly->vertices))*yCoord(nth(i poly->vertices))
		     poly->area = poly->area + (term0 - term1)
		     i = i+1
	   	);for
		if( poly->area < 0 then
		    poly->area = -1*poly->area
		)
		poly->area = 0.5*(poly->area)
	   );let	   
);defmethod
;###############################################################################
; Centroid of a closed non-self intersecting 2-D transform
;###############################################################################
defmethod( centroid (( poly polygon2 ))
	   let( (term0
	   	 term1 
		 term2
		 term3
		 term4
		 term5
	   	 j
	   	 len
		 cx
		 cy)
		area(poly)
		len = length(poly->vertices)
		cx=0.0
		cy=0.0
	   	for( i 0 length( poly->vertices)-1
		     j = modulo(i+1 len)
		     term0 = xCoord(nth(i poly->vertices))+xCoord(nth(j poly->vertices))
		     term1 = xCoord(nth(i poly->vertices))*yCoord(nth(j poly->vertices))
		     term2 = xCoord(nth(j poly->vertices))*yCoord(nth(i poly->vertices))
		     term3 = yCoord(nth(i poly->vertices))+yCoord(nth(j poly->vertices))
		     term4 = xCoord(nth(i poly->vertices))*yCoord(nth(j poly->vertices))
		     term5 = xCoord(nth(j poly->vertices))*yCoord(nth(i poly->vertices))
		     cx=cx+(term0*(term1+term2))/(6*poly->area)
		     cy=cy+(term3*(term4+term5))/(6*poly->area)
		     i = i+1
	   	);for
		if( cx > 1000 || cy > 1000 then
		    println("WARNING(polygon2): Centroid calculation may have failed")
		    println("                   Setting centroid manually is recommended")
		) 
		setCoord(poly->centroid list(cx cy))
	   );let	   
);defmethod
;###############################################################################
; Rotate Polygon. Polygon's centroid must be at origin prior to rotation
;###############################################################################
defmethod( rotate (( poly polygon2 ) arg)
  let( (rVerts mag theta thetaPrime tvert pi)
    pi = 3.14159265
    foreach( vert poly->vertices
      mag   = (xCoord(vert)**2+yCoord(vert)**2)**0.5
      theta = atan2(yCoord(vert) xCoord(vert))
      thetaPrime = theta+arg/180*pi
      tvert = list(mag*cos(thetaPrime) mag*sin(thetaPrime))
      rVerts = cons(tvert rVerts)
    );foreach
      setVertices(poly rVerts)
  );let	   
);defmethod
;#####################################################
; This method scales the polygon by the arg value
;#####################################################
defmethod( scale (( poly polygon2 ) arg)
  let( (new rvert)
    new = '()
    foreach( vert poly->vertices
      rvert = list(arg*xCoord(vert) arg*yCoord(vert))
      new = cons(rvert new)
    );foreach
      poly->vertices = new
  );let	   
);defmethod
;#####################################################
; Convert points to vertex list
;#####################################################
defmethod( points2Vertex (( poly polygon2 ))
  let((n)
    n = 0
    poly->vertices = '()
    foreach( pnt getCollection(getPoints(poly->points))
      poly->vertices = cons(getPoint(pnt) poly->vertices )
      n = n + 1
    );foreach
    n
   );let		     	 
);defmethod
;###############################################################################
; render the polygon using the vertex list
;###############################################################################
defmethod( render (( poly polygon2 ))
  if( !null(poly->vertices) then
    if( vertexCount(poly) < 2048 then
      println("INFO(polygon): Rendering")
      dbCreatePolygon(poly->ref
	     	    list(poly->layer poly->purpose)
		    poly->vertices
      );dbCreatePolygon
    else
      println("ERROR(polygon): Max Vertex Count Exceeded. Maximum Render Vertex Count is 2048.")
    );if
    println("ERROR(polygon): No vertices to render")
  );if   
);defmethod
;#####################################################
; Find max x 
;#####################################################
defmethod( maxx (( poly polygon2 ))
  let( (maxx)
    ;FIXME: Need to ensure with a check that the origin is inside
    ;       the polygon. By construction rules, polygons will always
    ;       have the origin withih the polygon, but it should have
    ;       an extra check
    maxx = 0.0
    foreach( vert poly->vertices
      if(xCoord(vert) > maxx then
        maxx = xCoord(vert)
      else
        maxx = maxx
      );if
    );foreach
    maxx 
   );let		     	 
);defmethod
;#####################################################
; Find min x 
;#####################################################
defmethod( minx (( poly polygon2 ))
  let( (minx)
    ;FIXME: Need to ensure with a check that the origin is inside
    ;       the polygon. By construction rules, polygons will always
    ;       have the origin withih the polygon, but it should have
    ;       an extra check
    minx = 0.0
    foreach( vert poly->vertices
      if(xCoord(vert) < minx then
        minx = xCoord(vert)
      else
        minx = minx
      );if
    );foreach
    minx 
   );let		     	 
);defmethod
;#####################################################
; Find max y 
;#####################################################
defmethod( maxy (( poly polygon2 ))
  let( (maxy)
    ;FIXME: Need to ensure with a check that the origin is inside
    ;       the polygon. By construction rules, polygons will always
    ;       have the origin withih the polygon, but it should have
    ;       an extra check
    maxy = 0.0
    foreach( vert poly->vertices
      if(yCoord(vert) > maxy then
        maxy = yCoord(vert)
      else
        maxy = maxy
      );if
    );foreach
    maxy 
   );let		     	 
);defmethod
;#####################################################
; Find min y
;#####################################################
defmethod( miny (( poly polygon2 ))
  let( (miny)
    ;FIXME: Need to ensure with a check that the origin is inside
    ;       the polygon. By construction rules, polygons will always
    ;       have the origin withih the polygon, but it should have
    ;       an extra check
    miny = 0.0
    foreach( vert poly->vertices
      if(yCoord(vert) < miny then
        miny = yCoord(vert)
      else
        miny = miny
      );if
    );foreach
    miny
   );let		     	 
);defmethod
;#####################################################
; Set the rectangular transformation rectTran of the
; polygon
;#####################################################
defmethod( setRectTran (( poly polygon2 ))
  setUr(poly->rtran list(maxx(poly) maxy(poly)))
  setLl(poly->rtran list(minx(poly) miny(poly)))
  calculateCentroid(poly->rtran)
);defmethod
;#####################################################
; FIXME: this should be in transform2 class
; This method "spins" the polygon vertices in a 
; counter-clockwise direction by one increment every call 
;#####################################################
;defmethod( spin (( poly polygon2 ))
;	    let( (j temp)  
;	   	temp = '()
;		j=1
;		for( i 0 length( poly->vertices)-2    
;		     temp = append1(temp nth(j poly->vertices))
;		     j = j+1
;	   	);for
;		temp = append1(temp nth(0 poly->vertices)) 
;		poly->vertices = temp
;	    );let
;);defmethod
;#####################################################
; This method translates the position of each polygon2
; vertex and it's current centroid value by the point 
; value argument "list(x y)" 
;#####################################################
defmethod( translate (( poly polygon2 ) trn)
  let( (new len tvert) 
    new = '()
    len = length(poly->vertices)
    foreach( vert poly->vertices
      tvert = list(xCoord(vert)+xCoord(trn) yCoord(vert)+yCoord(trn))
      new = cons(tvert new)
    );foreach
    poly->vertices = new
    poly->centroid->x = poly->centroid->x + xCoord(trn)
    poly->centroid->y = poly->centroid->y + yCoord(trn)
  );let	   
);defmethod
;###############################################################################
; Check that there are at least 3 vertices (not a line or a point)
;###############################################################################

;###############################################################################
; Make Vertex List
;###############################################################################
;defmethod( setVertexList (( poly polygon2 ))
;  let( (i vobj)
;   poly->vertObjList = '()
;   i=0
;    foreach(vert poly->vertices
;  	   vobj = makeInstance('vertex2)
;	   setxy(vobj vert)
;	   setNum(vobj i)
;  	   poly->vertObjList = cons(vobj poly->vertObjList)
;	   i++
;    );foreach	       
;  );let   
;);defmethod

;###############################################################################
; FIXME: Edge object?
; Make Poly Edge List
;###############################################################################
;defmethod( setEdgeList (( poly polygon2 ))
;  let( (eobj)
;    poly->edgeObjList = '()
;    for(i 0 sub1(sub1(poly->vertices))
;  	   eobj = makeInstance('edge)
;	   setxy(eobj->p0 nth(i poly->vertices))
;	   setxy(eobj->p1 nth(i+1 poly->vertices))
;	   update(eobj)
;  	   poly->vertObjList = cons(eobj poly->vertObjList)
;    );for       
;  );let   
;);defmethod

;###############################################################################
; FIXME: Merge Object?
; Get lower-left vertex of the polygon
;###############################################################################
;defmethod( getLowerLeft (( poly polygon2 ))
;  let( ()  
;    foreach(vert poly->vertices
;      
;    );foreach
;  );let
;  nil
;);defmethod

;###############################################################################
; FIXME: Merge Object?
; Detect if polygon is intersecting the argument
;###############################################################################
;defmethod( isIntersecting (( poly polygon2 ) arg )
;  nil
;);defmethod
;###############################################################################
; Close Vertices
;###############################################################################

;###############################################################################
; Derivative Filtering of Vertice List - eliminate dy/dx=0 vertices
;###############################################################################


;###############################################################################
; Perimeter of a 2-D Polygon
;###############################################################################

;###############################################################################
; Diff the vertices of another set of vertices of a second 2-D Polygon
;###############################################################################



;###############################################################################
; FIXME: This method should be in the transform class and it should be using the  
; point2 on grid method
; Determine if all polygon points are on the manufacturing grid
;###############################################################################
;defmethod( isPolyOnGrid (( poly polygon2 ))
;  let( (ret)
;    ret = t
;    foreach( vert poly->vertObjList
;      if(isOnGrid(vert) then
;        println("Point on Grid")
;      else
;        ret = nil
;      );if
;    );foreach
;    ret
;  );let
;);defmethod

;###############################################################################
; FIXME: This method should be in the transform class 
; FIXME: Should be in the points2 class
; Place all polygon points on the manufacturing grid
;###############################################################################
;defmethod( setPolyOnGrid (( poly polygon2 ))
;    foreach( vert poly->vertObjList
;      setOnGrid(vert) 
;    );foreach
;);defmethod

;###############################################################################
; WIP: DEBUG MODE ...
; Detect if point is inside the member polygon.
; Implements "overlap rule" where the point needs to be inside
; and not lie on the perimeter of the polygon.
; FIXME: could make this identify if a point is ON a edge or vertex
;        by adding in additional abs(cp) equal zero checks
;        Check if the detected point is a vertex gives you a vertex
;        overlap and if not it's an edge overlap
;###############################################################################
defmethod( isPointInside (( poly polygon2 ) pnt )
  let( (vectList vect vp rotation vect0 vect1 ret cp)
     vectList = '()
     foreach( vert poly->vertices
       vect = makeInstance( 'vector2 )
       setHead(vect vert)
       setTail(vect pnt)
       vectList = cons(vect vectList) 
     );foreach
     rotation = 0.0
     vect0 = nth(0 vectList)
     vect1 = nth(1 vectList)
     cp = cross(vect0 vect1)
     ret = t
     if( cp != abs(0.0) then
       if( cp > 0.0 then
       	 printf("0: Initial Pos CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y )
       else
	 printf("0: Initial Neg CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y )
       );if
       if(cp > 0.0 then
         for( i 1 sub1(sub1(length(vectList)))
           vect0 = nth(i vectList)
	   vect1 = nth(i+1 vectList)
	   cp = cross(vect0 vect1)
	   printf("%d: Pos Incremental CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" i cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y ) 
	   if(cp <= 0.0 then
	     ret = nil
	   else 
	     ret = ret
	   );
       );for
       else
         for( i 1 sub1(sub1(length(vectList)))
           vect0 = nth(i vectList)
	   vect1 = nth(i+1 vectList)
	   cp = cross(vect0 vect1)
	   printf("%d: Neg Incremental CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" i cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y ) 
	   if(cp >= 0.0 then
	     ret = nil
	   else
	     ret = ret
	   );
         );for
       );if
     else
       printf("0: Initial Zero CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y )
       ret=nil
     );if
     ret
  );let
);defmethod
;###############################################################################
; FIXME: Edge object?
; Using the vertices, generate a list of edge2 objects in the edge collection
;###############################################################################
;defmethod( genEdges (( poly polygon2 ) )
;  nil
;);defmethod
;###############################################################################
; Is polygon a rectangle
;###############################################################################
defmethod( isRectangle (( poly polygon2 ))
  nil
)
;###############################################################################
; Is polygon a rectangle
;###############################################################################
defmethod( vertexCount (( poly polygon2 ))
  length(poly->vertices)
)
;###############################################################################
;###############################################################################
;###############################################################################




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  bbox.ils: Boundary Box Class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( bbox (cadObj)
	  (
		( ur @reader getUr @writer setUr )
		( ll @reader getLl @writer setLl )
		( width @reader getWidth @writer setWidth )
		( height @reader getHeight @writer setHeight )		
		( bbox @reader getBbox @writer setBbox)
		( origin @reader getOrigin @writer setOrigin)
		( centroid @reader getCentroid @writer setCentroid)
		( vertices @reader getVertices @writer setVertices)
		( transformation @reader getTrans)			  
	  )
) ; defClass

;#####################################################
; Constructor method
;#####################################################
defmethod( initializeInstance @after ((obj bbox)) 
	   obj->ur = nil
	   obj->ll = nil
	   obj->width = nil
	   obj->height = nil
	   obj->origin = nil
	   obj->bbox = nil
	   obj->transformation = makeInstance( 'transformation2 )
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clones the cellview object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
defmethod( cloneBbox (( bb bbox) arg )
  arg->ur     = bb->ur      
  arg->ll     = bb->ll      
  arg->width  = bb->width  
  arg->height = bb->height    
  arg->origin = bb->origin    
  arg->bbox   = bb->bbox   
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Populates Boundary Box Member with the contents of the
; reference cv's boundary box
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getbb (( bb bbox ))
	setBbox(bb getRef(bb)~>bBox) 
);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method sets the cv bBox based on the bbox member of this class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( setbb (( bb bbox ))
  let((bbox)
    bbox=list(getLl(bb) getUr(bb))
    setBbox(bb bbox)
    getRef(bb)~>bBox = getBbox(bb)
  );let 
);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Gets The Width and Height cell's boundary box 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getDim (( bb bbox ))
	bb->width  = caadr( bb->bbox ) - caar( bb->bbox )
	bb->height = cadadr( bb->bbox ) - cadar( bb->bbox)
	setUr(bb caadr( bb->bbox ))
	setLl(bb cadar( bb->bbox)) 
	list(bb->width bb->height)
);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Gets the Cell's Origin - defined as lower left (minx,miny)
; for a boundary box
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( Origin (( bb bbox ))
  let((x y)
    getDim(bb)
    x=caar(bb->bbox) 
    y=cadar(bb->bbox)
    bb->origin=list(x y)
  );let
);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Finds the center of the cell's boundary box
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Centroid (( bb bbox ))
  let( ( urx ury llx lly  )
    getbb(bb)
    ury = yCoord( upperRight( bb->bbox ))
    urx = xCoord( upperRight( bb->bbox ))
    llx = xCoord( lowerLeft( bb->bbox ))
    lly = yCoord( lowerLeft( bb->bbox ))
    x = (urx+llx)/2 
    y = (ury+lly)/2
    bb->centroid = list(x y)
  );let
);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method converts bbox coordinates to vertices
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( bb2vert (( bb bbox ))
  let( (ury urx llx lly vo v1 v2 v3)
    ury = yCoord( upperRight( bb->bbox ))
    urx = xCoord( upperRight( bb->bbox ))
    llx = xCoord( lowerLeft( bb->bbox ))
    lly = yCoord( lowerLeft( bb->bbox ))
    v0 = list(llx lly)
    v1 = list(urx lly)
    v2 = list(urx ury) 
    v3 = list(llx ury)
    setVertices(bb list(v0 v1 v2 v3 v0))
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Finds the area of the cell's boundary box in square meters
; FIXME: need to get UserUnits from the techfile to do proper
;        unit conversion
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( getBboxArea (( bb bbox ))
;	bb2vert(bb)
;	area(bb)*1e-12
;);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method calculates the upper right and lower left of a new bounding 
; centered at a new location with widths and heights given by 0.5*deltaX
; and 0.5*deltaY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( setCenter (( bb bbox ) aPoint @key (deltaX 1) (deltaY 1))
; let( (llx lly urx ury aPointX aPointY)
;      apointX = xCoord( aPoint )
;      apointY = yCoord( aPoint )
;      llx = aPointX - deltaX
;      urx = aPointX + deltaX
;      ury = sPointY + deltaY
;      list( llx:lly urx:ury ) 
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method translates the bbox about its centroid
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( translate (( bb bbox ) arg )
;	nil
;);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method rotates the bbox about its centroid
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( rotate (( bb bbox ) arg )
;	nil
;);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method scales the bbox about its centroid
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( scale (( bb bbox ) arg)
;	nil
;);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method returns the smallest bounding box coordinates containing
; all boxes given in a list with the class box's object - Merge!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( union (( bb bbox ) box)
; let( ( llxList llyList urxList uryList minllx minlly maxurx maxury )
;      llxList = foreach(mapcar bb->bbox box xCoord( lowerLeft( bb->bbox )))
;      llyList = foreach(mapcar bb->bbox box yCoord( lowerLeft( bb->bbox )))
;      urxList = foreach(mapcar bb->bbox box xCoord( upperRight( bb->bbox )))
;      uryList = foreach(mapcar bb->bbox box yCoord( upperRight( bb->bbox )))
;      minllx = apply( 'min llxList )
;      minlly = apply( 'min llyList )
;      minllx = apply( 'max urxList )
;      minlly = apply( 'max uryList )
;  );let
;);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method returns the intersection of two class box's object and a 
; list of bboxs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( intersection (( bb bbox ) box)
;  let( (llxList llyList urxList uryList maxllx maxlly minurx minury )
;       llxList = foreach(mapcar bb->bbox box xCoord( lowerLeft( bb->bbox )))
;       llyList = foreach(mapcar bb->bbox box yCoord( lowerLeft( bb->bbox )))
;       urxList = foreach(mapcar bb->bbox box xCoord( upperRight( bb->bbox )))
;       uryList = foreach(mapcar bb->bbox box yCoord( upperRight( bb->bbox )))
;       minurx = apply( 'min urxList )
;       minury = apply( 'min uryList )
;       maxllx = apply( 'max llxList )
;       maxlly = apply( 'max llyList )
;       cond(
;		( maxllx >= minurx 
;	  	  nil
;		);maxllx
;		( maxlly >= minury 
;	  	  nil
;		);maxlly
;		( t
;	  	  list(maxllx:maxlly minurx:minury)
;		);t
;  	);cond
;  );let
;);defmethod
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts The contents of the targeted Cellview to the upper 
; right hand plane of the coordinate system base upon the boundary box
; of the target Cellview  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( shiftURQ (( bb bbox ))
  let( (shift dx dy name cv) 
    getbb(bb)
    Origin(bb)
    unless( caar(bb->bbox) == 0 && cadar( bb->bbox) == 0
      dx = -xCoord(bb->origin)
      dy = -yCoord(bb->origin)
      shift = list( list( dx dy) "R0")
      cv = getRef(bb)
      dbReopen( cv "a")
      printf( "INFO(bbox):  Shifting Cell: %s to upper-right quadrant\n" cv~>cellName)
      printf( "             Shift is: %f by %f\n" float(caar( shift)) float(cadar( shift)))         
      foreach( inst cv~>instances 
        dbMoveFig( inst cv shift)
      );foreach
      foreach( shape cv~>shapes   
        dbMoveFig( shape cv shift)
      );foreach
      dbSave(cv)
      dbClose(cv)
    );unless
    getbb(bb)
    list( dx dy)
  );let
);defMethod	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts the origin of the bbox
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( shiftOrigin (( bb bbox ) shift)
  let( (bllx blly burx bury bbll bbur) 
    bllx = xCoord(nth(0 bb->bbox)) + xCoord(shift)
    blly = yCoord(nth(0 bb->bbox)) + yCoord(shift)
    burx = xCoord(nth(1 bb->bbox)) + xCoord(shift)
    bury = yCoord(nth(1 bb->bbox)) + yCoord(shift)
    bbll = list(bllx blly)
    bbur = list(burx bury)
    bb->bbox = list(bbll bbur)
    bb->origin = Origin(bb)
  );let
);defMethod	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts bbox Origin by provided dx and dy values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( setCentroid (( bb bbox ) arg)
;  let( ( sx sy )	
;  );let
;) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts cellview bbox Origin by provided dx and dy values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( shiftCentroidCellView (( bb bbox ) dx dy)
;	let( ( (name bb->cellName)
;		   (lib  bb->library)
;		   shift
;		   sx
;                  sy
;		   cvRef )
;		getbBox(bb)
;		cvRef = dbOpenCellViewByType( lib name "layout" "maskLayout")
;		sx = bb->x0 + dx
;      	sy = bb->y0 + dy
;      	shift = list( list( sx sy) "R0")
;		dbReopen( cvRef "a")
;		foreach( inst cvRef~>instances dbMoveFig( inst cvRef shift))
;    	foreach( shape cvRef~>shapes   dbMoveFig( shape cvRef shift))
;      	dbSave(cvRef)
;		dbClose(cvRef)
;		getbBox(bb)
;		)
;) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  rectTran.ils: Rectangle transform class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( rectTran (bbox)
  (
    ( anchor @reader getAnchor @writer setAnchor )
    ( pivot @reader getPivot @writer setPivot )			  
  )
);defClass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constructor method
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj rectTran)) 
  obj->anchor = makeInstance( 'point2 )
  obj->pivot = makeInstance( 'point2 )
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Converts a rectTran to a boundary box
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( rtran2bbox (( rt rectTran ))
  setBbx(rt list(getLl(rt) getUr(rt)))
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Calculates the centroid of the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( calculateCentroid (( rt rectTran ))
  let( (urx ury llx lly xval yval)
    urx = xCoord(getUr(rt)) 
    ury = yCoord(getUr(rt))
    llx = xCoord(getLl(rt))
    lly = yCoord(getLl(rt))
    xval = (urx+llx)/2
    yval = (ury+lly)/2 
    setCentroid(rt->transformation list(xval yval))
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Checks if the rectTran is centered at that origin
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( isCentered (( rt rectTran ))
  if( abs(xCoord(getCentroid(rt->transformation))) < 1e-6 && abs(yCoord(getCentroid(rt->transformation))) < 1e-6 then
    t
  else
    nil
  );if
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Centers the rectTran about the origin
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( center (( rt rectTran ))
  let( (cx cy)
    if( !isCentered(rt) then
      translate(rt -1*xCoord(getCentroid(rt->transformation)))
      setLowerLeft(rt -1*yCoord(getCentroid(rt->transformation)))
      setCentroid(rt->transformation list(0.0 0.0))
    );if
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set Upper Right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( setUpperRight (( rt rectTran ) arg )
  setUr(rt arg)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get Upper Right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getUpperRight (( rt rectTran ))
  getUr(rt)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set Upper Right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( setLowerLeft (( rt rectTran ) arg )
  setLl(rt arg)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get Upper Right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getLowerLeft (( rt rectTran ))
  getLl(rt)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; sets the centroid of the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( setCentroid (( rt rectTran ) arg)
  setCentroid(rt->transformation arg)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; gets the centroid of the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getCentroid (( rt rectTran ))
  getCentroid(rt->transformation)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Zeros out the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( zero (( rt rectTran ))
  setCentroid(rt list(0.0 0.0))
  setUpperRight(rt list(0.0 0.0))
  setLowerLeft(rt list(0.0 0.0))
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clone the current rectTran to the input recTran argument
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( clone (( rt rectTran ) arg)
  if( classp(arg 'rectTran) then
    println("INFO(rectran): Cloning a rectTran")
    setUr(rt getUr(arg))
    setLl(rt getLl(arg))
    setCentroid(rt getCentroid(arg))
  else
    println("ERROR(rectTran): recTran object argument required")
  );
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Area of recTran - rectTran must be centered about origin
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( area (( rt rectTran ))
  if( isCentered(rt) then
    (xCoord(getUr(rt))-xCoord(getLl(rt))*(yCoord(getUr(rt))-yCoord(getLl(rt))))
  else
    println("ERROR(rectTran): rectTran is not centered at origin")
  );if
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method translates the recTran about its centroid
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( translate (( rt rectTran ) arg )
  let( (urx ury llx lly)
    if(!null(rt->bbox) then
      urx = xCoord(getUr(rt)) + xCoord(arg)
      ury = yCoord(getUr(rt)) + yCoord(arg)
      llx = xCoord(getLl(rt))  + xCoord(arg)
      lly = yCoord(getLl(rt))  + yCoord(arg)
      setUr(rt list(urx ury))
      setLl(rt list(llx lly))
      calculateCentroid(rt)
      ;setCentroid(rt list( xCoord(getCentroid(rt))+xCoord(arg) yCoord(getCentroid(rt))+yCoord(arg)))
    else
      println("ERROR(rectTran): rectTran translate failed, bbox not valid!") 
    );if
  );let 
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the vertices from the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getVertices (( rt rectTran ))
  let( (v0 v1 v2 v3 v4)
    ;ll
    v0 = getLl(rt)
    ;lr
    v1 = list( -xCoord(getLl(rt)) yCoord(getLl(rt)) )
    ;ur
    v2 = getUr(rt)
    ;ul
    v3 = list( -xCoord(getUr(rt)) yCoord(getUr(rt)) )
    ;ll (closes the polygon)
    v4 = v0
    list(v0 v1 v2 v3 v4)  
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method rotates the rectTran about its centroid
; The rectran's centroid must be centered at origin
; for this to work properly
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( rotate (( rt rectTran ) arg )
  let( (poly)
      if(!null(rt->bbox) then
        poly = makeInstance( 'polygon2)
        setVertices(poly getVertices(rt))
        rotate(poly arg)
        setRectTran(poly)
        setUr(rt getUr(poly->rtran))
        setLl(rt getLl(poly->rtran))
      else
        println("ERROR(rectran): bbox not defined. No rotation performed!")
    );if	
  );let
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method scales the rectTran about its centroid
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( scale (( rt rectTran ) arg)
;	nil
;);defMethod
;###############################################################################
; render the rectTran
;###############################################################################
defmethod( render (( rt rectTran ))
  if( !null(getUr(rt)) && !null(getLl(rt)) then
        println("INFO(rectTran): Rendering")
        dbCreateRect(rt->ref
	     	     list(rt->layer rt->purpose)
		     list(getLl(rt) getUr(rt))
        );dbCreateRect
  else
    println("ERROR(recTran): No UpperRight or LowerLeft Coordinate")
  );if   
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FIXME: This should be "dropped" into the bbox class
; This method returns the smallest bounding rectangle composed of the
; current bounding rectangle and the bounding rectangle of the input 
; rectTran argument
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( union (( rt rectTran ) arg)
 let( ( maxx minx maxy miny ur ll ura lla)
    ur  = getUr(rt)
    ll  = getLl(rt)
    ura = getUr(arg)
    lla = getLl(arg)
    if( classp(arg 'rectTran) then
      println("INFO(rectran): Performing the union of two rectTrans")
      maxx =  max(xCoord(ur) xCoord(ura))
      minx =  min(xCoord(ll) xCoord(lla))
      maxy =  max(yCoord(ur) yCoord(ura))
      miny =  min(yCoord(ll) yCoord(lla))
      setUr(rt list(maxx maxy))
      setLl(rt list(minx miny))
    else
      println("ERROR(recTran): Rectran object argument required")
    );if  
  );let
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( validate (( rt rectTran ))
  nil
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FIXME: the methods below should be part of a "rectTrans" class that
;        operates on a collection of rectTran objects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method returns the intersection of two class box's object and a 
; list of bboxs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( intersection (( bb bbox ) box)
;  let( (llxList llyList urxList uryList maxllx maxlly minurx minury )
;       llxList = foreach(mapcar bb->bbox box xCoord( lowerLeft( bb->bbox )))
;       llyList = foreach(mapcar bb->bbox box yCoord( lowerLeft( bb->bbox )))
;       urxList = foreach(mapcar bb->bbox box xCoord( upperRight( bb->bbox )))
;       uryList = foreach(mapcar bb->bbox box yCoord( upperRight( bb->bbox )))
;       minurx = apply( 'min urxList )
;       minury = apply( 'min uryList )
;       maxllx = apply( 'max llxList )
;       maxlly = apply( 'max llyList )
;       cond(
;		( maxllx >= minurx 
;	  	  nil
;		);maxllx
;		( maxlly >= minury 
;	  	  nil
;		);maxlly
;		( t
;	  	  list(maxllx:maxlly minurx:minury)
;		);t
; 	);cond
;  );let
;);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts The bbox Origin To the Upper Right Quadrant of the 
; cellviews master grid field
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( shiftURQ (( bb bbox ))
;  let( ( shift dx dy) 
;	  getbBox(bb)
;	  unless( caar( bb->bbox) == 0 && cadar( bb->bbox) == 0
;		  dx = 0 - bb->origin->x
;     		  dy = 0 - bb->origin->y
;      		  shift = list( list( dx dy) "R0")
;      		  printf( "NOTE:  shifting %s to upper-right quadrant" name)
;      		  printf( "       shift is: %f by %f" caar( shift) cadar( shift))
;		  dbReopen( bb->cvRef "a")
;		  foreach( inst cvRef~>instances dbMoveFig( inst bb->cvRef shift))
;    		  foreach( shape cvRef~>shapes   dbMoveFig( shape bb->cvRef shift))
;      		  dbSave(bb->cvRef)
;		  dbClose(bb->cvRef)
;	  );unless
;	  getbBox(bb)
;  );let
;);defMethod	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts bbox Origin by provided dx and dy values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( setCentroid (( bb bbox ) arg)
;  let( ( sx sy )	
;  );let
;) ; defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts cellview bbox Origin by provided dx and dy values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( shiftCentroidCellView (( bb bbox ) dx dy)
;	let( ( (name bb->cellName)
;		   (lib  bb->library)
;		   shift
;		   sx
;                  sy
;		   cvRef )
;		getbBox(bb)
;		cvRef = dbOpenCellViewByType( lib name "layout" "maskLayout")
;		sx = bb->x0 + dx
;      	sy = bb->y0 + dy
;      	shift = list( list( sx sy) "R0")
;		dbReopen( cvRef "a")
;		foreach( inst cvRef~>instances dbMoveFig( inst cvRef shift))
;    	foreach( shape cvRef~>shapes   dbMoveFig( shape cvRef shift))
;      	dbSave(cvRef)
;		dbClose(cvRef)
;		getbBox(bb)
;		)
;) ; defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  rectTrans.ils: container class for rectTran 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( rectTrans (cadObj)
  (
    ( rtrans @reader getRtrans )
    ( rtran @reader getRectTran )		  
  )
);defclass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj rectTrans)) 
  obj->rtrans = makeInstance( 'collection )
  obj->rtran = makeInstance( 'rectTran )
);defmethod
;#####################################################
; Add rectTran object to rectTrans collection
;#####################################################
defmethod( rtsAdd ((rts rectTrans) arg) 
  if(classp( arg 'rectTran) then
    add(rts->rtrans arg)
  else
    println("ERROR(rectTrans): Argument is not a rectTran object")
  );if
);defmethod
;#####################################################
; Generate the rectTran union of all the transforms
; in the  geometry
;#####################################################
defmethod( rtsUnion (( rts rectTrans ))
  foreach( rt getCollection(rts->rtrans)
    if(!null(rt->bbox) then
      union(rts->rtran rt)
    else
      println("ERROR(rectTrans): rectTran bbox not valid - Union failed!")
    );if
  );foreach 
  if(!null(rts->rtran->bbox) then
    calculateCentroid(rts->rtran)
  );if
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Translates a rectran and rectrans
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( translate (( rts rectTrans ) arg)
  foreach(rtrn getCollection(rts->rtrans)
    translate(rtrn arg)
  );foreach
  translate(rts->rtran arg)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  transform2: Generic Point Class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( transform2 (cadObj)
	  (
	    ( polygon )
	    ( vertices @reader getVertices @writer setVertexCollection)
	    ( area )
	    ( transformation )
	    ( rtran @reader getRectTran)
	  )				  
) ; defclass

;#####################################################
; Constructor method
;#####################################################
defmethod( initializeInstance @after ((obj transform2))
	   obj->polygon = makeInstance( 'polygon2 ) 
	   obj->vertices = makeInstance( 'points2 )
	   obj->area=nil
	   obj->transformation = makeInstance( 'transformation2 )
	   obj->rtran = makeInstance( 'rectTran )
);defmethod

;#####################################################
; sets up the polygon "component" of the transform2 object 
;#####################################################
defmethod( addPolygon (( tran transform2 ) arg)
  if( classp(arg 'polygon2) then
    setVertices(tran getVertices(arg))
    setCentroid(tran getCentroid(arg))
  else
    println("ERROR(transform2): argument is not a polygon.")
  );if
);defmethod

;#####################################################
; Creates a collection of vertex objects from an input
; vertex simple list argument
;#####################################################
defmethod( resetVertices (( tran transform2 ))
  resetCollection(tran->vertices)
);defmethod

;#####################################################
; Creates a collection of vertex objects from an input
; vertex simple list argument
;#####################################################
defmethod( setVertices (( tran transform2 ) arg)
  let( (p2)
    setVertices(tran->polygon arg)
    setRectTran(tran->polygon)
    resetPoints(tran->vertices)
    foreach(vert arg
      p2 = makeInstance( 'point2 )
      setCoord(p2 vert)
      appendPoint(tran->vertices p2)
    );foreach
    setCentroid(tran->transformation getCoord(tran->polygon->centroid))
    setScale(tran->transformation 1.0)
    setTheta(tran->transformation 0.0)
    cloneRectTran(tran)
    t
  );let
);defmethod

;#####################################################
; Clones the polygons's rectTran into the transform2's
; recTran. Use this to "reset" the recTran when 
; transform2's transformation is reset.
;#####################################################
defmethod( cloneRectTran (( tran transform2 ))
  clone(tran->rtran getRectTran(tran->polygon))
);defmethod

;###############################################################################
; render the transform
;###############################################################################
defmethod( render (( tran transform2 ))
  let( (verts)
    verts = '()
    if( !null(tran->ref) then
      if( !isEmpty(tran->vertices->points) then
        foreach( point getCollection(tran->vertices->points)
	  verts = cons(getCoord(point) verts)
        );foreach
	println("INFO(transform2): Rendering Transform")
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;println is ok in a pcell, but printf may break it :(
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;printf("INFO(transform2): Rendering Transform: Layers %s, Lib %s, Cell %s", tran->layer tran->ref~>libName tran->ref~>cellName)
        dbCreatePolygon(tran->ref
	     	        list(tran->layer tran->purpose)
		        verts
	);dbCreatePolygon
      else
        println("ERROR(transform2): No vertices to render")
      );if
    else
        println("ERROR(transform2): Layout cellview reference not set")
    );if
  );let   
);defmethod

;#####################################################
; This method translates the position of each transform
; vertex by the point value argument "list(x y)" 
;#####################################################
defmethod( translate (( tran transform2 ) arg)
  let( (centroid)
    if( listp(arg) then
      translate(tran->vertices arg)
      centroid = getCentroid(tran->transformation)
      setCentroid(tran->transformation list(xCoord(centroid)+xCoord(arg) yCoord(centroid)+yCoord(arg)))
      translate(tran->rtran arg)
    else
      println("ERROR(transform2): list argument required")
    );if
  );let	   
);defmethod

;#####################################################
; This method translates the position of each transform
; vertex by the point value argument "list(x y)" 
;#####################################################
defmethod( scale (( tran transform2 ) arg)
  scale(tran->vertices arg)
  setScale(tran->transformation arg*getScale(tran->transformation))	   
);defmethod

;#####################################################
; This method translates the position of each transform
; vertex by the point value argument "list(x y)" 
;#####################################################
defmethod( isCentered (( tran transform2 ))
  isCentered(tran->rtran)	   
);defmethod


;#####################################################
; This method centers the transform based upon its
; rectTran center
;#####################################################
defmethod( center (( tran transform2 ))
  let( (rtcent)
    if( !isCentered(tran->rtran) then
      rtcent = getCentroid(tran->rtran)
      translate(tran list( -xCoord(rtcent) -yCoord(rtcent)))
    else
      t
    );if
  );let	   
);defmethod


;###############################################################################
; Note A: A local rotation requires that the transforms centroid be translated
;         to origin. Global rotations do not need the tranlation to origin
; Note B: positive angles = counter clockwise in according to 
; the "right handedness" convention.
;###############################################################################
defmethod( rotate (( tran transform2 ) arg)
      rotate(tran->vertices arg)	   
);defmethod

;###############################################################################
; Get centroid of transform
;###############################################################################
defmethod( getCentroid (( tran transform2 ))
  getCoord(tran->transformation->centroid)
)

;###############################################################################
; Set centroid of transform
;###############################################################################
defmethod( setCentroid (( tran transform2 ) arg)
  setCoord(tran->transformation->centroid arg)
)	  
	  
;###############################################################################
;###############################################################################
;###############################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Transformation2: Class representing the transformation of any
;;  2-D geometry
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( transformation2 ()
	  (
	    ( centroid @reader centroid)
	    ( absRotation @reader absRotation)
	    ( relRotation @reader relRotation)
	    ( scale @reader getScale @writer setScale)
	  )				  
) ; defclass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj transformation2)) 
  obj->centroid = makeInstance( 'point2 )
  obj->absRotation = makeInstance( 'rotation2 )
  obj->relRotation = makeInstance( 'rotation2 )
  obj->scale = nil
);defmethod

;#####################################################
; sets the centroid of the transformation
;#####################################################
defmethod( setCentroid (( tr2 transformation2 ) arg)
  if(listp(arg) then
    setCoord(tr2->centroid arg)
  else
    println("ERROR(transformation2): Expecting list argument")
  );if	   
);defmethod

;#####################################################
; gets the centroid of the transformation
;#####################################################
defmethod( getCentroid (( tr2 transformation2 ))
  getCoord(tr2->centroid)	   
);defmethod

;#####################################################
; returns the radius from origin to the centroid
; (normally this is zero representing the base 
;  transform)
;#####################################################
defmethod( getRadius (( tr2 transformation2 ))
  getRadius(tr2->relRotation)	   
);defmethod

;#####################################################
; sets the angle of rotation (relative rotation)
; of the CAD object 
;#####################################################
defmethod( setTheta (( tr2 transformation2 ) arg)
  setTheta(tr2->relRotation arg)	   
);defmethod

;#####################################################
; returns the angle of rotation (relative rotation)
; of the CAD object 
;#####################################################
defmethod( getTheta (( tr2 transformation2 ))
  getTheta(tr2->relRotation)	   
);defmethod

;#####################################################
; returns the radius from origin to the centroid
;#####################################################
defmethod( getRadiusToCentroid (( tr2 transformation2 ))
  getRadius(tr2->absRotation)	   
);defmethod

;#####################################################
; returns the angle of rotation about the 
;#####################################################
defmethod( getThetaToCentroid (( tr2 transformation2 ))
  getTheta(tr2->absRotation)	   
);defmethod

;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  geometry.ils: container class which holds a group
;                of polygon transforms.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( geometry ()
	  (
		( transforms )	
		( centroid )
		( rtran @reader getRectTran )
		( ref @reader getRef @writer setRef )		  
	  )
) ; defClass

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj geometry)) 
	   obj->transforms = makeInstance( 'collection )
	   obj->centroid = makeInstance( 'point2 )
	   obj->rtran = makeInstance( 'rectTran )
	   obj->ref = nil
);defmethod

;#####################################################
; Generate the rectTran union of all the transforms
; in the  geometry
;#####################################################
defmethod( rectTranUnion (( geom geometry ))
  zero(geom->rtran)
  foreach( trans getCollection(geom->transforms)
    union(geom->rtran getRectTran(trans))
  ) 
  calculateCentroid(geom->rtran)
);defmethod

;#####################################################
; Sets the centroid of the geometry
;#####################################################
defmethod( setCentroid (( geom geometry ) arg)
  setCoord(geom->centroid arg)
);defmethod

;#####################################################
; Gets the centroid of the geometry
;#####################################################
defmethod( getCentroid (( geom geometry ))
  getCoord(geom->centroid)
);defmethod

;#####################################################
; Sets the layer of the geometry
;#####################################################
defmethod( setLayer (( geom geometry ) arg)
  if( !isEmpty(geom->transforms) then
    foreach( trans getCollection(geom->transforms)
;      println("INFO(geometry): Changing transform Layer")
      setLayer(trans arg)
    );foreach
  else
    println("ERROR(geometry): Empty transform collection")
  );if
);

;#####################################################
; Sets the purpose of the geometry 
;#####################################################
defmethod( setPurpose (( geom geometry ) arg)
  foreach( trans getCollection(geom->transforms)
    setPurpose(trans arg)
  )
);

;#####################################################
; Add transform to transforms collection
;#####################################################
defmethod( addTransform (( geom geometry ) arg)
  if( classp( arg 'transform2) then
    add(geom->transforms arg)
  else
    println("ERROR(geometry): Argument must be a transform object")
  );if
);defmethod


;#####################################################
; Center the geometry based upon the geometry's 
; rectTran centroid
;#####################################################
defmethod( isCentered (( geom geometry ))
  isCentered(geom->rtran)
);defmethod

;#####################################################
; Center the geometry based upon the geometry's 
; rectTran centroid
;#####################################################
defmethod( center (( geom geometry ))
  let( (tval)
    if( !isCentered(geom) then
      tval = list( -xCoord(getCentroid(geom->rtran)) -yCoord(getCentroid(geom->rtran)))
      setCentroid(geom list(0.0 0.0))
      translate(geom->rtran tval)
      translate(geom tval)
    else
      t
    );if
  );let  
);defmethod

;#####################################################
; translate the geometry
;#####################################################
defmethod( translate (( geom geometry ) arg)
  foreach(tran getCollection(geom->transforms)
    translate(tran arg)
  );  
);defmethod

;#####################################################
; rotate the geometry
;#####################################################
defmethod( rotate (( geom geometry ) arg)
  let( (tcent)
    foreach(tran getCollection(geom->transforms)
      rotate(tran arg)
    );foreach
    rotate(geom->rtran arg)
  );let
);defmethod

;#####################################################
; scale the geometry
;#####################################################
defmethod( scale (( geom geometry ) arg)
 nil	  
);defmethod

;#####################################################
; render the geometry
;#####################################################
defmethod( render (( geom geometry ) )
  foreach( trans getCollection(geom->transforms)
    if( classp(trans 'transform2) then
      setRef(trans geom->ref)
      render(trans)
    else
      printf("ERROR(geometry): Render object must be a transform2")
    );if
  )	  
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;######################################################
; assembly.ils: Assembly class of geometries - base class
;######################################################
defclass( assembly ()
	  (
	     ( geometries @reader getGeometryCollection )
	     ( layers @reader getLayerCollection )
	     ( ref @reader getRef @writer setRef )
	     ( rtrans )
	     ( rtran  )
	  )				  
);defclass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj assembly)) 
	   obj->geometries = makeInstance( 'collection )
	   obj->ref = nil
	   obj->layers = makeInstance( 'collection )
	   obj->rtrans = makeInstance( 'rectTrans )
	   obj->rtran  = makeInstance( 'rectTran )
);defmethod
;#####################################################
; Gets a list of layer objects in the assembly
;#####################################################
defmethod( getRectTran (( ass assembly ))
  getRectTran(ass->rtrans)
);defmethod
;#####################################################
; Gets a list of layer objects in the assembly
;#####################################################
defmethod( getLayers (( ass assembly ))
  ass->layers->list
);defmethod
;#####################################################
; Adds shapes to the assembly via the shapes container. 
;#####################################################
defmethod( addGeometry (( ass assembly ) arg )
  if( !null(arg) then
    if( classp(arg 'geometry) then
      add(ass->geometries arg)
      t
    else
      println("ERROR(assembly): Only geometry objects can be added")
      nil
    );if
  else
    println("ERROR(assembly): Cannot add null shape")	       
    nil
  );if
);defmethod
;#####################################################
; Adds shapes to the assembly via the shapes container. 
;#####################################################
defmethod( resetLayers (( ass assembly ))
  resetCollection(ass->layers)
);defmethod
;#####################################################
; Creates the layers in the layer stackup needed to 
; render the shape
;#####################################################
defmethod( setShapesOnLayers (( ass assembly ))
  let( (temp)
    if( !null(ass->shapes->list->elems) then
      foreach( shape ass->shapes->list->elems
      	printf("INFO(Assembly): Processing shape on layer %s\n" getLayer(shape))
	if( !null(ass->layers->list->elems) then
          foreach( layer ass->layers->list->elems
	    printf("INFO(Assembly): Finding layer %s in list\n" getName(layer))
            if(getName(layer) == getLayer(shape) then
	      printf("INFO(Assembly): Layer %s found - Adding shape to layer\n" getLayer(shape))	
	      addShape(layer shape)
	    else
	      printf("INFO(Assembly): Adding shape to new layer %s\n" getName(layer))
              temp = makeInstance( 'techLayer )
    	      setName(temp getLayer(shape))
	      addShape(temp shape)
	      add(ass->layers temp)
	    );if
          );foreach
        else
	  printf("INFO(Assembly): Adding shape to new layer %s (first layer in assembly layer collection)\n" getLayer(shape))
	  temp = makeInstance( 'techLayer )
    	  setName(temp getLayer(shape))
	  addShape(temp shape)
	  add(ass->layers temp)
	);if
      );foreach
      t
    else
      printf("ERROR(Assembly): Shape collection is null\n")
      nil	       
    );if
  );let
);defmethod
;#####################################################
; Translates the assembly
;#####################################################
defmethod( translate (( ass assembly ) arg )
  if(listp(arg) then
    if(null(getCollection(ass->geometries)) then
      println("ERROR(assembly): No geometries in assembly to translate")
    else
      println("INFO:(assembly): translating assembly geometries")
      foreach( geom getCollection(ass->geometries)
        println("INFO:(assembly): geometry translated")
        translate(geom arg)
      );foreach
      println("INFO:(assembly): rectran translated")
      translate(ass->rtrans arg)
    );if
  else
    println("ERROR(assembly): requires a list argument")   
  );if
);defmethod
;#####################################################
; Rotate the assembly - rotate individual geometeries
;#####################################################
defmethod( rotate (( ass assembly ) arg )
  foreach( geom getCollection(ass->geometries)
      rotate(geom arg)
    );foreach
    rotate(ass->rtran arg)
);defmethod
;#####################################################
; Renders the layer stackup consisting of the layer
; shapes of the assembly
;#####################################################
defmethod( renderAssembly (( ass assembly ))
  if( !null(arg) then
    setLayers(ass)
    setShapesOnLayers(ass)
    renderStack(ass)
  else
    printf("ERROR: Cannot add null shape" )	       
    t
  );if
);defmethod
;#####################################################
; Renders the layer stackup consisting of the layer
; shapes of the assembly
;#####################################################
defmethod( render (( ass assembly ))
  if( !isEmpty(ass->geometries) then
    foreach( geom getCollection(ass->geometries)
      if( classp(geom 'geometry) then
        setRef(geom getRef(ass))
        render(geom)
      else
        println("ERROR(assembly): Render object must be a geometry")
      );if
    );foreach
  else
    println("ERROR(assembly): Empty geometry collection")
  );if
);defmethod
;######################################################
;######################################################
;######################################################
;###################################################################
; component.ils: Container class containing a collection
;                of assemblies
;###################################################################
defclass( component (cadObj)
  (
    ( assemblies @reader getAssemblies @writer setAssemblies)
    ( rtrans )				  
  )
);defClass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
defmethod( initializeInstance @after ((obj component)) 
	   obj->assemblies = makeInstance( 'collection )
	   obj->rtrans = makeInstance( 'rectTrans ) 
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Adds an assembly to a component
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( addAssembly (( comp component ) arg)
  add(comp->assemblies arg)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Translates the component
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( translate (( comp component ) arg)
  foreach(ass getCollection(comp->assemblies)
    translate(ass arg)
  );foreach
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Rotates the component
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( rotate (( comp component ) arg)
  foreach(ass getCollection(comp->assemblies)
    rotate(ass arg)
  );foreach
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Render the component
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( render (( comp component ))
  if(!isEmpty(comp->assemblies) then
    foreach(ass getCollection(comp->assemblies)
      setRef(ass getRef(comp))
      render(ass)
    );foreach
  else
    println("ERROR(component): no assemblies to render")
  );if
);defmethod
;###################################################################
;###################################################################
;###################################################################
;###################################################################
; structure.ils: Container class containing a collection
;                   of components
;###################################################################
defclass( structure (cadObj)
  (
    ( components @reader getComponents @writer setComponents )
    ( rtrans )				  
  )
);defClass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
defmethod( initializeInstance @after ((obj structure)) 
	   obj->components = makeInstance( 'collection )
	   obj->rtrans = makeInstance( 'rectTrans ) 
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Adds an component to a structure
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( addComponent (( struct structure ) arg)
  add(struct->components arg)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Translates the component
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( translate (( struct structure ) arg)
  foreach(comp getCollection(struct->components)
    translate(comp arg)
  );foreach
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Rotates the component
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( rotate (( struct structure ) arg)
  foreach(comp getCollection(struct->components)
    rotate(comp arg)
  );foreach
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Render the component
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( render (( struct structure ))
  if(!isEmpty(struct->components) then
    foreach(comp getCollection(struct->components)
      setRef(comp getRef(struct))
      render(comp)
    );foreach
  else
    println("ERROR(structure): no components to render")
  );if
);defmethod
;###################################################################
;###################################################################
;###################################################################
;######################################################
; stackup.ils: container class for multiple layers 
;               forming a layout stackup for a number
;               of layout assemblies. This focused on
;               Cadence layout cell views.
;######################################################
defclass( stackup (cadObj)
	  (
		( layers @writer setLayers @reader getLayers )
	  )				  
) ; defclass

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Class constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj stackup)) 
	   obj->layers = makeInstance( 'collection )
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method gets the layer stackup and prints it out
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getStackUp (( st stackup ))
  let( (n temp)
    n = 0
    if( !null(st->ref~>lpps) then
    	foreach(lpp st->ref~>lpps
      	  printf("%d: LAYER: %s, PURPOSE: %s SHAPES: %d\n" n lpp~>layerName lpp~>purpose lpp~>nShapes)
      	  temp = makeInstance( 'techLayer )
	  setRef(temp st->ref)
	  setName(temp lpp~>layerName)
	  setPurpose(temp lpp~>purpose)
	  getShapesOnLayer(temp)
	  add(st->layers temp)
	  n++
    	);foreach
    	n
    else
	printf("WARNING: No layers found in cellview\n")
	nil
    );if
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; render the stack in the target cellview (st->ref)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( renderStack (( st stackup ))
  let( (n m)
    m=0
    ;FIXME: stack is a layer and layer is a shape!!
    foreach(layer st->layers->list->elems
      printf("Rendering layer: %d: Name (layer->name): %s \n" m layer->name)
      ;n=0
      ; Shapes on layer are being rendered ...
      ;foreach(shp layer->shapes
      ;  printf("%d: Rendering layer: %s\n" n layer->name)
        setRef(layer getRef(st))
        renderShapesOnLayer(layer)
      ;  n++
      ;);foreach
      m++
    );foreach
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Merges all layers that are teh same
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( mergeStackUp (( st stackup ))
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; add a single layer object to the stack
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( addLayer (( st stackup ) arg )
  add(st->stack arg)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; add a single "assembly"?? object to the stackup list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( addAssembly (( st stackup ) arg )
  add(st->stack arg)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method deletes the "arg" layer from the cellview stackup
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( deleteLayer (( st stackup ) arg )
  let( (i found)
    found = nil
    i=0
    foreach(lay st->stack->list->elems
      if(getName(lay) == arg then
        found = t
	removeElem(st->stack->list lay)
	i++
      else
       i++	     
      );if    
    );foreach
    if(found then
      printf("INFO: Layer %s removed from stackup\n" arg)
    else
      printf("WARNING: Layer %s not found in stackup\n" arg)
    );if
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method prints the stackup
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( printStackUp (( st stackup ))
  let( (n)
    n = 0
    if( !null(st->stack->list->elems) then
    	foreach(lay st->stack->list->elems
      	  printf("%d: LAYER: %s\n" n getName(lay))
	  n++
    	);foreach
    	n
    else
	printf("WARNING: No layers found in cellview\n")
	nil
    );if
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  cv.ils: Cell view class inheriting from cadObj 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defgeneric( clone (obj arg)
;  error( "Clone is a subclass responsibility\n")
;);defgeneric
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( cv (bbox)
	  (
		( name @reader getName @writer setName)
        	( view @reader getView @writer setView )
		( lib @reader getLib @writer setLib )
		( orient @reader getOrient @writer setOrient) 
		( cvLeaf )
                ( cvPcell )
		( instances )
		( leafs )
		( leafCells )
		( stack )
		( layers )
		( pcells )
		( bbx @reader getBbx )	
		( iRefs )
                ( iCnt )
                ( iNames )
		( iLibNames )
		( iLevels )
		( iLayers )
		( uLayers @reader getuLayers )			  
	  )
);defClass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Class constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj cv)) 
	   obj->name      = nil
	   obj->view      = nil
	   obj->lib       = nil
	   obj->orient    = nil
	   obj->cvLeaf    = nil
           obj->cvPcell   = nil
	   obj->instances = makeInstance('collection)
	   obj->leafs     = nil
	   obj->leafCells = makeInstance('collection)
	   obj->layers    = nil
	   obj->stack     = makeInstance('stackup)
	   obj->pcells    = nil
	   obj->bbx       = makeInstance('bbox) 
	   obj->iRefs     = nil
	   obj->iCnt      = nil
	   obj->iNames    = nil
	   obj->iLibNames = nil
           obj->iLevels   = nil
	   obj->iLayers   = makeInstance('listfun)
	   obj->uLayers   = nil
	   obj->width     = nil
	   obj->height    = nil
);defmethod	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clones the cellview object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( cloneCv (( cell cv) arg )
  arg->name = cell->name      
  arg->view = cell->view      
  arg->lib = cell->lib      
  arg->orient = cell->orient    
  arg->cvLeaf = cell->cvLeaf    
  arg->cvPcell = cell->cvPcell   
  arg->instances = cell->instances 
  arg->leafs = cell->leafs     
  arg->leafCells = cell->leafCells 
  arg->layers = cell->layers    
  arg->stack = cell->stack     
  arg->pcells = cell->pcells    
  arg->bbx->bbox = cell->bbx->bbox        
  arg->iRefs = cell->iRefs     
  arg->iCnt = cell->iCnt      
  arg->iNames = cell->iNames    
  arg->iLibNames = cell->iLibNames 
  arg->iLevels = cell->iLevels   
  arg->iLayers = cell->iLayers   
  arg->uLayers = cell->uLayers   
  arg->width = cell->width     
  arg->height = cell->height
  cloneBbox(cell arg)    
  cloneCadObj(cell arg)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set cv reference of this and the bbx component
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( setCvRef (( cell cv ) arg)
;     setRef(cell arg)
;     setRef(cell->bbx arg)
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set origin of cellview
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( setOrigin (( cell cv ) arg)
;  let((orig shx shy)
;     orig  = Origin(cell->bbx)
;     shx = xCoord(arg) - xCoord(orig)
;;     shy = yCoord(arg) - yCoord(orig)
;    shiftOrigin(cell->bbx list(shx shy))
;  );let
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get origin of cellview
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( getOrigin (( cell cv ))
;  cell->origin = Origin(cell->bbx)
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Determines if the cellview has instances (flat if no instances)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( hasInstance (( cell cv ))
  !null(dbHasInstance(getRef(cell)))
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Completely flatten the entire cellview hierarchy
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( smash (( cell cv ))
  let((insts)
    insts = getInstances(cell)
    for(i 0 sub1(length(insts))
      inst = nth(i insts)
      dbFlattenInst(inst 32 t)
    );for
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get all the instances in the current cellview
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( getInstances (( cell cv ))
  let( (instances temp)
    instances = cell->ref~>instances
    foreach( inst instances
      temp = makeInstance( 'instance )
      setRef(temp inst)
      add(cell->instances temp)
    );foreach
  );let
);defmethod	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create a new instance in the cellview
; FIXME: Create and container of instances
; FIXME: How is this even working!! cv->ref should be getRef(cell)
; FIXME: If i try to fix this skill++ won't load into cad61 session.
;        Don't know why - xyn crises so no time to debug!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( createInstance (( cell cv ) inst )
	   	cell->instances = const(dbCreateInst( inst cv->ref nil 0:0 "R0" 1) cell->instances)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create a new instance in the cellview
; version used in reticle builder
; FIXME: need to create a new instance object and add this to the instance collection
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( createInstance2 (( cell cv ) inst name orig orient)
  dbCreateInst( getRef(cell) inst name orig orient 1)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Gets Cell Grid Information
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( getGridInfo (( cell cv ))
		dbGetGlobalGridOffsetReferenceType(cell->ref)
		dbGetGlobalGridDefaultRepeatMode(cell->ref)
		dbGetGlobalGridRepeatMode(cell->ref "wsspDefName" "wspName")
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Removes layout cell from library
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( removeCell (( cell cv ))
		let( ( (name cell->name)
		       (lib  cell->lib) )
		if( !null(ddGetObj(cell->lib cell->name cell->view)) then
		    if(!null(ddDeleteObj(ddGetObj(cell->lib cell->name cell->view))) then
		      printf("INFO: Removing cell view: %s\n" cell->name)
		      t
		    else
		      printf("ERROR: Could not deleted cell view: %s\n" cell->name)
		      nil
		    );if
		else
	            printf("ERROR: Cell view not found: %s\n" cell->name)
		    nil
                );if
	); let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copys layout view to another name in the same library
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Copy (( cell cv ) name)
  let((cv cpCv)
    cv = getRef(cell)
    if( null(ddGetObj(cell->lib name cell->view )) then
      println("INFO(cv): Copying cellview")
      cpCv = dbCopyCellView(cv cell->lib name cell->view "" nil t)
      dbSave( cpCv )
      dbClose( cpCv )
      't
    else
      printf("ERROR: layout cell %s exists in library\n" name)
      nil
    );if 
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copys layout view from another library into the cell object's library
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( copyCell (( cell cv ) copyLib copyCell)
  if( !ddGetObj(copyLib copyCell "layout") then
    dbCopyCellView(cell->ref copyLib copyCell "layout" "" nil t)
  else
    printf("ERROR: layout cell %s exists in library\n" copyCell)
    nil
  );if 
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Creates a new cell in the target library
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( createCell (( cell cv ))
	let( ( (name cell->name)
		       (lib  cell->lib) 
		       cv)
		if( !ddGetObj(lib name "layout") then
		    cv = dbOpenCellViewByType( lib name "layout" "maskLayout" "w")
		    dbSave(cv)
		    dbClose(cv)
		    t
		else
		    printf("ERROR: layout cell %s exists in library\n" name)
		    nil
		);if 
	); let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copies a cellview instance into the a new cell in the target library
; at the origin of the object's cellview
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( newCellInstance (( cell cv ) instLib instCell)
	let( ( (name cell->name)
		       (lib  cell->lib)
		       (chlst  cell->children) 
		       cvp
                       cvc)
		if( ddGetObj(lib name "layout") then
		    cvp = dbOpenCellViewByType( lib name "layout" "maskLayout" "w")
		    if( ddGetObj(instLib instCell "layout") then
		    	cvc = dbOpenCellViewByType(instLib instCell "layout" "maskLayout")
			;FIXME: need a constructor which provides an initial empty list for children member
                        ;       append this child to the children list list
			cons( child = dbCreateInst( cvp cvc nil 0:0 "R0" 1) chlst )
		    	dbSave(cvp)
			dbClose(cvp)
			dbClose(cvc)
		    	t
	             else
			printf("ERROR: layout cell %s exists in library %s" instCell instLib)
		    	nil
		    );if
		else
		   printf("ERROR: layout cell %s exists in library %s" name lib)
		   nil	
		);if 
	); let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method determines if the cv is a leaf cell
; returns t if it is and nil if it is not
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( isLeaf (( cell cv ))
   if( length(cell->ref~>instances) > 0 then 
     nil
   else
     t
   )
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method determines if the cv is a Pcell
; returns t if it is and nil if it is not
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( isPcell (( cell cv ))
   if( length(cell->ref~>instances) > 0 then 
     nil
   else
     t
   )
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get cv bbox
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getbBox (( cell cv ))
  setRef(cell->bbx cell->ref)
  getbb(cell->bbx)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get cv bbox
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;defmethod( getDim (( cell cv ))
;  setRef(cell->bbx getRef(cell))
;  getDim(cell->bbx)
;  cell->origin = Origin(cell->bbx)
;  cell->width  = getWidth(cell->bbx)
;  cell->height = getHeight(cell->bbx)
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;defmethod( setDim (( cell cv ))
;  getDim(cell->bbx)
;  cell->origin = Origin(cell->bbx)
;  cell->width  = getWidth(cell->bbx)
;  cell->height = getHeight(cell->bbx)
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Helper method for the getTree method
; Get cv recursive instance tree
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getRecursiveTree (( cell cv ) @key cv cLst)
  prog( (instRef llist rlist lc ic)
       cLst = cons(cv cLst)
       if(!null(cv~>instances) then
         if( length(cv~>instances) > 0 then
           llist = '()
	   rlist = '()
       	   foreach( instance cv~>instances
	     printf("Sniffing ID->[%L]: CV->%s: INST->%s(%s)\n" instance cv~>cellName instance~>cellName instance~>name)
	     instRef = dbOpenCellViewByType(instance~>libName instance~>cellName "layout" "maskLayout")
	     ic = makeInstance( 'cv )
	     setName(ic cv~>cellName)
	     setLib(ic cv~>libName)
	     setBbox(ic->bbx cv~>bBox)
	     add(cell->instances ic)
             rlist = cons(getRecursiveTree(cell ?cv instRef ?cLst llist) rlist)  
	     ;dbClose(instRef)
	   );foreach
	   return(cons(rlist cLst))
         else
           printf("INFO: Leaf Cell: ID->[%L]: %s\n" cv cv~>cellName)
	   lc = makeInstance( 'cv )
	   setName(lc cv~>cellName)
	   setLib(lc cv~>libName)
	   setBbox(lc->bbx cv~>bBox)
	   add(cell->leafCells lc)
           return(cv)
         );if
       else
         printf("INFO: Leaf cell: ID->[%L] %s\n" cv cv~>cellName)
	 lc = makeInstance( 'cv )
	 setName(lc cv~>cellName)
	 setLib(lc cv~>libName)
	 setBbox(lc->bbx cv~>bBox)
	 add(cell->leafCells lc)
	 return(cv)
       );if
  );prog
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get cv instance tree
; populates the leafCell collection
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getTree (( cell cv ))
  cell->iRefs = '()
  cell->iRefs = getRecursiveTree(cell ?cv cell->ref ?cLst '())
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Helper Method for printTree method
; Auxilliary Print cv instance tree 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( printRecursiveTree (( cell cv ) @key hlist nlev cnt)
    prog( (revlist plist)
  	nlev++
	if( listp(hlist) then
	  revlist = reverse(hlist)
	  if( !listp(nth(0 revlist)) && listp(nth(1 revlist)) then
	    plist = nth(0 cdr(revlist))
	    printf("%s NUMBER OF CELLVIEW INSTANCES: %d\n" nth(0 revlist)~>libName length(plist))
	    for(i 0 sub1(length(plist))
	    	if(listp(nth(i plist)) then
		  printf("L%d: %s INST %d (ROOT) : %s, " sub1(nlev) nth(0 revlist)~>libName i nth(0 reverse(nth(i plist)))~>libName)
		else
	          printf("L%d: %s INST %d : %s" sub1(nlev) nth(0 revlist)~>cellName i nth(i plist)~>libName)
		);if
	        cnt = printRecursiveTree(cell ?hlist nth(i plist) ?nlev nlev ?cnt 0) + cnt
	    );for
	    return(cnt)
	   else
	     printf("HLeaf Cell: %s\n"  nth(0 hlist)~>cellName)
	     return(cnt)
	   );if
	else
	   cnt++
	   printf(" (LEAF)\n")
	   return(cnt)
	);if
  );prog
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Prints recursive Instance Tree (Uses Auxilliary method " printRecursiveTree"                            
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( printTree (( cell cv ))
  cell->iCnt = 0
  cell->iCnt = printRecursiveTree(cell ?hlist cell->iRefs ?nlev 0 ?cnt 0)
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Helper Method for getTreeNames method
; Auxilliary Get the instance names of the cv (recursive)                                        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getRecursiveTreeNames (( cell cv ) @key hlist nlev nList)
  prog( (revlist plist)
  	nlev++
	if( listp(hlist) then
	  revlist = reverse(hlist)
	  if( !listp(nth(0 revlist)) && listp(nth(1 revlist)) then
	    nList = cons(nth(0 revlist)~>cellName nList) 
	    plist = nth(0 cdr(revlist))
	    for(i 0 sub1(length(plist))
	        nList = cons(getRecursiveTreeNames(cell ?hlist nth(i plist) ?nlev nlev ?nList '()) nList)
	    );for
	    return(nList)
	   else
	     nList = cons(nth(0 hlist)~>cellName nList) 
	     return(nList)
	   );if
	else
	   nList = cons(hlist~>cellName nList)
	   return(nList)
	);if
  );prog
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Gets recursive Instance Tree Names (Uses  auxilliary method "getRecursiveTreeNames"                             
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getTreeNames (( cell cv ))
  cell->iNames = ()
  cell->iNames = reverse(getRecursiveTreeNames(cell ?hlist cell->iRefs ?nlev 0 ?nList '()))
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Auxilliary Get the instance names of the cv (recursive)                                        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getRecursiveLibTreeNames (( cell cv ) @key hlist nlev nList)
  prog( (revlist plist)
  	nlev++
	if( listp(hlist) then
	  revlist = reverse(hlist)
	  if( !listp(nth(0 revlist)) && listp(nth(1 revlist)) then
	    nList = cons(nth(0 revlist)~>libName nList) 
	    plist = nth(0 cdr(revlist))
	    for(i 0 sub1(length(plist))
	        nList = cons(getRecursiveLibTreeNames(cell ?hlist nth(i plist) ?nlev nlev ?nList '()) nList)
	    );for
	    return(nList)
	   else
	     nList = cons(nth(0 hlist)~>libName nList) 
	     return(nList)
	   );if
	else
	   nList = cons(hlist~>libName nList)
	   return(nList)
	);if
  );prog
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Gets recursive Instance Tree Names (Uses  auxilliary method "getRecursiveTreeNames"                             
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getLibTreeNames (( cell cv ))
  cell->iLibNames = ()
  cell->iLibNames = reverse(getRecursiveLibTreeNames(cell ?hlist cell->iRefs ?nlev 0 ?nList '()))
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the layers used in the cv 
; (use list remove() function to filter out repeated layers - lstFun??)                                        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getLpps (( cell cv ) @key cv cLst)
  prog( (instRef rlist)
       if(!null(cv~>instances) then
         if( length(cv~>instances) > 0 then
	   rlist = '()
       	   foreach( instance cv~>instances
	     printf("Sniffing ID->[%L]: CV->%s: INST->%s(%s)\n" instance cv~>cellName instance~>cellName instance~>name)
	     instRef = dbOpenCellViewByType(instance~>libName instance~>cellName "layout" "maskLayout")
	     if(!null(instRef)  then
	        rlist = cons(getLpps(cell ?cv instRef ?cLst '()) rlist)
	     else
		printf("WARNING: cellview instance not found!")
	     );if  
	   );foreach
	   return(cons(rlist cLst))
         else
	   if(!null(cv~>cellName) then
             printf("Leaf Cell: ID->[%L]: %s\n" cv cv~>cellName)
	     foreach( lpp cv~>lpps
	   	 printf("Leaf Cell Layer: %s: %s\n" cv lpp~>layerName)
		 if(!null(lpp~>layerName) then
		   rlist = cons(lpp~>layerName rlist)
                 else
		   return(rlist)
		 );if 
	     );foreach
             return(rlist)
	   else
	     printf("WARNING: Cell View not found!")
	     return(rlist)
           ):if
         );if
      else
         if(!null(cv~>cellName) then
           printf("INFO (getLpps): No cellview instances found - leaf cell: %s\n" cv~>cellName)
	   foreach( lpp cv~>lpps
	   	 printf("Leaf Cell Layer: %s: %s\n" cv lpp~>layerName) 
		 if(!null(lpp~>layerName) then
		   rlist = cons(lpp~>layerName rlist) 
		 else
		   return(rlist)
		 );if   
	   );foreach
	   return(rlist)
	  else
	    printf("WARNING: Cell View not found!")
	    return(rlist)
          );if
      );if
  );prog
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the layers in the cv                                         
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getLayers (( cell cv ))
  cell->layers = getLpps( cell ?cv cell->ref ?cLst '())
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the layers used in the cv 
; (use list remove() function to filter out repeated layers )                                        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getUsedLayers (( cell cv ))
    getLayers(cell)
    setElems(cell->iLayers cell->layers)
    flattenRecursive(cell->iLayers)
    cell->uLayers = removeRedundant(cell->iLayers)
    cell->uLayers
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Gets the technology layer stackup from the target cellview
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getStackUp (( cell cv ))
    setRef(cell->stack cell->ref)
    getStackUp(cell->stack)
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Create a snapshot using a currently targeted smashed (fully flattened) 
; cellview object reference. Argument is a freshly opened layout cellview
; reference.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( snapshot (( cell cv ))
    setRef(cell->stack cell->ref)
    renderStack(cell->stack)
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Removes layers from the stackup object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod(  removeLayerFromStackup (( cell cv ) arg)
    deleteLayer(cell->stack arg)
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Prints the stackup layer contents
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod(  printStackUp (( cell cv ))
    printStackUp(cell->stack)
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the leaf cells used in the cv
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getLeafCells (( cell cv ))
  cell->leafCells->list->elems
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the pcells used in the cv
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getPcells (( cell cv ))
    nil
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  close and purge the cv
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( closeAndPurge (( cell cv ))
    cell->ref = dbOpenCellViewByType( cell->lib cell->name cell->view "maskLayout")
    if(!null(cell->ref) then
      if( !null(dbPurge(cell->ref)) then
        printf("INFO: Closing and Purging: %s\n:" cell->name )
      else
        printf("WARNING: Cellview not found: %s\n:" cell->name )
      );if
    else
      printf("WARNING: Cellview not found: %s\n:" cell->name )
    );if
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  "Cleans" up a list of cellviews. Open's, closes, purges and then 
;   deletes the list of cellviews in the input argument list.
;   Cellview list must be in the same library as the current cv object's
;   cellview member as determined by the cv->lib member.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( clean (( cell cv ) arg )
  let( (cvName)
           cvName = cell->name
	   foreach( ar arg
	     cell->name = ar
	     closeAndPurge(cell)
	   );foreach	   
	   cell->name = cvName
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method recursively finds all the instances of the given name in
; a cellview heirarchy (See reference procedure in test.il)
; FIXME: Refer to tree view recursive behavior above to get the 
;        recursion right in this method
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( getAllInstances (( cell cv ) name @optional (transform list(0:0 "R0" 1))
;  let( (localCellInfo globalCellInfo iname)
;    localCellInfo = '()
;    iname = lowerCase(name)
;    foreach(inst cv~>instances
;      when(inst~>objType=="inst"
;	printf("Checking instance: %s\n" inst~>cellName)
;	if(rexMatchp(iname lowerCase(inst~>cellName)) then
;	  InternalCellInfo = list(inst~>cellName  dbTransformPoint(inst~>xy transform) inst~>orient)
;	  globalCellInfo = cons(InternalCellInfo GLOBAL_INST)
;	  printf("Adding %s to list" inst~>cellName)
;	);if 
;	getAllInstances(cv inst~>master iname dbConcatTransform(inst~>transform transform) strcat(hierInstPath inst~>cellName "/"))
;      );while
;    );foreach
;    t
;  );let
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Gets recursive Instance Tree Names (Uses  auxilliary method "getRecursiveTreeNames"                             
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( isCell (( cell cv))
  let((cv)
    if(!null(ddGetObj(cell->lib cell->name cell->view )) then
      cv = dbOpenCellViewByType( cell->lib cell->name cell->view "" nil)
      setRef(cell cv)
      t
    else
      nil
    );if
  );let
);

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;###################################################################
;#   instance.ils: instance class
;###################################################################
defclass( instance (cv)
	  (
	      ( inst @Reader getInst @Writer setInst )
	      ( type @Reader getType @Writer setType )
	      ( orient @reader getOrient @writer setOrient)
;	      ( bBox @reader getbBox @writer setbBox)
	      ( flev )		
	  )
);defClass

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Class constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj instance)) 
 	   obj->inst = nil
	   obj->type = nil
	   obj->orient = nil
;	   obj->bBox = nil
	   obj->flev = 32
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method flattens an instance
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( setInstanceBbox (( inst instance ) bb )
;      setBbx(inst->bbx bb)
;      inst->bBox = bb
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Sets the origin of the instance
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( setInstanceOrigin (( inst instance ))
;      getDim(inst->bbx)
;      Origin(inst->bbx)
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Sets the origin of the instance
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( getInstanceOrigin (( inst instance ))
;      getOrigin(inst->bbx)
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method flattens an instance
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( flattenInstance (( inst instance ) )
      if( !null(inst->ref~>cluster) then
        dbFlattenInst(inst->ref~>cluster arg t nil nil)
      else
        dbFlattenInst(inst->ref inst->flev t nil nil)
      );if
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method moves the location of the instance relative to its current
; position
; Argument (arg) is of the form list( dx:dy "R0") 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;defmethod( instanceMove (( inst instance ) arg ) 
;   dbMoveFig(inst->ref inst->cvRef arg)
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method flattens the instance's heirarchy by the levels in the arg.
; arg can range from 0 to 32 levels of heirarchical flattening
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;defmethod( instanceFlatten (( inst instance ) arg )
;    foreach( instance inst->cvRef~>instances
;      if( instance~>mosaic then
;        dbFlattenInst(instance~>mosaic arg t nil nil)
;      else
;        dbFlattenInst(instance arg t nil nil)
;      );if
;    );foreach
;);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  reticle.il: Reticle Object 
;   FIXME: After the inner streets are checked for compliance, there needs to be
;          a check to ensure that the outter streets of the combined die site 
;          outter streets are centered within the reticle outline. The combination
;          of these checks ensures that the inter and intra reticle streets are
;          periodic and can be numbered via the commutative numbering algorithm  
;  FIXME: Coupon XYNPADS need to be detected within the overhead block
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( reticle (cv)
	  (
		( srRes @reader getRes @writer setRes)
		( srGrid @reader getSrGrid @writer setSrGrid)
		( overlap @reader getOverlap @writer setOverlap)
		( maxDim @reader getMaxDim @writer setMaxDim)
		( xynPadChipName @reader getPadChipName @writer setPadChipName)
		( xynPadOverheadName @reader getPadOverheadName @writer setPadOverheadName)
		( xynPadCouponName @reader getPadCouponName @writer setPadCouponName)
		( validDim @reader getDimValid)
		( validRes @reader getResValid)
		( shiftUrq @reader getShiftUrq @writer setShiftUrq)
		( frame @reader getFrame)
		( frameName @reader getFrameName  @writer setFrameName)
		( chipList @reader getChipList)
		( olist @reader getOverheadList)
		( couponList @reader getCouponList)
		( dieSites @reader getDieSites )
		( die )
		( chips @reader getChips)
		( overhead @reader getOverhead)
		( coupons @reader getCoupons)	
		( isPartial @reader getIsPartial )
		( numRetChips @reader getNumRetChips @writer setNumRetChips) 
		( numRetOverhead @reader getNumRetOverhead @writer setNumRetOverhead)
		( numRetCoups @reader getNumRetCoups @writer setNumRetCoups) 
		( numNumPads @reader getNumNumPads)
		( innerStreetOrigs @reader getInnerStreetOrigs)	
		( bnb @reader getBnb)	
		( dieSiteOrig @reader getDieSiteOrig)	
		( dieSiteArray @reader getDieSiteArray)
		( waferRow @reader getWaferRow @writer setWaferRow)
		( waferCol @reader getWaferCol @writer setWaferCol)	
	  )
);defClass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj reticle)) 
	   obj->srRes = nil
	   obj->srGrid = nil
	   obj->overlap = nil
	   obj->maxDim = nil
	   obj->xynPadChipName = nil
	   obj->xynPadOverheadName = nil
	   obj->xynPadCouponName = nil
	   obj->validDim = nil
	   obj->validRes = nil
	   obj->shiftUrq = nil
	   obj->frame = makeInstance( 'reticleFrame )
	   obj->frameName = "memsChipFrame"
 	   obj->die = nil
	   obj->dieSites = makeInstance( 'collection )
	   obj->chipList = nil
	   obj->olist = nil 
	   obj->couponList = nil
	   obj->chips = makeInstance( 'collection )
	   obj->overhead = makeInstance( 'collection )
	   obj->coupons = makeInstance( 'collection ) 
	   obj->isPartial = nil
	   obj->origin = nil 
	   obj->numRetChips = nil 
	   obj->numRetOverhead = nil
	   obj->numRetCoups = nil
	   obj->numNumPads = nil
	   obj->bnb = makeInstance( 'collection )
	   obj->dieSiteOrig = nil
	   obj->dieSiteArray = nil
	   obj->waferRow = nil
	   obj->waferCol = nil
);defmethod
;######################################################
; Clones the contents of this reticle into arg reticle
;######################################################
defmethod( cloneRet ((ret reticle) arg)
   arg->srRes              = ret->srRes 
   arg->srGrid 	           = ret->srGrid 
   arg->overlap	           = ret->overlap 
   arg->maxDim 	           = ret->maxDim 
   arg->xynPadChipName 	   = ret->xynPadChipName 
   arg->xynPadOverheadName = ret->xynPadOverheadName
   arg->xynPadCouponName   = ret->xynPadCouponName 
   arg->validDim	   = ret->validDim 
   arg->validRes           = ret->validRes
   arg->shiftUrq           = ret->shiftUrq
   arg->frame	           = ret->frame 
   arg->frameName          = ret->frameName 
   arg->chipList	   = ret->chipList
   arg->olist 	           = ret->olist  
   arg->couponList 	   = ret->couponList 
   arg->die                = ret->die
   arg->chips 	           = ret->chips 
   arg->overhead 	   = ret->overhead 
   arg->coupons	           = ret->coupons  
   arg->isPartial	   = ret->isPartial 
   arg->origin	           = ret->origin  
   arg->numRetChips 	   = ret->numRetChips 
   arg->numRetOverhead	   = ret->numRetOverhead 
   arg->numRetCoups	   = ret->numRetCoups 
   arg->numNumPads 	   = ret->numNumPads 
   arg->bnb	           = ret->bnb
   arg->dieSiteOrig        = ret->dieSiteOrig
   arg->dieSiteArray       = ret->dieSiteArray
   arg->waferRow           = ret->waferRow
   arg->waferCol           = ret->waferCol
   cloneDieSites(ret arg)
   cloneCv(ret arg)
);defmethod

;######################################################
; Clones the die site collection
;######################################################
defmethod( cloneDieSites ((ret reticle) arg)
  let((col die)
    col = makeInstance( 'collection )
    foreach(item getCollection(ret->dieSites)
      die = makeInstance( 'die )
      cloneDie(item die)
      add(col die)
    );foreach
    arg->dieSites = col
  );let
);defmethod

;######################################################
; This method checks to make sure reticle width and 
; height do not exceed the maximum dimension (maxDim)
;######################################################
defmethod( checkDim ((ret reticle))
  ret->validDim = 't
  getbb(ret)
  getDim(ret)
  if(getWidth(ret) > getMaxDim(ret) then
    printf("ERROR: Reticle Width %8.1f exceeds maximum dimension %f\n" float(getWidth(ret)) float(ret->maxDim) )
    ret->validDim = nil
  else
    printf("INFO: Reticle Width %8.1f is less than maximum dimension %f\n" float(getWidth(ret)) float(ret->maxDim) )
  );if
  if(getHeight(ret) > getMaxDim(ret) then
    printf("ERROR: Reticle Length %8.1f exceeds maximum dimension %f\n" float(getHeight(ret)) float(ret->maxDim) )
    ret->validDim = nil
  else
    printf("INFO: Reticle Length %8.1f is less than maximum dimension %f\n" float(getHeight(ret)) float(ret->maxDim) )
  );if
);defmethod

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for grid requirements????
; FIXME: Get grid information from TF via grid class 
;#####################################################
defmethod( checkGrid ((ret reticle))
  getbb(ret)
  getDim(ret)
  if( abs(quotient(getWidth(ret) ret->srGrid 1.0) - round(getWidth(ret)*10)) > 0.0 then
    printf("ERROR: Reticle Width %g NOT ON a %g um grid\n" float(getWidth(ret)) float(ret->srGrid))
  else
    printf("INFO: Reticle Width %g step is CORRECTLY on a %g um grid\n" float(getWidth(ret)) float(ret->srGrid))
  );if
  if( abs(quotient(getHeight(ret) ret->srGrid 1.0) - round(getHeight(ret)*10)) > 0.0 then
    printf("ERROR: Reticle Height %g step resolution NOT ON a %g um grid\n" ret->bb->height ret->srGrid)
  else
    printf("INFO: Reticle Height %g step is CORRECTLY on a %g um grid\n" float(getHeight(ret)) float(ret->srGrid))
  );if
);defmethod

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for Step and Repeat (S&R) value 
; provided
;#####################################################
defmethod( checkRes (( ret reticle ))
 let((rwidth rheight)
    ret->validRes = 't
    getbb(ret)
    getDim(ret)
    rwidth =  getWidth(ret) - ret->overlap
    rheight = getHeight(ret) - ret->overlap
    printf("INFO: Reticle Overlap Setting: %5.1f\n" float(ret->overlap))
    printf("INFO: Reticle S&R Setting: %5.1f\n" float(ret->srRes))
    if(quotient(rwidth ret->srRes) - int(quotient(rwidth ret->srRes)) > 0 then
      printf("ERROR: Overlap Compensated Reticle Width %5.1f DOES NOT MEET required S&R step resolution of %3.1f\n" float(rwidth) float(ret->srRes))
      ret->validRes = nil     
    else
      printf("INFO: Overlap Compensated Reticle Width %5.1f MEETS required S&R step resolution of %3.1f\n" float(rwidth) float(ret->srRes))
    );if
    if(quotient(rwidth ret->srRes) - int(quotient(rwidth ret->srRes)) > 0 then
      printf("ERROR: Overlap Compensated Reticle Length %5.1f DOES NOT MEET required S&R step resolution of %3.1f\n" float(rheight) float(ret->srRes))
      ret->validRes = nil
    else
      printf("INFO: Overlap Compensated Reticle Length %5.1f MEETS required S&R step resolution of %3.1f\n" float(rheight) float(ret->srRes))
    );if
  );let
); defmethod

;#####################################################
; This method checks the periodicity of the inside
; streets of reticle and ensures that each inner street
; extends the full length of the reticle without any 
; jogging
; 
; 1.) generate a row/col matrix for the die sites
; 2.) find the origin of all die sites
; 3.) make sure the row,col matrix origin coordinates
;     are periodic in their respective dimension  
;#####################################################
;defmethod( CheckPeriodicity (( ret reticle )) 
  ; Periodicity check of verticle streets
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Scribe line pointer
  ; xs = 0
  ; xs = getVerticalScribes(ret)
  ; 
  ; Intra-Reticle (Die Site Counter)
  ; lx = 0
  ; while( car( inst~>xy) - lx > xynpl->retW
  ;	ix = ix + length( sl)
  ;	lx = lx + xynpl->retW
  ;    )
  ;     advance to the next scribe line, 
  ;     or reset to the first scribe when we pass the right edge of reticle:
  ;    xs = or( cdr( xs) sl)
  ;x = xCoord(getOrigin(ret))
  ;while( x >= getWidth(ret) 
  ;       printf("X coordinate %L is greater than reticle width %L subtracting width" x getWidth(ret))
  ;       x = x - getWidth(ret)
  ;       printf( "New X value %L:" x )
  ;);while
  ;	   
;  nil
;);

;#####################################################
; Checks that inner streets are conformant to the
; requirement that they extend the full length of 
; the reticle
;#####################################################
defmethod( checkInnerStreets (( ret reticle ))
  let( ( slx sly sorted cols rows origsx origsy dieCount dieSiteCount slxc slyc dsc dscList n conform)
    origsx = '()
    origsy = '()
    foreach( dieSite getCollection(ret->dieSites)
      origsx = cons(xCoord(Origin(dieSite)) origsx)
      origsy = cons(yCoord(Origin(dieSite)) origsy)
    );foreach
    slx = '()
    foreach( posx origsx
       if(null(member(posx slx)) then
         slx = cons(posx slx)
       );if
    );foreach
    sly = '()
    foreach( posy origsy
       if(null(member(posy sly)) then
         sly = cons(posy sly)
       );if
    );foreach
    foreach( posx origsx
      ;printf( "Die Site X Position: %L\n" posx)
      ; create a list of chip unique x values
      ; INLINE IF: if(member( car( posn) sl)  sl = cons( car( posn)  sl):nil)
      unless( member( car( origsx) slx) slx = cons( car( origsx) slx))
      cdr(origsx)
    );foreach
    foreach( posy origsx
      ;printf( "Die Site Y Position: %L\n" posy)
      ; create a list of chip unique y values
      ; INLINE IF: if(member( car( posn) sl)  sl = cons( car( posn)  sl):nil)
      unless( member( car( origsy) sly) sly = cons( car( origsx) sly))
      cdr(origsy)
    );foreach
    sortedx = sort( slx 'lessp)
    sortedy = sort( sly 'lessp)
    printf("INFO: Number of Vertical Inner Streets Detected: %d\n" length(sortedx))
    printf("INFO: Number of Horizontal Inner Streets Detected: %d\n" length(sortedy))
    dieSiteCount = length(sortedx)*length(sortedy)
    dieCount = length(getCollection(ret->dieSites))
    if(dieSiteCount != dieCount then
       printf("ERROR: Die number: %d, NOT EQUAL TO Die site inner street defined array total: %d\n"  dieCount dieSiteCount)
       println("ERROR: Non-Conformant Inner Street Structure!")
       conform = nil
    else
       printf("INFO: Die number: %d, EQUALS Die site inner street defined array total: %d\n"  dieCount dieSiteCount)
       println("INFO: Conformant Inner Street Structure")
       conform = 't
    );
    if(conform then
      println( "Reticle Vertical Scribe Line X Coord List:")
      cols=0
      slxc = '()
      foreach(sort sortedx
        printf( "%d.) SLX Coord: %L\n" cols sort)
        slxc = cons(sort slxc)
        cols++
      );foreach
      println( "Reticle Horizontal Scribe Line Y Coord List:")
      rows=0
      slyc = '()
      foreach(sort sortedy
        printf( "%d.) SLY Coord: %L\n" rows sort)
        slyc = cons(sort slyc)
        rows++
      );foreach
      ;println( "Reticle Street Array Defined Die Site Origin List:")
      n = 0
      dscList = '()
      for(i 0 sub1(rows)
        for(j 0 sub1(cols)
          dsc = list(nth(i slxc) nth(j slyc))
      	  dscList = cons(dsc dscList)
          ;printf("%d.) ROW: %d COL: %d, Origin: %L\n" n i j dsc)
	  n++
        );for
      );for      
      ret->dieSiteOrig = dscList
      ret->dieSiteArray = list(cols rows)
    else
      nil
    );if
  );let
);defmethod

;#####################################################
; Generates the intra reticle die sites. Need to run
; "checkInnerStreets" method first.
; FIXME: need checksum validation. Make sure that the number
;        of generated die sites equals the number of
;        die in the reticle and that the origins of 
;        the generated die site and the actual die
;        origins are also equivalent.
;#####################################################
defmethod( arrayDieSites (( ret reticle ))
  let((n dorig ind aorig)
    foreach( die getCollection(ret->dieSites)
      dorig = Origin(die)
      ind = 0
      for(i 0 sub1(xCoord(ret->dieSiteArray))
        for(j 0 sub1(yCoord(ret->dieSiteArray))
          ind = i*xCoord(ret->dieSiteArray) + j
          aorig = nth(ind ret->dieSiteOrig)
	  if(xCoord(dorig) == xCoord(aorig) && yCoord(dorig) == yCoord(aorig) then
	    setReticleRow(die i)
	    setReticleCol(die j)
          );if
        );for
      );for 
    );foreach
    n = 0
    foreach( die getCollection(ret->dieSites)
      printf("INFO: die #%d, ROW: %d COL: %d\n" n getReticleRow(die) getReticleCol(die))
      n++
    )
   n
  );let
);defmethod

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for Step and Repeat (S&R) value 
; provided
;#####################################################
defmethod( chipId (( ret reticle ))
  nil
);

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for Step and Repeat (S&R) value 
; provided
;#####################################################
defmethod( renderRetBbox (( ret reticle ))
  let((bbv shp lay dsbbv dshp)
    bbv = bb2vert(ret)
    shp = makeInstance( 'shape )
    setLayer(shp "GRID")
    setPurpose(shp "drawing")
    setVertices(shp bbv)
    setVertices(shp->transform bbv) 
    lay = makeInstance( 'techLayer )
    setName(lay "GRID")
    setPurpose(lay "drawing")
    addShape(lay shp)
    foreach(ds getCollection(ret->dieSites)
      dshp = makeInstance( 'shape )
      dsbbv = bb2vert(ds)   
      setLayer(dshp "GRID")
      setPurpose(dshp "drawing")
      setVertices(dshp dsbbv)
      setVertices(dshp->transform bbv) 
      addShape(lay dshp)
    );foreach
    setRef(lay getRef(ret))
    renderShapesOnLayer(lay)
  );let
);
;#####################################################
; Delete reticle bbox shapes
;#####################################################
defmethod( erase (( ret reticle ))
  let((cv)
    cv = getRef(ret)
    if(!null(cv~>shapes) then
      foreach( shape cv~>shapes
        if(shape~>layerName == "GRID" then   
          dbDeleteObject(shape)
        );if
      );foreach
    );if
  );let
);

;#####################################################
; This method searches the reticle instances for the
; xynPad. It only searches for the pad in instances
; one level below the top level reticle cellview
;#####################################################
defmethod( findXynPads (( ret reticle ))
  let((dlist olist clist cv numPadCount chipPadCount overheadPadCount couponPadCount chip coupon cvchip)
    resetCollection(ret->chips)
    resetCollection(ret->coupons)
    numPadCount = 0
    chipPadCount = 0
    overheadPadCount = 0
    couponPadCount = 0
    dlist = '()
    clist = '()
    cv = getRef(ret)
    foreach( ih cv~>instHeaders
      printf("Instance Header Name: %s \n" ih~>cellName)
      foreach( inst ih~>instances
        printf("Instance Name: %s \n" inst~>cellName)
        foreach( cell inst~>master~>instances
          printf("Cell Name: %s \n" cell~>cellName)
          if(!null(strcmp(cell~>cellName ret->xynPadChipName) == 0) then
	    numPadCount++
	    chipPadCount++
            printf("%d.) XYN CHIP PAD FOUND!: %s, In chip: %s \n" numPadCount cell~>cellName inst~>cellName)
	    dlist = cons(inst~>cellName dlist)
	    chip = makeInstance( 'chip )
	    setName(chip inst~>cellName)
	    setLib(chip getLib(ret))
	    setView(chip getView(ret))
	    setOrient(chip inst~>orient)
	    setBbx(getBbx(chip) inst~>bBox)
	    getDim(getBbx(chip))
	    Origin(getBbx(chip))
	    setName(chip->numpad cell~>cellName)
            setOrient(chip->numpad cell~>orient)
	    setBbx(getBbx(chip->numpad) cell~>bBox)
	    getDim(getBbx(chip->numpad))
	    Origin(getBbx(chip->numpad))
	    ;setChipBbox(chip inst~>bbox)
	    ;setPadBbox(chip cell~>bBox)
	    ;setInstanceBbox(chip inst~>bBox)
	    ;getDim(chip)
	    addChip(ret chip)
          );
	  if(!null(strcmp(cell~>cellName ret->xynPadOverheadName) == 0) then
	    numPadCount++
	    overheadPadCount++
            printf("%d.) XYN OVERHEAD PAD FOUND!: %s, In chip: %s \n" numPadCount cell~>cellName inst~>cellName)
	    olist = cons(inst~>cellName olist)
	    oh = makeInstance( 'overhead )
	    setName(oh inst~>cellName)
	    setLib(oh getLib(ret))
	    setView(oh getView(ret))
	    setOrient(oh inst~>orient)
	    setBbx(getBbx(oh) inst~>bBox)
	    getDim(getBbx(oh))
	    Origin(getBbx(oh))
	    setName(oh->numpad cell~>cellName)
            setOrient(oh->numpad cell~>orient)
	    setBbx(getBbx(oh->numpad) cell~>bBox)
	    getDim(getBbx(oh->numpad))
	    Origin(getBbx(oh->numpad))
	    ;setChipBbox(oh inst~>bbox)
	    ;setPadBbox(oh cell~>bBox)
	    ;setInstanceBbox(oh inst~>bBox)
	    ;getDim(oh)
	    addOverhead(ret oh)
          );
	  ;if(!null(strcmp(cell~>cellName ret->xynPadCouponName) == 0) then
          ;  numPadCount++
	  ;  couponPadCount++
          ;  printf("%d.) XYN COUPON PAD FOUND!: %s, In coupon: %s \n" numPadCount cell~>cellName inst~>cellName)
	  ;  clist = cons(inst~>cellName clist)
          ;);
        );foreach
      );foreach
    );foreach
    dlist = sort(dlist nil)
    clist = sort(clist nil)
    ret->chipList = dlist
    ret->olist = olist
    ret->couponList = clist
    ret->numNumPads = numPadCount
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Sorts chips based on the whether the chip is a chip or a coupon,
;              then on the naming convention adopted on 06/08
;                    Chips/Legacy Coupons: NN[N]  (e.g.  99, 970)
;                    New Standard Coupons: PPNNR  (e.g. 8099A)
;                New Experimental Coupons: XPPNNR (e.g. X8001A)
;                         Legend -  N - Number
;                                   P - Process
;                                   R - Revision
;                                  [] - Optional
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;#####################################################
; Digitizes a number (num) to a list of digits of 
; length digits
;#####################################################
defmethod( digitize (( ret reticle ) num)
  let((digits format dlist)
    ;FIXME: add a second argument for digits
    digits = 3
    format = sprintf( nil "%%0%dd" digits)
    dlist = parseString( sprintf( nil format num) "")
  );let
);defmethod

;#####################################################
; Add chip to chips collection
;#####################################################
defmethod( addChip (( ret reticle ) arg)
  if( classp( arg 'chip) then
    add(ret->chips arg)
  else
    println("ERROR(reticle): Argument must be a chip object")
  );if
);defmethod

;#####################################################
; Add overhead to overhead collection
;#####################################################
defmethod( addOverhead (( ret reticle ) arg)
  if( classp( arg 'overhead) then
    add(ret->overhead arg)
  else
    println("ERROR(reticle): Argument must be an overhead object")
  );if
);defmethod

;#####################################################
; Add coupon to couponss collection
;#####################################################
defmethod( addCoupon (( ret reticle ) arg)
  if( classp( arg 'coupon) then
    add(ret->coupons arg)
  else
    println("ERROR(reticle): Argument must be a coupon object")
  );if
);defmethod


;#####################################################
; Updates the relative position, relPos member,  of the 
; chips and pad locations within the reticle based upon
; the reticleOrigin value
;#####################################################
defmethod( update (( ret reticle ))
  nil
);defmethod

;#####################################################
; Updates the relative position, relPos member,  of the 
; chips and pad locations within the reticle based upon
; the reticleOrigin value
;#####################################################
defmethod( checkSum (( ret reticle ))
  let((psum)
    psum = getNumRetChips(ret) + getNumRetOverhead(ret)
    if(!null(psum == getNumNumPads(ret)) then
       printf("INFO: Reticle Coupon Checksum Passed, Chips+Overhead: %d, numPads: %d\n" psum getNumNumPads(ret))
    else
       printf("ERROR: Reticle Coupon Checksum FAILED!, Chips+Overhead: %d, numPads: %d\n" psum getNumNumPads(ret))
    ); 
  );
);defmethod

;#####################################################
; Updates the relative position, relPos member,  of the 
; chips and pad locations within the reticle based upon
; the reticleOrigin value
;#####################################################
defmethod( detectDieSites (( ret reticle ))
  let((die i cv masters instances)
    cv = getRef(ret)
    masters = cv~>instanceMasters
    instances = cv~>instances
    i = 0
    foreach( instance instances
      if(instance~>cellName == ret->frameName then
        die = makeInstance( 'die )
        setName(die instance~>cellName)
        setLib(die instance->libName)
	setBbox(die instance~>bBox)
	Origin(die)
        add(ret->dieSites die)
	printf("INFO(reticle): Die Site #%d Detected: %s\n" i  getName(die))
        printf("               ORIGIN: %L, WIDTH: %L HEIGHT: %L\n" Origin(die) getWidth(die) getHeight(die))
	i++
      );if
    );foreach
  );let
);defmethod

;#####################################################
; Sets the reticle and die site origins
;#####################################################
defmethod( setReticleOrigin (( ret reticle ) arg)
  let((retOrig orig shx shy)
    retOrig = Origin(ret)
    shx = xCoord(arg)-xCoord(retOrig) 
    shy = yCoord(arg)-yCoord(retOrig)
    shiftOrigin(ret list(shx shy))
    foreach(die getCollection(ret->dieSites)
      shiftOrigin(die list(shx shy))
    );foreach
  );let
);defmethod

;######################################################
;######################################################
;######################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  numberPad.ils: number pad class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( numberPad (cv)
  (
    ( row @reader getRow @writer setRow )
    ( col @reader getCol @writer setCol )
  )
);defClass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj numberPad))
  obj->row  = nil 
  obj->col  = nil
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Update the pad center coordinates
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( update (( np numberPad ))
  np->centroid = list(np->origin+np->width/2.0 np->origin+np->height/2.0)
);defmethod
;######################################################
;######################################################
;######################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  chipNumberPad.ils: chip number pad class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( chipNumberPad (numberPad)
  (
    ( type @reader getType @writer setType )
  )
);defClass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj chipNumberPad))
  obj->type = nil 
);defmethod
;######################################################
;######################################################
;######################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  couponNumberPad.ils: coupon number pad class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( couponNumberPad (numberPad)
);defClass
;######################################################
;######################################################
;######################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  die.ils: die class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( die (cv)
  (
    ( reticle @reader getReticle @writer setReticle )
    ( number @reader getNumber @writer setNumber )
    ( revision @reader getRev @writer setRev )
    ( reticleRow @reader getReticleRow @writer setReticleRow )
    ( reticleCol @reader getReticleCol @writer setReticleCol )
    ( waferRow @reader getWaferRow @writer setWaferRow )
    ( waferCol @reader getWaferCol @writer setWaferCol )
    ( numpad )
  )
);defClass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj die))
  obj->reticle    = nil 
  obj->number     = nil
  obj->revision   = nil
  obj->reticleRow = nil
  obj->reticleCol = nil
  obj->waferRow   = nil
  obj->waferCol   = nil
  obj->numpad = makeInstance( 'chipNumberPad )
);defmethod
;#####################################################
; clones the die
;#####################################################
defmethod( cloneDie (( d die ) arg)
  arg->reticle    = d->reticle
  arg->number     = d->number
  arg->revision   = d->revision
  arg->reticleRow = d->reticleRow
  arg->reticleCol = d->reticleCol
  arg->waferRow   = d->waferRow
  arg->waferCol   = d->waferCol
  cloneCv(d arg)
);defmethod
;######################################################
;######################################################
;######################################################




	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  chip.ils: chip class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( chip (die)
  (
    (numpad @reader getNumPad)
  )
);defClass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj chip)) 
  obj->numpad = makeInstance( 'chipNumberPad )
);defmethod
;######################################################
;#####################################################
; Sets the boundary box of the chip numbers pad
;#####################################################
defmethod(setChipBbox  (( ch chip ) bbx)
  setBbx(ch->bbx bbx)
  ;getDim(ch->bbx)
  ;Origin(ch->bbx)
);defmethod
;######################################################
;#####################################################
; Sets the boundary box of the chip numbers pad
;#####################################################
defmethod(setPadBbox  (( ch chip ) bbx)
  setBbx(ch->numpad->bbx bbx)
  ;getDim(ch->numpad->bbx)
  ;Origin(ch->numpad->bbx)
);defmethod
;######################################################
;######################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  coupon.ils: coupon class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( coupon (die)
  (
    (numpad @reader getNumPad)
  )
);defClass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj coupon)) 
  obj->numpad = makeInstance( 'couponNumberPad )
);defmethod
;######################################################
;######################################################
;######################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  overhead.ils: overhead class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( overhead (die)
  (
    (numpad @reader getNumPad)
    (coupons @reader getCoupons)
    (amarks @reader getAmarks)
  )
);defClass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj overhead)) 
  obj->numpad = makeInstance( 'chipNumberPad )
  obj->coupons = makeInstance( 'collection )
  obj->amarks = makeInstance( 'collection )
);defmethod
;######################################################
;#####################################################
; Sets the boundary box of the chip numbers pad
;#####################################################
defmethod(setChipBbox  (( oh overhead ) bbx)
  setBbx(ch->bbx bbx)
  ;getDim(ch->bbx)
  ;Origin(ch->bbx)
);defmethod
;######################################################
;#####################################################
; Sets the boundary box of the chip numbers pad
;#####################################################
defmethod(setPadBbox  (( oh overhead ) bbx)
  setBbx(oh->numpad->bbx bbx)
  ;getDim(oh->numpad->bbx)
  ;Origin(oh->numpad->bbx)
);defmethod
;######################################################
;######################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  reticleFrame.ils: reticleFrame class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( reticleFrame (die)
  (
    (overlap @reader getOverlap)
  )
);defClass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj reticleFrame)) 
  obj->overlap = 4.0
);defmethod
;######################################################
;#####################################################
; Sets the boundary box of the chip numbers pad
;#####################################################
defmethod(setChipBbox  (( rf reticleFrame ) bbx)
  setBbx(rf->bbx bbx)
  ;getDim(rf->bbx)
  ;Origin(rf->bbx)
);defmethod
;######################################################
;#####################################################
; Sets the boundary box of the chip numbers pad
;#####################################################
defmethod(setPadBbox  (( rf reticleFrame ) bbx)
  setBbx(rf->numpad->bbx bbx)
  ;getDim(rf->numpad->bbx)
  ;Origin(rf->numpad->bbx)
);defmethod
;######################################################
;######################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  alpha.ils: alphabet class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( alpha (polygon2)
	  ( 
		( val @reader getVal @writer setVal) 
		( width @reader getWidth @writer setWidth )
		( height @reader getHeight @writer setHeight )
		( scale @reader getScale @writer setScale )
		( ca )
		( cb )
		( cc )
		( cd )
		( ce )
		( cf )
		( cg )
		( ch )
		( ci )
		( cj )
                ( ck )
                ( cl )
                ( cm )
                ( cn )
                ( co )
                ( cp )
                ( cq )
                ( cr )
		( cs )
		( ct )
		( cu )
		( cv )
		( cw )
		( cx )
		( cy )
		( cz )								
	  )
);defClass
;#####################################################
; Class constructor
; This method initializes the class
; Initialized/Default Heigth is 50
;#####################################################
defmethod( initializeInstance @after ((obj alpha))  
	   obj->val = nil
	   obj->width = nil
	   obj->height = nil
	   obj->scale = 1.0
	   obj->ca  = list(list(4.0 0.0) 
			   list(4.0 4.0) 
			   list(6.8 4.0) 
			   list(6.8 8.0) 
			   list(4.0 8.0)
			   list(4.0 11.2) 
			   list(8.0 15.2) 
			   list(12.0 11.2) 
			   list(12.0 8.0) 
			   list(9.2 8.0)
			   list(9.2 4.0) 
			   list(12.0 4.0) 
			   list(12.0 0.0) 
			   list(16.0 0.0) 
		           list(16.0 14.0)
			   list(10.0 20.0) 
			   list(6.0 20.0) 
			   list(0.0 14.0) 
			   list(0.0 0.0))
	   obj->cb = list( list(6.4 0.0) 
		           list(6.4 4.0) 
		           list(4.0 4.0) 
			   list(4.0 8.0) 
			   list(11.0 8.0)
			   list(12.0 7.0) 
			   list(12.0 5.0) 
			   list(11.0 4.0) 
			   list(8.8 4.0)
			   list(8.8 0.0)
			   list(13.0 0.0)	
			   list(16.0 3.0)
			   list(16.0 8.0)
			   list(14.0 10.0)
			   list(16.0 12.0)
			   list(16.0 17.0)
			   list(13.0 20.0)
			   list(8.8 20.0)
			   list(8.8 16.0)
			   list(11.0 16.0)
			   list(12.0 15.0)
			   list(12.0 13.0)
			   list(11.0 12.0)
			   list(4.0 12.0)
			   list(4.0 16.0)
			   list(6.4 16.0)
			   list(6.4 20.0)
			   list(0.0 20.0)
			   list(0.0 0.0))
	   obj->cc = list(list(3.2 0.0) 
			  list(12.8 0.0) 
			  list(16.0 3.2) 
			  list(16.0 7.2) 
			  list(12.0 7.2)
			  list(12.0 5.2) 
			  list(10.8 4.0) 
			  list(5.2 4.0) 
			  list(4.0 5.2) 
			  list(4.0 14.8)
			  list(5.2 16.0) 
			  list(10.8 16.0) 
			  list(12.0 14.8) 
			  list(12.0 13.2) 
			  list(16.0 13.2)
			  list(16.0 16.8) 
			  list(12.8 20.0) 
			  list(3.2 20.0) 
			  list(0.0 16.8) 
			  list(0.0 3.2))
	   obj->cd = list(list(12.0 0.0) 
			  list(16.0 4.0) 
			  list(16.0 16.0) 
			  list(12.0 20.0) 
		          list(8.0 20.0)
			  list(8.0 16.0) 
			  list(10.0 16.0) 
		          list(12.0 14.0) 
			  list(12.0 6.0) 
			  list(10.0 4.0)
			  list(4.0 4.0) 
			  list(4.0 16.0) 
			  list(5.6 16.0) 
		          list(5.6 20.0) 
			  list(0.0 20.0)
		          list(0.0 0.0))
	   obj->ce = list(list(16.0 0.0) 
			  list(16.0 4.0) 
			  list(4.4 4.0) 
			  list(4.4 8.0) 
			  list(12.8 8.0)
			  list(12.8 12.0) 
			  list(4.4 12.0) 
			  list(4.4 16.0) 
			  list(16.0 16.0) 
			  list(16.0 20.0)
			  list(0.0 20.0) 
			  list(0.0 0.0))
	   obj->cf = list(list(4.0 0.0) 
			  list(4.0 8.0) 
			  list(12.8 8.0) 
			  list(12.8 12.0) 
			  list(4.0 12.0)
			  list(4.0 16.0) 
			  list(16.0 16.0) 
			  list(16.0 20.0) 
			  list(0.0 20.0) 
			  list(0.0 0.0))
	   obj->cg = list(list(3.2 0.0) 
			  list(13.2 0.0) 
			  list(16.0 3.2) 
			  list(16.0 10.8) 
			  list(8.0 10.8)
		          list(8.0 6.8) 
			  list(12.0 6.8) 
			  list(12.0 5.2) 
			  list(10.8 4.0) 
			  list(5.2 4.0)
			  list(4.0 5.2) 
			  list(4.0 14.8) 
			  list(5.2 16.0) 
			  list(10.8 16.0) 
			  list(12.0 14.8)
			  list(12.0 14.0) 
			  list(16.0 14.0) 
			  list(16.0 16.8) 
			  list(13.2 20.0) 
			  list(3.2 20.0)
			  list(0.0 16.8) 
			  list(0.0 3.2))
	   obj->ch = list(list(4.0 0.0) 
		     	  list(4.0 8.4) 
			  list(12.0 8.4) 
			  list(12.0 0.0) 
			  list(16.0 0.0)
			  list(16.0 20.0) 
			  list(12.0 20.0) 
			  list(12.0 12.4) 
			  list(4.0 12.4) 
			  list(4.0 20.0)
			  list(0.0 20.0)
			  list(0.0 0.0))
	   obj->ci = list(list(12.0 0.0) 
			  list(12.0 4.0) 
			  list(8.0 4.0) 
			  list(8.0 16.0) 
			  list(12.0 16.0)
			  list(12.0 20.0) 
			  list(0.0 20.0) 
			  list(0.0 16.0) 
			  list(4.0 16.0) 
			  list(4.0 4.0)
			  list(0.0 4.0) 
			  list(0.0 0.0))
	   obj->cj = list(list(3.2 0.0) 
			  list(13.6 0.0) 
			  list(16.0 2.4) 
			  list(16.0 20.0) 
			  list(12.0 20.0)
			  list(12.0 4.0) 
			  list(4.0 4.0) 
			  list(4.0 8.8) 
			  list(0.0 8.8) 
			  list(0.0 3.2))
	   obj->ck = list(list(4.4 0.0) 
			  list(4.4 5.6) 
			  list(5.6 5.6) 
			  list(11.2 0.0) 
			  list(15.2 0.0)
			  list(15.2 1.6) 
			  list(6.8 10.0) 
			  list(15.2 18.4) 
			  list(15.2 20.0) 
			  list(11.2 20.0)
			  list(5.6 14.4) 
			  list(4.4 14.4) 
			  list(4.4 20.0) 
			  list(0.0 20.0) 
			  list(0.0 0.0))
	   obj->cl = list(list(12.0 0.0) 
			  list(12.0 4.0) 
			  list(4.0 4.0) 
			  list(4.0 20.0) 
			  list(0.0 20.0)
			  list(0.0 0.0))
	   obj->cm = list(list(4.0 0.0) 
			  list(4.0 12.0) 
			  list(5.2 12.0) 
			  list(8.0 9.2) 
			  list(10.8 12.0)
			  list(12.0 12.0) 
			  list(12.0 0.0) 
			  list(16.0 0.0) 
			  list(16.0 20.0) 
			  list(12.8 20.0)
			  list(8.0 15.2) 
			  list(3.2 20.0) 
			  list(0.0 20.0) 
			  list(0.0 0.0))
	   obj->cn = list(list(4.0 0.0) 
			  list(4.0 9.2) 
			  list(5.2 9.2) 
			  list(12.0 2.4) 
			  list(12.0 0.0)
			  list(16.0 0.0) 
			  list(16.0 20.0) 
			  list(12.0 20.0) 
			  list(12.0 10.4) 
			  list(10.8 10.4)
			  list(1.2 20.0) 
			  list(0.0 20.0) 
			  list(0.0 0.0))
	   obj->co = list(list(4.0 0.0) 
			  list(12.0 0.0) 
			  list(16.0 4.0) 
			  list(16.0 8.8) 
			  list(12.0 8.8)
			  list(12.0 6.0) 
			  list(10.0 4.0) 
			  list(6.0 4.0) 
			  list(4.0 6.0) 
			  list(4.0 8.8)
			  list(0.0 8.8) 
			  list(0.0 4.0)
                          list(16.0 16.0)
			  list(12.0 20.0)
			  list(4.0 20.0)
			  list(0.0 16.0)
			  list(0.0 11.2)
			  list(4.0 11.2)
			  list(4.0 14.0)
			  list(6.0 16.0)
			  list(10.0 16.0)
			  list(12.0 14.0)
			  list(12.0 11.2)
			  list(16.0 11.2))
	   obj->cp = list(list(4.0 0.0) 
			  list(4.0 6.8) 
			  list(10.8 6.8) 
			  list(14.0 10.0) 
			  list(14.0 16.8)
			  list(10.8 20.0) 
			  list(7.6 20.0) 
			  list(7.6 16.0) 
			  list(8.8 16.0) 
			  list(10.0 14.8)
			  list(10.0 12.0) 
			  list(8.8 10.8) 
			  list(4.0 10.8) 
			  list(4.0 16.0) 
			  list(5.2 16.0)
			  list(5.2 20.0) 
			  list(0.0 20.0) 
			  list(0.0 0.0))
	   obj->cq = list(list(4.0 0.0) 
			  list(12.0 0.0) 
			  list(13.2 1.2) 
			  list(14.4 0.0) 
			  list(16.0 0.0)
			  list(16.0 2.0) 
			  list(14.8 3.2) 
			  list(16.0 4.4) 
			  list(16.0 16.0) 
			  list(12.0 20.0)
			  list(9.2 20.0) 
			  list(9.2 16.0) 
			  list(10.0 16.0) 
			  list(12.0 14.0) 
			  list(12.0 6.0)
			  list(10.0 6.0) 
			  list(10.0 4.0) 
			  list(6.0 4.0) 
			  list(4.0 6.0) 
			  list(4.0 14.0)
			  list(6.0 16.0) 
			  list(6.8 16.0) 
			  list(6.8 20.0) 
			  list(4.0 20.0) 
			  list(0.0 16.0)
			  list(0.0 4.0))
	   obj->cr = list(list(4.0 0.0) 
			  list(4.0 6.8) 
			  list(7.2 6.8) 
			  list(10.0 4.0) 
			  list(10.0 0.0)
			  list(14.0 0.0) 
			  list(14.0 5.2) 
			  list(11.2 8.0) 
			  list(14.0 10.8) 
			  list(14.0 16.8)
			  list(10.8 20.0) 
			  list(7.6 20.0) 
			  list(7.6 16.0) 
			  list(8.8 16.0) 
			  list(10.0 14.8)
			  list(10.0 12.0) 
			  list(8.8 10.8) 
			  list(4.0 10.8) 
			  list(4.0 16.0) 
			  list(5.2 16.0)
			  list(5.2 20.0) 
			  list(0.0 20.0) 
			  list(0.0 0.0))
	   obj->cs = list(list(3.2 0.0) 
			  list(13.2 0.0) 
			  list(16.0 3.2) 
			  list(16.0 8.8) 
			  list(12.8 12.0)
			  list(5.2 12.0) 
			  list(4.0 13.2) 
			  list(4.0 14.8) 
			  list(5.2 16.0) 
			  list(10.8 16.0)
			  list(12.0 14.8) 
			  list(12.0 14.0) 
			  list(16.0 14.0) 
			  list(16.0 16.8) 
			  list(12.8 20.0)
			  list(3.2 20.0) 
			  list(0.0 16.8) 
			  list(0.0 11.2) 
			  list(3.2 8.0) 
			  list(10.8 8.0)
			  list(12.0 6.8) 
			  list(12.0 5.2) 
			  list(10.8 4.0) 
			  list(5.2 4.0) 
			  list(4.0 5.2)
			  list(4.0 6.0)
			  list(0.0 6.0)
			  list(0.0 3.2))
	   obj->ct = list(list(6.0 16.0) 
			  list(6.0 0.0) 
			  list(10.0 0.0) 
			  list(10.0 16.0) 
			  list(16.0 16.0)
			  list(16.0 20.0) 
			  list(0.0 20.0) 
			  list(0.0 16.0))
	   obj->cu = list(list(3.2 0.0) 
			  list(12.8 0.0) 
			  list(16.0 3.2) 
			  list(16.0 20.0) 
			  list(12.0 20.0)
			  list(12.0 5.2) 
			  list(10.8 4.0) 
			  list(5.2 4.0) 
			  list(4.0 5.2) 
			  list(4.0 20.0)
			  list(0.0 20.0) 
			  list(0.0 3.2))
	   obj->cv = list(list(6.0 0.0) 
			  list(10.0 0.0) 
			  list(16.0 6.0) 
			  list(16.0 20.0) 
			  list(12.0 20.0)
			  list(12.0 8.0) 
			  list(8.8 4.8) 
			  list(7.2 4.8) 
			  list(4.0 8.0) 
			  list(4.0 20.0)
			  list(0.0 20.0) 
			  list(0.0 6.0))
	   obj->cw = list(list(5.2 0.0) 
			  list(8.0 2.8) 
			  list(10.8 0.0) 
			  list(16.0 5.2) 
			  list(16.0 20.0)
			  list(12.0 20.0) 
			  list(12.0 6.4) 
			  list(10.8 6.4) 
			  list(8.0 9.2) 
			  list(5.2 6.4)
			  list(4.0 6.4) 
			  list(4.0 20.0) 
			  list(0.0 20.0) 
			  list(0.0 5.2))
	   obj->cx = list(list(4.0 0.0) 
			  list(4.0 3.2) 
			  list(8.0 7.2) 
			  list(12.0 3.2) 
			  list(12.0 0.0)
			  list(16.0 0.0) 
			  list(16.0 4.8) 
			  list(10.8 10.0) 
			  list(16.0 15.2) 
			  list(16.0 20.0)
			  list(12.0 20.0) 
			  list(12.0 17.2) 
			  list(8.0 13.2) 
			  list(4.0 17.2) 
			  list(4.0 20.0)
			  list(0.0 20.0) 
			  list(0.0 15.2) 
			  list(5.2 10.0) 
			  list(0.0 4.8) 
			  list(0.0 0.0))
	   obj->cy = list(list(6.0 10.0) 
			  list(6.0 0.0) 
			  list(10.0 0.0) 
			  list(10.0 10.0) 
			  list(16.0 16.0)
			  list(16.0 20.0) 
			  list(12.0 20.0) 
			  list(12.0 17.2) 
			  list(8.0 13.2) 
			  list(4.0 17.2)
			  list(4.0 20.0) 
			  list(0.0 20.0) 
			  list(0.0 16.0))
	   obj->cz = list(list(16.0 0.0) 
			  list(16.0 4.0) 
			  list(7.2 4.0) 
			  list(7.2 5.2) 
			  list(16.0 14.0)
			  list(16.0 20.0) 
			  list(0.0 20.0) 
			  list(0.0 16.0) 
			  list(10.8 16.0) 
			  list(10.8 14.8)
			  list(0.0 4.0) 
			  list(0.0 0.0))
);defmethod
;#####################################################
; Generates a number polygon
;#####################################################
defmethod( generate (( np alpha ))
  let( (ret)
	   ret=nil
	   np->val = lowerCase(np->val)
	   case(np->val
	       ("a"
	         ret=np->ca
               )
	       ("b"
	         ret=np->cb
               )
	       ("c"
	         ret=np->cc
               )
	       ("d"
	         ret=np->cd
               )
	       ("e"
	         ret=np->ce
               )
	       ("f"
	         ret=np->cf
               )
	       ("g"
	         ret=np->cg
               )
	       ("h"
	         ret=np->ch
               )
	       ("i"
	         ret=np->ci
               )
	       ("j"
	         ret=np->cj
               )
	       ("k"
	         ret=np->ck
               )
	       ("l"
	         ret=np->cl
               )
	       ("m"
	         ret=np->cm
               )
	       ("n"
	         ret=np->cn
               )
	       ("o"
	         ret=np->co
               )
	       ("p"
	         ret=np->cp
               )
	       ("q"
	         ret=np->cq
               )
	       ("r"
	         ret=np->cr
               )
	       ("s"
	         ret=np->cs
               )
               ("t"
	         ret=np->ct
               )
	       ("u"
	         ret=np->cu
               )
	       ("v"
	         ret=np->cv
               )
	       ("w"
	         ret=np->cw
               )
	       ("x"
	         ret=np->cx
               )
	       ("y"
	         ret=np->cy
               )
	       ("z"
	         ret=np->cz
               )   
	       (t
	         ret=nil
	       )
	    );case
	    setVertices(np ret)
	    np->width  = maxx(np) - minx(np) 
	    np->height = maxy(np) - miny(np)
	    ret
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  numeric.ils: numberic class 
; FIXME: If non-unity scaling is used, the polygon needs to be re-gridded to 
;        the current manufacturing grid setting in the technology file ...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( numeric (polygon2)
	  ( 
		( val @reader getVal @writer setVal ) 
		( width @reader getWidth @writer setWidth )
		( height @reader getHeight @writer setHeight )
		( scale @reader getScale @writer setScale )
		( c0 )
		( c1 )
		( c2 )
		( c3 )
		( c4 )
		( c5 )
		( c6 )
		( c7 )
		( c8 )
		( c9 )								
	  )
);defClass
;#####################################################
; Class constructor
; This method initializes the class
; Initialized/Default Heigth is 50
;#####################################################
defmethod( initializeInstance @after ((obj numeric))  
	   obj->val = nil
	   obj->width = nil
	   obj->height = nil
	   obj->scale = 1.0
	   obj->c0  = list(list(0 10) 
			   list(10 0) 
			   list(18 0) 
			   list(18 10) 
			   list(16 10)
			   list(13 13) 
			   list(27 27) 
			   list(30 27) 
			   list(30 15) 
			   list(25 10)
			   list(23 10) 
			   list(23 0) 
			   list(30 0) 
			   list(40 10) 
		           list(40 40)
			   list(30 50) 
			   list(22 50) 
			   list(22 40) 
			   list(24 40) 
			   list(27 37)
			   list(13 23) 
			   list(10 23) 
			   list(10 35) 
			   list(15 40) 
			   list(17 40)
			   list(17 50) 
			   list(10 50) 
			   list(0 40) 
			   list(0 10))
	   obj->c1 = list( list(0 40) 
		           list(8 40) 
		           list(8 0) 
			   list(18 0) 
			   list(18 50)
			   list(8 50) 
			   list(4 46) 
			   list(0 46) 
			   list(0 40))
	   obj->c2 = list(list(0 0) 
			  list(40 0) 
			  list(40 10) 
			  list(20.5 10) 
			  list(20.5 13)
			  list(40 32.5) 
			  list(40 42.5) 
			  list(32.5 50) 
			  list(7.5 50) 
			  list(0 42.5)
			  list(0 35) 
			  list(10 35) 
			  list(10 37.5) 
			  list(12.5 40) 
			  list(29.5 40)
			  list(29.5 37) 
			  list(0 7.5) 
			  list(0 0))
	   obj->c3 = list(list(0 8) 
			  list(8 0) 
			  list(33 0) 
			  list(41 8) 
		          list(41 20)
			  list(36 25) 
			  list(41 30) 
		          list(41 42) 
			  list(33 50) 
			  list(8 50)
			  list(0 42) 
			  list(0 35) 
			  list(11 35) 
		          list(11 37) 
			  list(14 40)
		          list(28 40) 
			  list(31 37) 
		          list(31 33) 
			  list(23 25) 
			  list(31 17)
			  list(31 13) 
			  list(28 10) 
			  list(13 10) 
			  list(10 13) 
			  list(10 15)
		          list(0 15) 
			  list(0 8))
	   obj->c4 = list(list(0 10) 
			  list(16 10) 
			  list(16 20) 
			  list(13 20) 
			  list(13 25)
			  list(21 33) 
			  list(25 33) 
			  list(25 20) 
			  list(22 20) 
			  list(22 10)
			  list(25 10) 
			  list(25 0) 
			  list(35 0) 
			  list(35 10) 
			  list(40 10)
			  list(40 20) 
			  list(35 20) 
			  list(35 50) 
			  list(23 50) 
			  list(0 27)
			  list(0 10))
	   obj->c5 = list(list(0 8) 
			  list(8 0) 
			  list(32 0) 
			  list(40 8) 
			  list(40 24)
			  list(32 32) 
			  list(10 32) 
			  list(10 40) 
			  list(40 40) 
			  list(40 50)
			  list(0 50) 
			  list(0 22) 
			  list(30 22) 
			  list(30 13) 
			  list(27 10)
			  list(13 10) 
			  list(10 13) 
			  list(10 15) 
			  list(0 15) 
			  list(0 8))
	   obj->c6 = list(list(0 8) 
			  list(8 0) 
			  list(17 0) 
			  list(17 10) 
			  list(13 10)
		          list(10 13) 
			  list(10 17) 
			  list(13 20) 
			  list(27 20) 
			  list(30 17)
			  list(30 13) 
			  list(27 10) 
			  list(23 10) 
			  list(23 0) 
			  list(32 0)
			  list(40 8) 
			  list(40 22) 
			  list(32 30) 
			  list(10 30) 
			  list(10 36)
			  list(14 40) 
			  list(37.5 40) 
			  list(37.5 50) 
		    	  list(8 50) 
			  list(0 42)
			  list(0 8))
	   obj->c7 = list(list(0 0) 
		     	  list(13 0) 
			  list(13 5) 
			  list(40 32) 
			  list(40 50)
			  list(0 50) 
			  list(0 40) 
			  list(30 40) 
			  list(30 37) 
			  list(0 7)
			  list(0 0))
	   obj->c8 = list(list(0 8) 
			  list(8 0) 
			  list(18 0) 
			  list(18 10) 
			  list(14 10)
			  list(11 13) 
			  list(11 17) 
			  list(14 20) 
			  list(28 20) 
			  list(31 17)
			  list(31 13) 
			  list(28 10) 
			  list(24 10) 
			  list(24 0) 
			  list(33 0)
			  list(41 8) 
			  list(41 19) 
			  list(35 25) 
			  list(41 31) 
			  list(41 42)
			  list(33 50) 
			  list(24 50) 
			  list(24 40) 
			  list(28 40) 
			  list(31 37)
			  list(31 33) 
			  list(28 30) 
			  list(14 30) 
			  list(11 33) 
			  list(11 37)
			  list(14 40) 
			  list(18 40) 
			  list(18 50) 
			  list(8 50) 
			  list(0 42)
			  list(0 31) 
			  list(6 25) 
			  list(0 19) 
			  list(0 8))
	   obj->c9 = list(list(2.5 0) 
			  list(32 0) 
			  list(40 8) 
			  list(40 42) 
			  list(32 50)
			  list(22 50) 
			  list(22 40) 
			  list(27 40) 
			  list(30 37) 
			  list(30 32)
			  list(27 29) 
			  list(13 29) 
			  list(10 32) 
			  list(10 37) 
			  list(13 40)
			  list(16 40) 
			  list(16 50) 
			  list(8 50) 
			  list(0 42) 
			  list(0 27)
			  list(8 19) 
			  list(30 19) 
			  list(30 13) 
			  list(27 10) 
			  list(2.5 10))
);defmethod

;#####################################################
; Width and hieght of of number member
;#####################################################

;#####################################################
; Generates a number polygon
;#####################################################
defmethod( generate (( np numeric ))
  let( (ret)
	   ret=nil
	   case(np->val
	       ("0"
	         ret=np->c0
               )
	       ("1"
	         ret=np->c1
               )
	       ("2"
	         ret=np->c2
               )
	       ("3"
	         ret=np->c3
               )
	       ("4"
	         ret=np->c4
               )
	       ("5"
	         ret=np->c5
               )
	       ("6"
	         ret=np->c6
               )
	       ("7"
	         ret=np->c7
               )
	       ("8"
	         ret=np->c8
               )
	       ("9"
	         ret=np->c9
               )
	       (t
	         ret=nil
	       )
	    );case
	    setVertices(np ret)
	    if(np->scale != 1.0 then
	      scale(np np->scale)
	    );if
	    np->width  = maxx(np) - minx(np) 
	    np->height = maxy(np) - miny(np)
	    getVertices(np)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  punctuation.ils: punctuation class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( punctuation (polygon2)
	  ( 
		( val @reader getVal @writer setVal ) 
		( width @reader getWidth @writer setWidth )
		( height @reader getHeight @writer setHeight )
		( scale @reader getScale @writer setScale )
		( cAngleBracketOpen )
		( cAngleBracketClose )
                ( cBracketClose )
		( cParenthClose )
		( cColon )
		( cComma )
		( cDash )
		( cDot )
		( cEqual )
		( cPound )
		( cHat )
		( cBracketOpen )
		( cParenthOpen )
                ( cPercent )
                ( cQuote )
                ( cPlus )
                ( cQuestion )
                ( cSemiColon )
                ( cSlashBackward )
                ( cSlashForward )
		( cStar )
		( cUnderscore )
		( cBug )								
	  )
);defClass
;#####################################################
; Class constructor
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj punctuation))  
	   obj->val = nil
	   obj->width = nil
	   obj->height = nil
	   obj->scale = 1.0
	   obj->cAngleBracketOpen  = list(list(7.6 0.0) 
			                  list(8.4 0.0) 
			             	  list(8.4 2.4) 
			             	  list(7.6 2.4) 
			   	     	  list(2.4 7.6)
			   	     	  list(2.4 8.4) 
			   	     	  list(7.6 13.6) 
			   	     	  list(8.4 13.6) 
			   	     	  list(8.4 16.0) 
			   	     	  list(7.6 16.0)
			   	     	  list(0.0 8.4) 
			   	     	  list(0.0 7.6))
	   obj->cAngleBracketClose = list(list(0.8 0.0) 
		                          list(8.4 7.6) 
		           		  list(8.4 8.4) 
			   		  list(0.8 16.0) 
			   		  list(0.0 16.0)
			   		  list(0.0 13.6) 
			   		  list(0.8 13.6) 
			   		  list(6.0 8.4) 
			   		  list(6.0 7.6)
			   		  list(0.8 2.4)
			  		  list(0.0 2.4)	
			   		  list(0.0 0.0))
	   obj->cBracketClose = list(list(4.4 0.0) 
			             list(4.4 20.0) 
			  	     list(0.0 20.0) 
			  	     list(0.0 17.2) 
			  	     list(1.2 17.2)
			  	     list(1.2 2.8) 
			  	     list(0.0 2.8) 
			  	     list(0.0 0.0))			  
	   obj->cParenthClose = list(list(2.8 0.0) 
			      	     list(5.2 2.4) 
			 	     list(5.2 17.6) 
			  	     list(2.8 20.0) 
			  	     list(0.0 20.0)
			  	     list(0.0 17.2) 
			  	     list(1.2 16.0) 
			  	     list(1.2 4.0) 
			  	     list(0.0 2.8) 
			  	     list(0.0 0.0))
	   obj->cColon = list(list(1.2 0.0) 
			      list(3.2 0.0) 
			      list(4.4 1.2) 
			      list(4.4 3.2) 
		              list(3.2 4.4)
			      list(1.2 4.4) 
			      list(0.0 3.2) 
		              list(0.0 1.2))
	   obj->cComma = list(list(2.4 0.0) 
			      list(4.8 2.4) 
			      list(4.8 8.8) 
			      list(0.8 8.8) 
			      list(0.0 8.0)
			      list(0.0 4.8) 
			      list(0.8 4.0) 
			      list(1.6 4.0) 
			      list(1.6 3.2) 
			      list(0.0 1.6)
			      list(0.0 0.0))
	   obj->cDash = list(list(0.0 8.0) 
			     list(12.4 8.0) 
			     list(12.4 12.0) 
			     list(0.0 12.0))
	   obj->cDot = list(list(1.2 0.0) 
			    list(2.8 0.0) 
			    list(4.0 1.2) 
			    list(4.0 2.8) 
			    list(2.8 4.0)
		            list(1.2 4.0) 
			    list(0.0 2.8) 
			    list(0.0 1.2))
	   obj->cEqual = list(list(0.0 0.0) 
		     	      list(12.0 0.0) 
			      list(12.0 3.2) 
			      list(0.0 3.2))
	   obj->cPound = list(list(0.0 10.0) 
			      list(5.2 10.0) 
			      list(5.2 12.4) 
			      list(0.0 12.4))
	   obj->cHat = list(list(2.4 19.6) 
			    list(2.4 20.4) 
			    list(5.6 23.6) 
			    list(6.4 23.6) 
			    list(9.6 20.4)
			    list(9.6 19.6) 
			    list(12.0 19.6) 
			    list(12.0 20.4) 
			    list(6.4 26.0) 
			    list(5.6 26.0)
			    list(0.0 20.4)
			    list(0.0 19.6))
	   obj->cBracketOpen = list(list(4.4 0.0) 
			            list(4.4 2.8) 
			  	    list(3.2 2.8) 
			  	    list(3.2 17.2) 
			  	    list(4.4 17.2)
			  	    list(4.4 20.0) 
			  	    list(0.0 20.0) 
			  	    list(0.0 0.0))
	   obj->cParenthOpen = list(list(2.4 0.0) 
			            list(5.2 0.0) 
			       	    list(5.2 2.8) 
			       	    list(4.0 4.0) 
			       	    list(4.0 16.0)
				    list(5.2 17.2)
				    list(5.2 20.0)
				    list(2.4 20.0)
				    list(0.0 17.6)
				    list(0.0 2.4))
	   obj->cPercent = list(list(11.2 2.0) 
			        list(12.8 2.0) 
			  	list(14.0 3.2) 
			  	list(14.0 4.8) 
			  	list(12.8 6.0)
			  	list(11.2 6.0) 
			  	list(10.0 4.8) 
			  	list(10.0 3.2))
	   obj->cQuote = list(list(7.2 14.4) 
			      list(8.8 14.4) 
			      list(9.6 15.2) 
			      list(9.6 20.0) 
			      list(6.4 20.0)
			      list(6.4 15.2))
	   obj->cPlus = list(list(4.4 8.4) 
			     list(4.4 4.0) 
			     list(7.6 4.0) 
			     list(7.6 8.4) 
			     list(12.0 8.4)
			     list(12.0 11.6) 
			     list(7.6 11.6) 
			     list(7.6 16.0) 
			     list(4.4 16.0) 
			     list(4.4 11.6)
			     list(0.0 11.6) 
			     list(0.0 8.4))
	   obj->cQuestion = list(list(3.2 16.0) 
			         list(4.0 16.8) 
			  	 list(7.2 16.8) 
			  	 list(8.0 16.0) 
			  	 list(8.0 12.8)
			  	 list(7.2 12.0) 
			  	 list(3.2 12.0) 
			  	 list(3.2 6.0) 
			  	 list(6.4 6.0) 
			  	 list(6.4 9.6)
			  	 list(8.8 9.6)
				 list(10.8 11.6)
				 list(10.8 18.0)
				 list(8.8 20.0)
				 list(2.4 20.0)
				 list(0.0 17.6)
				 list(0.0 16.0))
	   obj->cSemiColon = list(list(1.6 0.0) 
			          list(4.0 2.4) 
			  	  list(4.0 7.2) 
			  	  list(0.8 7.2) 
			  	  list(0.0 6.4)
			  	  list(0.0 5.2) 
			  	  list(0.8 4.4) 
			  	  list(1.6 4.4) 
			  	  list(1.6 3.2) 
			  	  list(0.0 1.6)
			  	  list(0.0 0.0))
	   obj->cSlashBackward = list(list(12.0 2.8) 
			              list(12.0 0.0) 
			  	      list(16.0 0.0) 
			  	      list(16.0 4.8) 
			  	      list(4.0 16.8)
			  	      list(4.0 20.0) 
			  	      list(0.0 20.0) 
			  	      list(0.0 14.8))
	   obj->cSlashForward = list(list(4.0 0.0) 
			             list(4.0 2.8) 
			  	     list(16.0 14.8) 
			  	     list(16.0 20.0) 
			  	     list(12.0 20.0)
			  	     list(12.0 16.8) 
			  	     list(0.0 4.8) 
			  	     list(0.0 0.0))
	   obj->cStar = list(list(2.4 8.4) 
			     list(0.8 6.8) 
			     list(2.8 4.8) 
			     list(4.4 6.4) 
			     list(4.4 4.0)
			     list(7.6 4.0) 
			     list(7.6 6.4) 
			     list(9.2 4.8) 
			     list(11.2 6.8) 
			     list(9.6 8.4)
			     list(12.0 8.4) 
			     list(12.0 11.6) 
			     list(9.6 11.6) 
			     list(11.2 13.2) 
			     list(9.2 15.2)
			     list(7.6 13.6) 
			     list(7.6 16.0) 
			     list(4.4 16.0) 
			     list(4.4 13.6) 
			     list(2.8 15.2)
			     list(0.8 13.2) 
			     list(2.4 11.6) 
			     list(0.0 11.6) 
			     list(0.0 8.4))
	   obj->cUnderscore = list(list(0.0 0.0) 
			           list(12.4 0.0) 
			  	   list(12.4 4.0) 
			  	   list(0.0 4.0))
	   obj->cBug = list(list(9.0 0.0) 
			    list(7.0 0.0) 
			    list(7.0 4.1) 
			    list(6.1 5.0) 
			    list(3.0 5.0)
			    list(3.0 7.0) 
			    list(6.9 7.0) 
			    list(7.0 7.9) 
			    list(7.0 9.1) 
			    list(6.9 10.0)
			    list(2.0 10.0) 
			    list(2.0 0.0)
			    list(0.0 0.0)
			    list(0.0 12.0)
			    list(6.9 12.0)
			    list(9.0 9.9)
			    list(9.0 7.1)
			    list(7.9 6.0)
			    list(9.0 4.9))
);defmethod
;#####################################################
; Generates a symbol polygon
;#####################################################
defmethod( generate (( np punctuation ))
  let( (ret)
	   ret=nil
	   case(np->val
	       ("<"
	         ret=np->cAngleBracketOpen 
               )
	       (">"
	         ret=np->cAngleBracketClose
               )
	       ("]"
	         ret=np->cBracketClose
               )
	       (")"
	         ret=np->cParenthClose
               )
	       (":"
	         ret=np->cColon
               )
	       (","
	         ret=np->cComma
               )
	       ("-"
	         ret=np->cDash
               )
	       ("."
	         ret=np->cDot
               )
	       ("="
	         ret=np->cEqual
               )
	       ("^"
	         ret=np->cHat
               )
	       ("["
	         ret=np->cBracketOpen
               )
	       ("("
	         ret=np->cParenthOpen
               )
	       ("%"
	         ret=np->cPercent
               )
	       ("\""
	         ret=np->cQuote
               )
	       ("+"
	         ret=np->cPlus
               )
	       ("?"
	         ret=np->cQuestion
               )
	       (";"
	         ret=np->cSemiColon
               )
	       ("\\"
	         ret=np->cSlashBackward
               )
	       ("/"
	         ret=np->cSlashForward
               )
               ("*"
	         ret=np->cStar
               )
	       ("_"
	         ret=np->cUnderscore
               )
	       ("bug"
	         ret=np->cBug
               )
	       (t
	         ret=nil
	       )
	    );case
	    setVertices(np ret)
	    np->width  = maxx(np) - minx(np) 
	    np->height = maxy(np) - miny(np)
	    ret
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  shape.ils: Layout Shape Object 
;             This is a cadence cellview centric class that 
;             operates on the shape of a layout layer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( shape (cadObj)
	  (	
	  	( geometries )	
		( layer @writer setLayer @reader getLayer )
		( purpose @writer setPurpose @reader getPurpose )
		( type )
		( vertices @reader getVertices)
		( transform )
		( centroid )
		( dbg )
		( mfg )	
		( area )			
	  )
) ; defClass
;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj shape))
	   obj->geometries = makeInstance( 'collection )  
	   obj->layer = nil 
	   obj->purpose = nil 
	   obj->type = nil
	   obj->vertices = nil
	   obj->transform = makeInstance( 'transform2 )
	   obj->centroid = makeInstance( 'point2 )
	   obj->dbg = nil
	   obj->mfg = nil
	   obj->area = nil	     
);defmethod
;#####################################################
; Add polygon to polygons collection of the shape
;#####################################################
defmethod( addGeometry (( shp shape ) arg)
  add(shp->geometries arg)
);defmethod
;#####################################################
; Shape is the "foundation" Rendering Class for all
; higher "layer" classes above shape - assembly, layer,
; stackup and layout ...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Renders the shape using the contained geometries
; in the the focus cv reference
;#####################################################
defmethod( render (( shp shape ))
  if( !null(shp->geometries->list) then
    foreach( geom shp->geometries->list->elems
      foreach( polygon geom->polygons->list->elems
        printf("INFO(shape): Rendering Shape Polygon\n")
        dbCreatePolygon(getRef(shp)
	     	        list(shp->layer shp->purpose)
		        polygon->vertices
		        );dbCreatePolygon
      );foreach
    );foreach
  else
    printf("ERROR(shape): Shape Null Vertices - ")
 );if   
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This render method renders a single shape given by
; the vertices class member
; FIXME: There is a tangle with the render method above.
;        Need some refactoring here, but I a wary of
;        doing so in the absence of a regressible test suite.
;        Also, it looks like there might be an inheritance
;        opportunity here with the polygon class. This could
;        possible link dependencies between this class
;        and the geometry class!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( renderShape (( shp shape ))
  if( !null(shp->vertices) then
    dbCreatePolygon(getRef(shp)
	     	    list(shp->layer shp->purpose)
		    shp->vertices
		    );dbCreatePolygon   
  else
    printf("ERROR(shape): Shape Null Vertices - ")
  );if   
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FIXME: Need to update code below to process multiple 
;        polygons in the new polygons collection 
;        member. Most of this code should drop down
;        into the geometry and polygon2 class definitions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;#####################################################
; Reset the shape's transform
;#####################################################
defmethod( shapeReset (( shp shape ))
	   shp->transform->vertices = shp->vertices
	   shp->transform->area = shp->area
	   shp->transform->polygon->centroid->x = shp->centroid->x
	   shp->transform->polygon->centroid->y = shp->centroid->y
);defmethod
;#####################################################
; This method sets the vertex list the the vertices
; argument
;#####################################################
defmethod( setVertices (( shp shape ) vertices)
	   shp->vertices = vertices
	   resetPoints(shp->transform->vertices)
	   setVertices(shp->transform vertices)
	   area(shp->transform->polygon)
	   shp->transform->area = shp->area
	   centroid(shp->transform->polygon)
	   shp->centroid->x = shp->transform->polygon->centroid->x
	   shp->centroid->y = shp->transform->polygon->centroid->y
	   length(getCollection(shp->transform->vertices->points))
);defmethod
;#####################################################
; This method works on an existing Cadence layout, and
; creates polygons for all layout shapes
;#####################################################
;
; FIXME: This needs to go into a new "snapshot" class
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( genVertices (( shp shape ))
	   let( (bbox
	   	 v0
		 v1
		 v2
		 v3)
	   	shp->type = shp->ref~>objType 
		shp->vertices='()
		shp->transform->vertices='()
		case( shp~>ref~>objType 
		  ( ( "polygon" )
		    println("polygon detected")
	   	    foreach(point shp~>ref~>points
	      	      shp->vertices=cons(point shp->vertices)
		      shp~>transform~>vertices=cons(point shp~>transform~>vertices)
	    	    )	     
	   	  );polygon
		  ( ( "dot" )
		    println("dot detected")
	   	    foreach(point shp~>ref~>points
	      	      shp~>vertices=cons(point shp~>vertices)
		      shp~>transform~>vertices=cons(point shp~>transform~>vertices)
	    	    )	     
	   	  );dot
		  ( ( "line" )
		    println("line detected")
		    bbox=shp~>ref~>bBox
		    v3 = list(nth(0 nth( 0 bbox)) nth(1 nth(1 bbox)))
		    v2 = list(nth(0 nth( 1 bbox)) nth(1 nth(1 bbox)))
		    v1 = list(nth(0 nth( 1 bbox)) nth(1 nth(0 bbox)))
		    v0 = list(nth(0 nth( 0 bbox)) nth(1 nth(0 bbox)))
		    shp->vertices=list(v0 v1 v2 v3)
		    shp->transform->vertices=list(v0 v1 v2 v3)
		    shp->layer = shp~>ref~>layerName
		    shp->purpose = shp~>ref~>purpose
		    shp->type = shp~>ref~>objType
		  );line
		  ( ( "rect" )
		    println("rect dectected")
		    bbox=shp~>ref~>bBox
		    v3 = list(nth(0 nth( 0 bbox)) nth(1 nth(1 bbox)))
		    v2 = list(nth(0 nth( 1 bbox)) nth(1 nth(1 bbox)))
		    v1 = list(nth(0 nth( 1 bbox)) nth(1 nth(0 bbox)))
		    v0 = list(nth(0 nth( 0 bbox)) nth(1 nth(0 bbox)))
		    shp->vertices=list(v0 v1 v2 v3)
		    shp->transform->vertices=list(v0 v1 v2 v3)
		    shp->layer = shp~>ref~>layerName
		    shp->purpose = shp~>ref~>purpose
		    shp->type = shp~>ref~>objType
		  );rect
		  ( ( "path" )
		    println("path detected")
		    bbox=shp~>ref~>bBox
		    v3 = list(nth(0 nth( 0 bbox)) nth(1 nth(1 bbox)))
		    v2 = list(nth(0 nth( 1 bbox)) nth(1 nth(1 bbox)))
		    v1 = list(nth(0 nth( 1 bbox)) nth(1 nth(0 bbox)))
		    v0 = list(nth(0 nth( 0 bbox)) nth(1 nth(0 bbox)))
		    shp->vertices=list(v0 v1 v2 v3)
		    shp->transform->vertices=list(v0 v1 v2 v3)
		    shp->layer = shp~>ref~>layerName
		    shp->purpose = shp~>ref~>purpose
		    shp->type = shp~>ref~>objType
		  );path
                  ( "ellipse"
		    println("ellipse detected")
		    foreach(point shp~>ref~>points
	      	      shp~>vertices=cons(point shp~>vertices)
		      shp~>transform~>vertices=cons(point shp~>transform~>vertices)
	    	    )
		  );ellipse
		  ( "label"
		    println("label detected")
		    shp->vertices=nil
		  );label
		  ( t
                        printf("ERROR(shape): Unknown shape %s\n" shp~>ref~>objType )
			error( "ERROR SHAPE: Encountered unknown shape" )
			return()
		  );t
		);case	
		area(shp->transform->polygon)
		shp->transform->area = shp->area
		centroid(shp->transform->polygon)
		shp->centroid->x = shp->transform->polygon->centroid->x 
		shp->centroid->y = shp->transform->polygon->centroid->y
		list(shp->transform->polygon->centroid->x shp->transform->polygon->centroid->y)
	   );let	   
);defmethod
;#####################################################
; Translates the shape's transform
;#####################################################
; Note: Class no longer inherits from polygon2
defmethod( shapeTranslate (( shp shape ) trn)
	   if( listp(trn) then
	   ;FIXME: Need to check that inputs are in on grid increments
	     translate(shp->transform trn)
	     list(shp->transform->polygon->centroid->x shp->transform->polygon->centroid->y)
	   else
	      println("ERROR(shape): argument must be a coordinate list")
           );if
);defmethod
;#####################################################
; Scales the shape's transform
;#####################################################
; NOTE: Class no longer inherits from polygon2
defmethod( shapeScale (( shp shape ) arg)
	   ;FIXME: Need to check that inputs are in on grid increments
	   scale(shp->transform arg)
	   list(shp->transform->polygon->centroid->x shp->transform->polygon->centroid->y)
);defmethod
;#####################################################
; Rotate the shape's transform (rot is in degrees
; with positive being counter-clockwise about the origin)
;#####################################################
; Note: Class no longer inherits from polygon2
;defmethod( shapeRotate (( shp shape ) rot)
;  ;FIXME: Need to check that input arg in on grid increments
;  rotate(shp->transform rot/180*3.14159)
;);defmethod
;#####################################################
; Returns the transform's centroid
;#####################################################
;  Note: Class no longer inherits from polygon2
defmethod( shapeCentroid (( shp shape ))
	   list( shp->transform->polygon->centroid->x shp->transform->polygon->centroid->y)
);defmethod
;#####################################################
; Returns the transform's area
;#####################################################
; Note: Class no longer inherits from polygon2
defmethod( shapeArea (( shp shape ))
	   shp->transform->area 
);defmethod
;#####################################################
; Checks that all the vertices are on the manufacturing grid
;#####################################################
defmethod( checkMfg (( shp shape ))
  forach(shp shp->geometries
    foreach( vert shp->vertices
       ;x=round(xCoord(vert)/shp->mfg) * shp->mfg
       ;y=round(yCoord(vert)/shp->mfg) * shp->mfg
    );foreach
  );foreach
);defmethod
;#####################################################
;
;#####################################################
;defmethod( setOnDbg (( shp shape ))
;  let( (x y vertices)
;    vertices = '()
;    foreach( vert shp->vertices
;      x=round(xCoord(vert)/shp->dbg) * shp->dbg
;     y=round(yCoord(vert)/shp->dbg) * shp->dbg
;      vertex =list(x y)
;      vertices = cons(vertex vertices)
;    );foreach
;    shp->vertices=reverse(vertices)
;  );let	   
;);defmethod
;#####################################################
; quotient(xCoord(vert)/grid 1.0) - round(xCoord(vert)*10)
;#####################################################
defmethod( isOnMfg (( shp shape ))
  let( (onGrid)
    onGrid = 't
    foreach( vert shp->vertices
      if( abs(quotient(xCoord(vert)/getGrid(shp) 1.0) - round(xCoord(vert)*10)) > 0.000001 then
        printf("ERROR: Shape Vertex X coordinate NOT ON a %g um grid: (%g,%g) \n" float(getGrid(shp)) float(xCoord(vert)) float(yCoord(vert)))
        onGrid = nil
      );if
      if( abs(quotient(yCoord(vert)/getGrid(shp) 1.0) - round(yCoord(vert)*10)) > 0.000001 then
        printf("ERROR: Shape Vertex Y coordinate NOT ON a %g um grid: (%g,%g) \n" float(getGrid(shp)) float(xCoord(vert)) float(yCoord(vert)))
        onGrid = nil
      );if
    );foreach
  );let	   
);defmethod
;#####################################################
;
;#####################################################
defmethod( setOnMfg (( shp shape ))
  let( (x y vertices mfg)
    vertices = '()
    mfg = getGrid(shp)
    foreach( vert shp->vertices
      x=round(xCoord(vert)/mfg) * mfg
      y=round(yCoord(vert)/mfg) * mfg
      vertex =list(x y)
      vertices = cons(vertex vertices)
    );foreach
      shp->vertices=reverse(vertices)
  );let	   
);defmethod
;#####################################################
; Center the shape's transform centroid to align to the 
; origin
;#####################################################
;defmethod( shapeCenter (( shp shape ))
;	   let( (delx dely)
;	   	delx = shp->transform->origin->x - shp->centroid->x
;	   	dely = shp->transform->origin->y - shp->centroid->y 
;	   	shapeTranslate(shp list(delx dely))
;	   	shp->transform->centroid->x = shp->transform->origin->x
;	   	shp->transform->centroid->y = shp->transform->origin->y
;		list(shp->transform->polygon->centroid->x shp->transform->centroid->y)
;	   );let
;);defmethod
;#####################################################
; Generate a bounding box for the shape
; FIXME: Is this simply getting the shape's bBox from
;        the cellview?
;#####################################################
;defmethod( genBbox (( shp shape ))
;	   nil
;);defmethod
;#####################################################
; Shift the shape's lower left corner to the 
; upper left quadrant of the cellview window
; FIXME: do this via the bounding box once it is
; defined in genBbox
;#####################################################
;defmethod( shiftUrq (( shp shape ))
;	   nil
;);defmethod
;#####################################################
; Does the bbox exactly match the veritices. If it
; does the bbox is a rectangle
;#####################################################
;defmethod( isRect (( shp shape ))
;	   nil
;);defmethod
;#####################################################
; Merge the two shapes into one 
; argument is another shape reference
;#####################################################
defmethod( mergeShapes (( shp shape ) arg)
	  shp->ref = leMergeShapes(list(shp->ref arg))
);defmethod
;#####################################################
; Union of two shapes
;#####################################################
defmethod( unionShapes (( shp shape ) arg)
	  leOr(shp->ref shp->ref arg)
);defmethod
;#####################################################
; Union minus intersection of two shapes
;#####################################################
defmethod( intersectionShapes (( shp shape ) arg)
	  leXor(shp->ref shp->ref arg)
);defmethod
;#####################################################
; Union minus intersection of two shapes
;#####################################################
defmethod( unionMinusintersectionShapes (( shp shape ) arg)
	   leXor(shp->ref shp->ref arg)
);defmethod
;#####################################################
; Fiter out redundant adjacent vertexes
;#####################################################
;defmethod( filter (( shp shape ) )
;	   nil
;);defmethod
;#####################################################
; Determines if two shapes have collided. the second
; shape is arg
;#####################################################
defmethod( collide (( shp shape ) arg)
  if( null(dbStraddle(shp->ref "text" shp->ref  arg))
    nil
  else	       
    t
  );if
);defmethod
;#####################################################
; Determines if two the shape arg is enclosed in this
; shape object. 
;#####################################################
defmethod( enclosed (( shp shape ) arg)
  if( !null(dbAndNot(shp->ref "text" shp->ref  arg))
    nil
  else	       
    t
  );if
);defmethod
;#####################################################
; Resize the shape by uu user units (um)
; FIXME: need to create a binding between shape object
;        and equivalent cell view shape so that
;        le functions can be used by this class??
;#####################################################
;defmethod( resize (( shp shape ) uu)
; let((cv)
;   leSizeShape(cvShp)
; );let  
;);defmethod
;###############################################################################
;###############################################################################
;###############################################################################




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  alphaNumeric.ils: alphaNumeric class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( alphaNumeric ()
  ( 
    ( val    @reader getVal @writer setVal)
    ( width  @reader getWidth @writer setWidth )
    ( height @reader getHeight @writer setHeight )
    ( scale  @reader getScale @writer setScale )							
  )
);defClass
;#####################################################
; Class constructor
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj alphaNumeric))  
  obj->val = nil
  obj->width = nil
  obj->height = nil
  obj->scale = 1.0
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generate character
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generate (( an alphaNumeric ))
  let( (char gen ret)
    ret = nil
    char = makeInstance( 'alpha )
    setVal(char an->val)
    setScale(char an->scale)
    gen  = generate(char)
    if(!null(gen) then
      ret = gen
      setWidth(an getWidth(char))
      setHeight(an getHeight(char))
    );if
    char = makeInstance( 'numeric )
    setVal(char an->val)
    setScale(char an->scale)
    gen  = generate(char)
    if(!null(gen) then
      ret = gen
      setWidth(an getWidth(char))
      setHeight(an getHeight(char))
    );if
    char = makeInstance( 'punctuation )
    setVal(char an->val)
    setScale(char an->scale)
    gen  = generate(char)
    if(!null(gen) then
      ret = gen
      setWidth(an getWidth(char))
      setHeight(an getHeight(char))
    );if
    ret
  );let
);defmethod;######################################################
;# techLayer.ils: Technology layer class. Shapes member
;#                is a container for all shapes on the
;#                target layer.
;#                FIXME: shapes are depreciated. Use
;#                       transform2 class
;######################################################
defclass( techLayer (cadObj)
  (
    ( name @reader getName @writer setName )
    ( purpose @reader getPurpose @writer setPurpose )
    ( shapes @reader getShapes )
  )				  
);defclass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Class constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj techLayer)) 
  obj->name = nil
  obj->purpose = nil
  obj->shapes = makeInstance( 'collection )
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method gets all the shapes on the target layer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getShapesOnLayer (( lay techLayer ))
  let( (shps temp)
    shps = car(setof(lp lay->ref~>lpps lp~>layerName==lay->name))~>shapes
    foreach( sh shps
      temp = makeInstance( 'shape )
      setRef(temp sh)
      genVertices(temp)
      add(lay->shapes temp)
    );foreach	       
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method deletes all shapes on the target layer
; Rendor shapes on the layer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( deleteShapesOnLayer (( lay techLayer ))
  foreach(shape lay->shapes
      dbDeleteObject(shape)
  )
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Render shapes on the layer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( renderShapesOnLayer (( lay techLayer ))
  let((i points)
    i=0
    foreach(shp lay->shapes->list->elems
      points = makeInstance( 'points2 )
      addPoints(points shp->vertices)
      setVertexCollection(shp->transform points)
      setLayer(shp->transform lay->name)
      setPurpose(shp->transform lay->purpose)
      setRef(shp getRef(lay))
      setRef(shp->transform getRef(lay))    
      render(shp->transform)
      i++
    );foreach
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Render shapes on the layer - V2.0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( renderShapesOnLayer2 (( lay techLayer ))
  let((i)
    i=0
    foreach(shp lay->shapes->list->elems
      printf("INFO: Rendering Shape %d\n" i)
      setLayer(shp getName(lay))
      setPurpose(shp getPurpose(lay))
      setRef(shp getRef(lay))
      renderShape(shp)
      i++
    );foreach
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method adds a shape to a layer by reference
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( addShape (( lay techLayer ) arg )
  if( getName(lay) == getLayer(arg) then
    printf("INFO: Adding shape to layer\n")
    add(lay->shapes arg)
    t
  else
    printf("ERROR: Shape is on %s layer, cannot be added to %s layer\n" getLayer(arg) getName(lay))
    nil
  );if  
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Performs the logical AND of the two input layer objects
;  Returns: A list of shapes that satisfy the logical AND operation
;           nil if there is no output from the AND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( andLayers (( lay techLayer ) lppIn lppOut )
  let((layer purpose)
    layer = getName(lay)
    purpose = getPurpose(lay)
    leLayerAnd(getRef(lay) list(layer purpose) lppIn lppOut)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Performs the logical AND NOT of the two input layer objects
;  Returns: A list of shapes that satisfy the logical AND operation
;           nil if there is no output from the AND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( andNotLayers (( lay techLayer ) lppIn lppOut )
  let((layer purpose)
    layer = getName(lay)
    purpose = getPurpose(lay)
    leLayerAndNot(getRef(lay) list(layer purpose) lppIn lppOut)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Performs the logical OR of the two input layer objects
;  Returns: A list of shapes that satisfy the logical AND operation
;           nil if there is no output from the AND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( orLayers (( lay techLayer ) lppIn lppOut )
  let((layer purpose)
    layer = getName(lay)
    purpose = getPurpose(lay)
    leLayerOr(getRef(lay) list(layer purpose) lppIn lppOut)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Performs the logical XoR of the two input layer objects
;  Returns: A list of shapes that satisfy the logical XoR operation in
;           the target cellview (cv argument) on the error marker layer
;  NOTE: To save XoR shapes in target cellview, open the cellview in 
;        append mode and then save/close it.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( xOrLayers (( lay techLayer ) lppIn lppOut)
  let((layer purpose)
    layer = getName(lay)
    purpose = getPurpose(lay)
    leLayerXor(getRef(lay) list(layer purpose) lppIn lppOut)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Resizes the shapes on this layer by useru (um) and returns 
;  a list of newly resized shapes on this layer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( resizeLayer (( lay techLayer ) uu )
  let((layA purA temp)
    lay = getLayer(other)
    pur = getPurpose(other)
    leLayerSize(getRef(lay) list(lay pur) uu list(lay pur))
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Merge all shapes on a layer. Returnts a list of shapes that have
;  been returned from the merger operation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( mergeLayer (( lay techLayer ))
  let((cv sList)
    cv = getRef(lay)
    foreach(layer cv~>lpps
      if(layer~>layerName == getName(lay) && layer~>purpose == getPurpose(lay) then
        foreach(shp layer~>shapes 
          sList = cons(shp sList)
        );foreach
      );if
    );foreach	
    ; get the target layer from the cv
    ; get the shapes on that layer and add them to sList
    leMergeShapes(sList)
  )
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;######################################################
;# snapshot.ils: 
;######################################################
defclass( snapshot (stackup)
   (
	  ( layerMap @reader getLayerMap @writer setLayerMap)
	  ( serialfile  @reader getSerialFile @writer setSerialFile)
   )				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj snapshot)) 
  layerMap = nil
  serialfile = nil	   	     
);defmethod

;#####################################################
; Checks the vertices of all shapes for manufacturing grid
; compliance
;#####################################################
defmethod( checkMfg (( ss snapshot ))
  foreach( layer ss->layers->list->elems
    printf("INFO: Checking layer for MFG compliance: %s\n" layer->name)
    foreach(shp layer->shapes->list->elems
      isOnMfg(shp)
    );foreach
  );foreach
);defmethod

;#####################################################
; snaps the vertices of all shapes onto the manufacturing grid
;#####################################################
defmethod( setOnMfg (( ss snapshot ))
  let((n)
    foreach( layer ss->layers->list->elems
      printf("INFO: Regridding layer: %s\n" layer->layer)
      foreach(shp layer->shapes->list->elems
        setOnMfg(shp)
      );foreach
    );foreach
  );let
);defmethod

;#####################################################
; snaps vertices on the database grid
;#####################################################
;defmethod( setOnDbg (( shp shape ))
;	   let( (x
;	   	 y
;		 vertices)
;		 vertices = '()
;		 foreach( vert shp->vertices
;	           x=round(xCoord(vert)/shp->dbg) * shp->dbg
;	           y=round(yCoord(vert)/shp->dbg) * shp->dbg
;		   vertex =list(x y)
;		   vertices = cons(vertex vertices)
;		 );foreach
;		 shp->vertices=reverse(vertices)
;	   );let	   
;);defmethod



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  pcell.ils: General Pcell ANALYSIS class encapsulating commonly used
;             pcell analysis commands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( pcell (cv)
	  (		
		( superMaster @reader isSuperMaster )
		( master @reader isMaster )			
	  )
) ; defClass

;#####################################################
; 
;#####################################################
defmethod( initializeInstance @after ((obj pcell))  
	   obj->superMaster  = nil
	   obj->master = nil  
);defmethod

;#####################################################
; Check if current cv is a pcell
;#####################################################
defmethod( isPcell (( pc pcell ))
	   getRef(pc)~>isParamCell
);defmethod

;#####################################################
; Check if current cv is a VALID pcell
;#####################################################
defmethod( isValidPcell (( pc pcell ))
	   dbCheckParamCell(pc->cvRef)
);defmethod

;#####################################################
; Generate the skill code for the pcell cv
;#####################################################
defmethod( skillGen (( pc pcell ) ofile)
	   pcSkillGen(pc->cvRef ofile nil)
);defmethod

;#####################################################
; "Dump" the skill code for the pcell cv
;#####################################################
defmethod( skillDump (( pc pcell ) ofile)	   
	   dbDumpPcDefinePcell(pc->cvRef ofile)
);defmethod

;#####################################################
; Fix the skill code for the pcell cv
;#####################################################
defmethod( skillFix (( pc pcell ) ofile)	   
	   if(!null(dbFixParamCell(pc->cvRef ofile)) then
	     println("INFO: Pcell redefined succeeded")
	   else
	     println("WARN: Pcell redefined either was not needed or redefine not needed")
	   );if 
);defmethod

;#####################################################
; "Dump" the skill code for the pcell cv
;#####################################################
defmethod( getParams (( pc pcell ))	   
  if(!null(nth(0 pc->cvRef~>prop)~>valueType) then
    foreach(value nth(0 pc->cvRef~>prop)~>value
       printf("Name: %s Type: %s, Value: %L\n" value~>name value~>valueType value~>value)
    )
  )
);defmethod

;###############################################################################
;###############################################################################
;###############################################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  reticleArray.ils: Reticle Array Class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( reticleArray (cv)
  (
    ( waferWidth @reader getWaferWidth @writer setWaferWidth)
    ( waferHeight @reader getWaferHeight @writer setWaferHeight)
    ( reticle @reader getReticle @writer setReticle)
    ( reticles @reader getReticles)
    ( arrayWidth @reader getArrayWidth @writer setArrayWidth)
    ( arrayHeight @reader getArrayHeight @writer setArrayHeight)
    ( rows @reader getRows @writer setRows)
    ( cols @reader getCols @writer setCols)
    ( overlap @reader getOverlap @writer setOverlap)
    ( origin )	
    ( ur )
  )
);defclass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj reticleArray))
  obj->waferWidth = nil
  obj->waferHeight = nil
  obj->reticle = nil
  obj->reticles = makeInstance( 'collection )
  obj->arrayWidth = nil
  obj->arrayHeight = nil
  obj->rows = nil
  obj->cols = nil
  obj->overlap = nil
  obj->origin = nil
  obj->ur = nil
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Center the reticle array
; FIXME: need to generate an reticle array that has
;        an odd number of sites in the horizontal and
;        vertical. This will center the center of the
;        center site on the center of the wafer outline
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( centerArray (( ra reticleArray ) arg)
  let((w h cx cy shx shy)
    w  = xCoord(ra->ur) - xCoord(ra->origin) 
    h  = yCoord(ra->ur) - yCoord(ra->origin)
    cx = (w - xCoord(ra->origin))/2.0
    cy = (h - yCoord(ra->origin))/2.0
    shx = cx - xCoord(arg)
    shy = cy - yCoord(arg)
    shift(ra list(-w/2.0 -h/2.0))
    ra->width = w
    ra->height = h
    ra->origin = list(-w/2.0 -h/2.0)
    ra->ur = list(w/2.0 h/2.0)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Shift entire reticle array origin to the new origin 
; given by arg
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( shift (( ra reticleArray ) arg)
  let((orig dx dy i)
    i = 0
    foreach(ret getCollection(ra->reticles)
      orig = getOrigin(ret)
      dx = xCoord(orig) + xCoord(arg)
      dy = yCoord(orig) + yCoord(arg)
      printf("INFO(reticleArray) Setting Origin %d to %L\n" i list(dx dy))
      setReticleOrigin(ret list(dx dy))
      i++
    );foreach
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;######################################################
; Create Reticle Array
;######################################################
defmethod( array (( ra reticleArray ))
  let((ral rah rw rh r c ind x y)
    ral = getWaferWidth(ra)
    rah = getWaferHeight(ra)
    rw = getWidth(ra->reticle)
    rh = getHeight(ra->reticle)
    r = floor(ral/rh)
    c = floor(rah/rw)
    ra->rows = r
    ra->cols = c
    ol = ra->overlap
    ind = 0
    x = 0.0
    y = 0.0
    for(i 0 sub1(r)
      ind = ind + ind*i
      x = 0.0
      orig = list(x y)
      for(j 0 sub1(c)
        ind = ind + j
	x = xCoord(orig) + rw - ol
	ret = makeInstance( 'reticle )
	cloneRet(ra->reticle ret)
	setReticleOrigin(ret orig)	
        add(ra->reticles ret)
	orig = list(x y)
      );for
      y = yCoord(orig) + rh - ol
    );for
    ra->origin = list(0.0 0.0)
    ra->ur = list(x y)
    list(ra->rows ra->cols)
  );let
);defmethod
;######################################################
; Render reticle boundary box array
;######################################################
defmethod( render (( ra reticleArray ))
  foreach(ret getCollection(ra->reticles)
    printf("Reticle Origin: (%f,%f)\n" xCoord(ret->origin) yCoord(ret->origin))
    setRef(ret getRef(ra))
    renderRetBbox(ret)
  );foreach
);defmethod
;######################################################
; Erase reticle boundary box array
;######################################################
defmethod( erase (( ra reticleArray ))
  let((cv)
    cv = getRef(ra)
    if(!null(cv~>shapes) then
      foreach( shape cv~>shapes
        if(shape~>layerName == "GRID" then   
          dbDeleteObject(shape)
        );if
      );foreach
    );if
  );let
);defmethod
;######################################################
; Render the boundary box of a single reticle into
; the target cellview
;######################################################
defmethod( renderBbox (( ra reticleArray ))
  let((ind ret r c)
    ra->rows = r
    ra->cols = c
    ind = 0.0
    for(i 0 sub1(r)
      ind = ind + ind*i
      for(j 0 sub1(c)
        ind = ind + j
        ret = getItem(reticles ind)
	renderRetBbox(ret)
      );for
    );for
  );let
);defmethod
;######################################################
;######################################################
;######################################################


	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  wafer.il: Wafer Class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( wafer (cv)
  (
    ( width @read getWidth @writer setWidth)
    ( height @read getHeight @writer setHeight )
    ( overlap @read getOverlap @writer setOverlap )
    ( retName @reader getRetName @writer setRetName)
    ( retArray @reader getRetArray)
    ( crossLayer @reader getCrossLayer @writer setCrossLayer)
    ( center @reader getCenter )	
    ( shiftHorizontal @reader getShiftHorizontal )
    ( shiftVerticle @reader getShiftVerticle )	
    ( pm @reader getPm )
    ( wafNumMrk @reader getWafNumMrk )
    ( retNumMrk @reader getRefNumMrk )	
    ( bsideMrk @reader getBsideMrk )
    ( dieSiteRows @reader getDieSiteRows )
    ( dieSiteCols @reader getDieSiteCols ) 
    ( waferOutline )
    ( exclusingRing )
    ( tempCv )	
  )
);defClass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj wafer))
  obj->width = nil
  obj->height = nil
  obj->overlap = nil
  obj->retName = nil
  obj->retArray = makeInstance( 'reticleArray )
  obj->crossLayer = "GLASS"
  obj->center = nil
  obj->shiftHorizontal = nil
  obj->shiftVerticle = nil
  obj->pm = makeInstance( 'collection )
  obj->wafNumMrk = makeInstance( 'collection )
  obj->retNumMrk = makeInstance( 'collection )
  obj->bsideMrk =  makeInstance( 'collection )
  obj->waferOutline = makeInstance( 'shape)
  obj->exclusingRing = makeInstance( 'shape )
  obj->tempCv = makeInstance( 'cv )
);defmethod

;######################################################
; This finds the Center Diameter "CD-Critical Dimension" 
; Cross Coordinates
; find the center of the wafer outline, it's a cross 
; (on GRID layer, typically):
; FIXME: zero centered cross measures an offset!
;######################################################
defmethod( findCenter (( waf wafer ))
  let( (shapes cross x y)  
    shapes = setof( i getRef(waf)~>shapes i~>layerName == waf->crossLayer)
    cross = nth(0 shapes)
    if(length(cross~>points) == 12 then
      x = (caadr(cross~>bBox)-caar(cross~>bBox))/2.0
      y = (cadadr(cross~>bBox)-cadar(cross~>bBox))/2.0
    );if
    waf->center = list(x y)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read in the wafer outline layers from a reference
; cellview
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( renderOutline (( waf wafer ) cv)
  let((ss)
    ss = makeInstance( 'snapshot )
    setRef(ss cv)
    getStackUp(ss)
    setRef(ss getRef(waf))
    renderStack(ss)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the information about the wafer level die site
; array
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getWaferDieSites (( waf wafer ))
  let((rarows racols dsrows dscols rind dind ret die wrow wcol dsn)
      rarows = getRows(waf->retArray)
      racols = getCols(waf->retArray)
      dsrows = xCoord(getDieSiteArray(waf->retArray->reticle))
      dscols = yCoord(getDieSiteArray(waf->retArray->reticle))
      waf->dieSiteRows = rarows*dsrows
      waf->dieSiteCols = racols*dscols
      printf("INFO(wafer): Total Number of Wafer Die Sites: %d\n" rarows*dsrows*racols*dscols)
      wcol = 0
      dsn  = 0
      wrow = 0
      for(i 0 sub1(rarows)
        dind = 0
	for(j 0 sub1(dsrows)
          wcol = 0
	  for(k 0 sub1(racols)
	    rind = i*rarows + k
	    ret = getItem(waf->retArray->reticles rind)
	    setWaferRow(ret i)
	    setWaferCol(ret k)
	    for(l 0 sub1(dscols)
	      dind = j*dsrows+l
              die = getItem(ret->dieSites dind)
	      setWaferRow(die wrow)
	      setWaferCol(die wcol)
	      println("##########################################################################################")
	      printf("INFO(wafer): Numbering Wafer Die Site #%d, ROW: %d, COL: %d\n" dsn wrow wcol)
	      printf("INFO(wafer): Reticle Array Index: ROW %d, COL %d | Die Array Index: ROW %d, COL %d\n" i k j l)
	      dsn++
	      wcol++
	    );for
          );for
	  wrow++
        );for
      );for
      list(waf->dieSiteRows waf->dieSiteCols)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Print the die site numbers across the wafer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( numberDieSites (( waf wafer ))
  let((ret)
    ; based upon the number of cols/rows determine the 
    ; number of digits necessary to represent the row/col
    ; numbers
    ;
    ; open the target wafer cellview for applying the numbers
    ;
    ; get each reticle in the wafer reticle array
;    getWaferRow(getItem(ret->dieSites 0))
;    ret = getItem(waf->retArray->reticles 0)
    ; get each die within the indexed reticle 
;    for(i 0 sub1(getDieSiteRows)
;      for(j 0 sub1(getDieSiteCols)
         ; update pad center
;	 update(die)
	 
         ; print a dash in middle of numpad
	 ; print row number to left of dash
	 ; print col number to right of dash
;      );for
;    );for 
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Determines if the bbox of a site is valid 
; 
; 1.) Create a shape from the bbox argument
; 2.) First check to see if the bbox is fully within the wafer 
;     boundaries by a set amount (1/4 of the exclusion ring width)
;     This is done by checking the distance of each corner of the bbox
;     from the center of the wafer. The wafer center is determined from 
;     the bbox of the wafer overlay/outline 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( isValidSite (( waf wafer ) bbox)
  let((shp)   
    shp = dbCreateRect( waf->tempCv "text" bbox)
    and(
	 overlaping( shp waf->waferOutline)
	 null( xynOverlaps(shp  waf->exclusingRing))
    );and
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Determines if the given bBox overlaps a given shape
; Converts the bBox to a shape on the text layer uses the
; layout editor function "leLayerAnd" funtion to determine if there
; is an intersection or overlap between the bBox and shape 
; arguments.
;
; 1.) Copy the two input shapes into the temporary cellview
; 2.) Perform the boolean and on the two shapes and return
;     the result to the text layer
; 3.) Clean up the temporary cell view by removing all shapes
;     on the input argument shape layers making it clean for
;     the next overlap operation 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( isOverlapping (( waf wafer ) shapeA shapeB)
  let((layA layB layC result lpp)  
    dbCopyFig( getShape(shapeA) waf->tempCv)
    dbCopyFig( getShape(shapeB) waf->tempCv)
    layA = getLayer(shapeA)
    layB = getLayer(shapeB)
    layC = "text"
    result = leLayerAnd(waf->tempCv list( layA getPurpose(shapeA))
			   list( layB Purpose(shapeB))
			   list( layC "drawing"))
    ; Delete all shapes on the layers above in the temporary cellview
    foreach( layerName '( layA layB layC)
      lpp = car( exists( l (waf->tempCv~>layerPurposePairs l~>layerName == layerName))
      foreach( shape lpp~>shapes 
        dbDeleteObject( shape))
      )
    )
    result
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;######################################################
;######################################################
;######################################################


	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  numbers.ils: numbers class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( numbers (polygon2)
	  ( 
		( val @reader getVal @writer setVal) 
		( width @reader getWidth )
		( height @reader getHeight )
		( scale )
		( cd )
		( c0 )
		( c1 )
		( c2 )
		( c3 )
		( c4 )
		( c5 )
		( c6 )
		( c7 )
		( c8 )
		( c9 )								
	  )
);defClass
;#####################################################
; Class constructor
; This method initializes the class
; Initialized/Default Heigth is 50
;#####################################################
defmethod( initializeInstance @after ((obj numbers))  
	   obj->val = nil
	   obj->width = nil
	   obj->height = nil
	   obj->scale = 1.0
	   obj->cd  = list(list(-5.5 -45.0) 
			   list(-5.5 1.0) 
			   list(5.5 1.0) 
			   list(5.5 -5.0) 
			   list(-5.5 -5.0)
			   list(-5.5 -45.0) 
			   list(10.0 -45.0) 
			   list(10.0 42.5) 
			   list(-10.0 42.5) 
			   list(-10.0 -45.0))
	   obj->c0  = list(list(35.0 -45.0) 
			   list(-35.0 -45.0) 
			   list(-35.0 42.5) 
			   list(23.0 42.5) 
			   list(23.0 35.0)
			   list(5.0 35.0) 
			   list(5.0 27.0) 
			   list(15.0 27.0) 
			   list(15.0 -29.5) 
			   list(-15.0 -29.5)
			   list(-15.0 27.0) 
			   list(-5.0 27.0) 
			   list(-5.0 35.0) 
			   list(-23.0 35.0) 
		           list(-23.0 -37.5)
			   list(23.0 -37.5) 
			   list(23.0 42.5) 
			   list(35.0 42.5))
	   obj->c1 = list( list(35.0 -45.0) 
		           list(-35.0 -45.0) 
		           list(-35.0 42.5) 
			   list(14.0 42.5) 
			   list(14.0 -29.5)
			   list(4.0 -29.5) 
			   list(4.0 31.0) 
			   list(-14.0 31.0) 
			   list(-14.0 25.0)
                           list(-4.0 25.0)
			   list(-4.0 -29.5)
			   list(-14.0 -29.5)
			   list(-14.0 -37.5)
			   list(14.0 -37.5)
			   list(14.0 42.5)
                           list(35.0 42.5))
	   obj->c2 = list(list(35.0 -45.0) 
			  list(-35.0 -45.0) 
			  list(-35.0 42.5) 
			  list(23.0 42.5) 
			  list(23.0 35.0)
			  list(-23.0 35.0) 
			  list(-23.0 27.0) 
			  list(14.55 27.0) 
			  list(14.55 2.5) 
			  list(-23.0 2.5)
			  list(-23.0 -37.5) 
			  list(23.0 -37.5) 
			  list(23.0 -29.5) 
			  list(-15.0 -29.5) 
			  list(-15.0 -6.0)
			  list(23.0 -6.0) 
			  list(23.0 42.5) 
			  list(35.0 42.5))
	   obj->c3 = list(list(35.0 -45.0) 
			  list(-35.0 -45.0) 
			  list(-35.0 42.5) 
			  list(23.0 42.5) 
		          list(23.0 35.0)
			  list(-23.0 35.0) 
			  list(-23.0 27.0) 
		          list(17.0 27.0) 
			  list(17.0 1.5) 
			  list(-23.0 1.5)
			  list(-23.0 -6.5) 
			  list(17.0 -6.5) 
			  list(17.0 -29.5) 
		          list(-23.0 -29.5) 
			  list(-23.0 -37.5)
		          list(23.0 -37.5) 
			  list(23.0 42.5) 
		          list(35.0 42.5))
	   obj->c4 = list(list(35.0 -45.0) 
			  list(-35.0 -45.0) 
			  list(-35.0 42.5) 
			  list(23.0 42.5) 
			  list(23.0 35.0)
			  list(15.0 35.0) 
			  list(15.0 5.5) 
			  list(-15.0 5.5) 
			  list(-15.0 35.0) 
			  list(-23.0 35.0)
			  list(-23.0 -2.5) 
			  list(15.0 -2.5) 
			  list(15.0 -37.5) 
			  list(23.0 -37.5) 
			  list(23.0 42.5)
			  list(35.0 42.5))
	   obj->c5 = list(list(35.0 -45.0) 
			  list(-35.0 -45.0) 
			  list(-35.0 42.5) 
			  list(23.0 42.5) 
			  list(23.0 35.0)
			  list(-23.0 35.0) 
			  list(-23.0 -5.5) 
			  list(15.0 -5.5) 
			  list(15.0 -29.5) 
			  list(-23.0 -29.5)
			  list(-23.0 -37.5) 
			  list(23.0 -37.5) 
			  list(23.0 2.5) 
			  list(-15.0 2.5) 
			  list(-15.0 27.0)
			  list(23.0 27.0) 
			  list(23.0 42.5) 
			  list(35.0 42.5))
	   obj->c6 = list(list(35.0 -45.0) 
			  list(-35.0 -45.0) 
			  list(-35.0 42.5) 
			  list(23.0 42.5) 
			  list(23.0 1.5)
		          list(-2.0 1.5) 
			  list(-2.0 -6.5) 
			  list(15.0 -6.5) 
			  list(15.0 -29.5) 
			  list(-15.0 -29.5)
			  list(-15.0 25.0) 
			  list(18.5 25.0) 
			  list(18.5 33.0) 
			  list(-23.0 33.0) 
			  list(-23.0 -37.5)
			  list(23.0 -37.5) 
			  list(23.0 42.5) 
			  list(35.0 42.5))
	   obj->c7 = list(list(35.0 -45.0) 
		     	  list(-35.0 -45.0) 
			  list(-35.0 42.5) 
			  list(23.0 42.5) 
			  list(23.0 33.0)
			  list(-23.0 33.0) 
			  list(-23.0 25.0) 
			  list(15.0 25.0) 
			  list(15.0 -37.5) 
			  list(23.0 -37.5)
			  list(23.0 42.5)
			  list(35.0 42.5))
	   obj->c8 = list(list(35.0 -45.0) 
			  list(-35.0 -45.0) 
			  list(-35.0 42.5) 
			  list(23.0 42.5) 
			  list(23.0 28.0)
			  list(15.0 28.0) 
			  list(15.0 1.5) 
			  list(-15.0 1.5) 
			  list(-15.0 25.0) 
			  list(7.0 25.0)
			  list(7.0 33.0) 
			  list(-23.0 33.0) 
			  list(-23.0 -32.5) 
			  list(-15.0 -32.5) 
			  list(-15.0 -6.5)
			  list(15.0 -6.5) 
			  list(15.0 -29.5) 
			  list(-7.0 -29.5) 
			  list(-7.0 -37.5) 
			  list(23.0 -37.5)
			  list(23.0 42.5) 
			  list(35.0 42.5))
	   obj->c9 = list(list(35.0 -45.0) 
			  list(-35.0 -45.0) 
			  list(-35.0 42.5) 
			  list(23.0 42.5) 
			  list(23.0 33.0)
			  list(-23.0 33.0) 
			  list(-23.0 -4.5) 
			  list(7.0 -4.5) 
			  list(7.0 3.5) 
			  list(-15.0 3.5)
			  list(-15.0 25.0) 
			  list(15.0 25.0) 
			  list(15.0 -37.5) 
			  list(23.0 -37.5) 
			  list(23.0 42.5)
			  list(35.0 42.5))
);defmethod

;#####################################################
; Width and height of of number member
;#####################################################

;#####################################################
; Generates a number polygon
;#####################################################
defmethod( generate (( np numbers ))
  let( (ret)
	   ret=nil
	   case(np->val
	       ("-"
	         ret=np->cd
               )
	       ("0"
	         ret=np->c0
               )
	       ("1"
	         ret=np->c1
               )
	       ("2"
	         ret=np->c2
               )
	       ("3"
	         ret=np->c3
               )
	       ("4"
	         ret=np->c4
               )
	       ("5"
	         ret=np->c5
               )
	       ("6"
	         ret=np->c6
               )
	       ("7"
	         ret=np->c7
               )
	       ("8"
	         ret=np->c8
               )
	       ("9"
	         ret=np->c9
               )
	       (t
	         ret=nil
	       )
	    );case
	    setVertices(np ret)
	    np->width  = maxx(np) - minx(np) 
	    np->height = maxy(np) - miny(np)
	    ret
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  stamp.ils: stamp generator class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( stamp (geometry)
  ( 
    ( chars @reader getChars @writer setChars )
    ( origin @reader getOrigin @writer setOrigin )
    ( layer @reader getLayer @writer setLayer )
    ( purpose @reader getPurpose @writer setPurpose )
    ( len @reader getLength )							
  )
);defClass
;#####################################################
; Class constructor
;#####################################################
defmethod( initializeInstance @after ((obj stamp))
  obj->chars = ""  
  obj->origin = '()
  obj->layer = "text"
  obj->purpose = "drawing"
  obj->len = nil
);defmethod	   
;#####################################################
; Print a given array number within a cellview
;#####################################################
defmethod( generate (( st stamp ))
  let( (char an shift val cTran cwidth cTran wid)
    st->len = strlen(st->chars)
    an = makeInstance( 'alphaNumeric )
    shift = 0.0
    for(i 0 sub1(st->len)
;      char = getchar(st->chars i+1)
      char = substring(st->chars i+1 1)
      setVal(an char)
      val = generate(an)
      cTran = makeInstance( 'transform2 )
      setVertices(cTran val)
      cloneRectTran(cTran)
      setLayer(cTran getLayer(st))
      setPurpose(cTran getPurpose(st))
      translate(cTran list(shift 0.0))
      addTransform(st cTran)
      wid = getWidth(an)
      shift = shift + 1.2*wid
    );for
    translate(st list(xCoord(st->origin) yCoord(st->origin)))
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GeometricObject.ils: generic geometric class
; Represents all the objects in the construction. It defines the "consraints"
; slot. This slot list all teh other objects which need to be notified when
; the object updates.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Geometric Constructions:
; 1.) A point to lie on two intersecting lines
; 2.) A line to pass through two points
; 3.) A line to pass through a point and be parallel to another line
; 4.) A line to pass through a point and be perpendicular to another line
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Implementation:
; 1.) Call a SKILL function repeatedly to specify sever free points
; 2.) Call another SKILL function to construct the dependend points and lines
; 3.) Enter a SKILL expression to change the coordinates of one of the free points
; 4.) Call a SKILL function to PROPAGATE the change though the constrained points and lines
; 5.) Call a SKILL functionto describe on of the constrained points or lines
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Class Heirarchy:
; Geometric Object ------- Point --------- IntersectingTwoLinesPoint
;                          Line  --------- TwoPointsLine
;                                --------- parallelLineThruPoint
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generic Subclass Methods: Each of the generics base methods simply
;                           raise an error if they are not called in
;                           a dependent object (heirarchically via inheritance)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method propagates changes. It updates the 
; coordinates or equations of an object and calls
; itself recursively for each dependendent object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defgeneric( Update ( obj )
  error("Update is a subclass reponsibility\n")
);defgeneric
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Prints a description of an object and calls
; itself recursively for each dependent object
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defgeneric( Describe ( obj )
  error("Describe is a subclass reponsibility\n")
);defgeneric
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Verifies that a point or line statisfies its
; contraints
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defgeneric( Validate ( obj )
  error("Validate is a subclass reponsibility\n")
);defgeneric
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Adds an object to another objects list of 
; constraints
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defgeneric( Connect ( obj constraint )
  error("Connect is a subclass reponsibility\n")
);defgeneric
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Renders a "renderable" object (points and lines)
; into the cellview reference
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defgeneric( renderGeo ( obj constraint )
;  error("Connect is a subclass reponsibility\n")
;);defgeneric
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Class Definition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( geomObject ()
  (
	( constraints @reader getConstraints @writer setConstraints @initform nil )
	( ref @reader getRef @writer setRef @initform nil)
  )
);defclass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; List of connection constraints:
; This method connects GeometricObjects together based upon a
; list of constraints. The argument is added to the existing 
; list of constraints. The method first checks to make sure
; the constrainnt argument insn't already in the list (only new constraints
; are added)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Connect (( obj geomObject ) constraint )
  if(!null(constraint) then
    when( !member( constraint obj->constraints)
      obj->constraints = cons(constraint obj->constraints)
    );when
  );if
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This is a base update method which prints a list of the most current
; constraints, validates the geomObj, and Update the most current constraints
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Update (( obj geomObject ))
  ;printf( "Updating constraints %L(%s) for %L(%s) \n" obj->constraints className(classOf(obj->constraints)) obj className(classOf(obj)))
  printf( "Updating constraints for %L(%s) \n" obj className(classOf(obj)))
  Validate( obj )
  foreach( constraint obj->constraints
    Update( constraint )
    printf( "      Constraint: %L(%s)\n" constraint className(classOf(constraint)))
  );foreach
  t
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; point.ils: point class inheriting from geomObject
;            Represents w point with coordinate slots x and y
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( point (geomObject)
  (
	( name @reader getName @writer setName )
	( x    @reader getX @writer setX )
        ( y    @reader getY @writer setY )
  )
);defclass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj point))
  obj->name = nil 
  obj->x = 0.0
  obj->y = 0.0
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Describe (( obj point ))
  printf("%s at (%f,%f)\n" className(classOf(obj)) float(obj->x) float(obj->y) )
);defmethod
; Nothing to update about a point
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( render (( obj point ))
  t
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Nothing to update about a point
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Validate (( obj point ))
  t
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; line.ils: line class represents a line with slots A, B, and C.
;           A, B, and C are coefficients of the line equation: Ax+By+C=0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( line ( geomObject )
  (
	( A @reader getA @writer setA )
	( B @reader getB @writer setB )
	( C @reader getC @writer setC )
  )
);defclass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj line))
  obj->A = 0.0 
  obj->B = 0.0
  obj->C = 0.0
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method simply decribes the line equation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Describe (( obj line ))
  printf("%s (%f)*x+(%f)*y+%f=0: (Ax+By+C=0)\n" className(classOf(obj)) float(obj->A) float(obj->B) float(obj->C))
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; twoPointsLine.ils: Inherits from the line class. Class that creates a 
;                     line pasing through two points. Contains two members
;                     that are points of that define the line
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( twoPointsLine ( line )
  (
	( P1 @reader getPoint1 @writer setPoint1)
	( P2 @reader getPoint2 @writer setPoint2)
  )
);defclass
;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj twoPointsLine))
  obj->P1 = makeInstance( 'point ) 
  obj->P2 = makeInstance( 'point )
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( setP1 (( obj twoPointsLine ) pnt)
  setX(obj->P1 xCoord(pnt))
  setY(obj->P1 yCoord(pnt))
  Describe(obj->P1)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( setP2 (( obj twoPointsLine ) pnt)
  setX(obj->P2 xCoord(pnt))
  setY(obj->P2 yCoord(pnt))
  Describe(obj->P2)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Describe (( obj twoPointsLine ))
  callNextMethod( obj )
  printf("...containing\n")
  Describe( obj->P1 )
  Describe( obj->P2 )
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Validate (( obj twoPointsLine ))
  let( (x1 y1 x2 y2 A B C )
     x1 = obj->P1->x
     x2 = obj->P2->x
     y1 = obj->P1->y
     y2 = obj->P2->y
     A = obj->A
     B = obj->B
     C = obj->C
     if( A*x1+B*y1+C != 0.0 then
       error( "Invalid twoPointsLine\n" )
     );if
     if( A*x2+B*y2+C != 0.0 then
       error( "Invalid twoPointsLine\n" )
     );if
     t
     );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( Update (( obj twoPointsLine ))
  let( (x1 y1 x2 y2 m b)
    x1 = obj->P1->x
    x2 = obj->P2->x
    y1 = obj->P1->y
    y2 = obj->P2->y
    if( x2-x1 != 0 then
      m = (y2-y1)*1.0/(x2-x1)
      b = y2-m*x2
      obj->A = -m
      obj->B = 1
      obj->C = -b
    else
      obj->A = 1.0
      obj->B = 0.0
      obj->C = -x1
    );if
  );let
  callNextMethod( obj )
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;######################################################
;# rectangle.ils: Rectangle class
;######################################################
defclass( rectangle (polygon2)
	  (
		( width @reader getWidth @writer setWidth )
		( height @reader getHeight @writer setHeight )
	  )				  
) ; defclass

;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj rectangle)) 
	   obj->width  = 1.0
           obj->height = 1.0
);defmethod

;######################################################
;######################################################
defmethod( generate (( rect rectangle ))
  let( ( vertices )
	   vertices = '()
	   ;ll
	   vertices = cons(list(-abs(rect->width)/2 -abs(rect->height)/2) vertices)
	   ;lr
	   vertices = cons(list( abs(rect->width)/2 -abs(rect->height)/2) vertices)
	   ;ur
	   vertices = cons(list( abs(rect->width)/2  abs(rect->height)/2) vertices)
	   ;ul
	   vertices = cons(list(-abs(rect->width)/2  abs(rect->height)/2) vertices)
	   ;ll (again to close the polygon)
	   vertices = cons(list(-abs(rect->width)/2 -abs(rect->height/2)) vertices)
	   vertice = reverse(vertices)
	   setVertices(rect reverse(vertices))
	   setCentroid(rect list(0.0 0.0))
	   setRectTran(rect)
	   getCentroid(rect)
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method chamfers the upper right and left corners
; of the rectangle
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( chamfer (( rect rectangle ) arg)
  let( (ur nur0 nur1 ul nul0 nul1 xd newVertices)
    ur = nth(2 getVertices(rect))
    ul = nth(3 getVertices(rect))
    xd = abs(xCoord(ul))+abs(xCoord(ur))-2*abs(arg)
    if( xd >= 0.0 then
      nur0 = list( xCoord(ur)     yCoord(ur)-arg)
      nur1 = list( xCoord(ur)-arg yCoord(ur))
      nul0 = list( xCoord(ul)+arg yCoord(ul))
      nul1 = list( xCoord(ul)     yCoord(ul)-arg)
      newVertices = '()
      ;ll (same)
      newVertices = cons(list(-rect->width/2 -rect->height/2) newVertices)
      ;lr (same )
      newVertices = cons(list( rect->width/2 -rect->height/2) newVertices)
      ;;;;;;;;;;;;;;;;;;;;;;
      ;chamfered ur start
      ;;;;;;;;;;;;;;;;;;;;;;
      ;nur0
      newVertices = cons(nur0 newVertices)
      ;nur1
      newVertices = cons(nur1 newVertices)
      ;;;;;;;;;;;;;;;;;;;
      ;chamfered ur end 
      ;;;;;;;;;;;;;;;;;;;
      ;ur (deleted)
      ;newVertices = cons(list( rect->width/2  rect->height/2) newVertices)
      ;;;;;;;;;;;;;;;;;;;;;;
      ;chamfered ul start
      ;;;;;;;;;;;;;;;;;;;;;;
      ;nul0
      newVertices = cons(nul0 newVertices)
      ;nul1
      newVertices = cons(nul1 newVertices)
      ;;;;;;;;;;;;;;;;;;;
      ;chamfered ul end 
      ;;;;;;;;;;;;;;;;;;;
      ;ul (deleted)
      ;newVertices = cons(list(-rect->width/2  rect->height/2) newVertices)
      ;ll (same)
      newVertices = cons(list(-rect->width/2 -rect->height/2) newVertices)
      setVertices(rect newVertices) 
    else
      println("ERROR(rectangle): Intersecting chamfers - operation aborted")
    );if
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method tapers the rigtht side of the rectangle
; using chamferUr and chamferLr above.
; Fixme: A square that is chamfered becomes a triangle
;        which could take the place of the triangle class
;        (centroid remains the same)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( taperLeft (( rect rectangle ) )
  nil
);defmethod



;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  triangle.ils: Trianlge Class
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( triangle (polygon2)
	  (
		( base @reader getBase @writer setBase )
		( height @reader getHeight @writer setHeight )
	  )				  
) ; defclass

;######################################################
;
;######################################################
defmethod( initializeInstance @after ((obj triangle)) 
	   obj->base  = 1.0
           obj->height = 1.0
);defmethod

;######################################################
;######################################################
defmethod( generate (( tri triangle ))
  let( (vertices)
	   vertices = '()
	   vertices = cons(list(-tri->base/2 -tri->height/2) vertices)
	   vertices = cons(list( tri->base/2 -tri->height/2) vertices)
	   vertices = cons(list( 0            tri->height/2) vertices)
	   vertices = cons(list(-tri->base/2 -tri->height/2) vertices)
	   setVertices(tri vertices)
	   setCentroid(tri list(0.0 0.0))
	   setRectTran(tri)
	   getCentroid(tri)
  );let
);defmethod
;######################################################
;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  circle.ils: On Grid Circle Generator Object based upon CORDIC 
;              vector rotation algorithm.
;              Note: All centroids for subset circles (half, quarter, etc.)
;              are defined to have the same centroid as the original
;              circle
;
;              FIXME: Sub-circular shapes are not ending at 90 degrees on both sides
;                     Need to add an addition point one grid increment to get the
;                     double sided 90. Added 1 grid increment of FUDGE to the cframe
;                     corners to compensate for this problems
;              FIXME: Need a delta filter to reduce the number of points in these
;                     circular constructs. Only keep the points that are changing
;                     and the point just prior to the change ...
;              FIXME: for large diameter circtles need to break the polygons into
;                     a group of segments that are some maximum number of vertices
;                     (maximimum is 2048 for the Cadence rendering). Circle will
;                     have to inherit from geometry rather than polygon2 and 
;                     contain a number of circle transforms ...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( circle (polygon2)
	  (
		( radius @writer setRadius )
		( orig @writer setOrig @reader getOrig)
		( origin @writer setOrigin @reader getOrigin)
		( area @reader getArea)
		( direction )
		( X )
		( Y )
		( grid )
		( id )			  
	  )
) ; defClass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Class Constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj circle)) 
	   obj->radius = 1.0
	   obj->orig = list(0.0 0.0)
	   obj->origin = list(0.0 0.0)
	   obj->X = 0.0
           obj->Y = 0.0
	   obj->grid = 0.025
	   obj->direction = 0
	   obj->id="cir"
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Incrementally generates next vertex based upon CORDIC constraints
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( genNextVertex ((cir circle))
  let( ( (grid cir->grid)
         X0 Y0 R0 D0 X1 Y1 R1 D1 X2 Y2 R2 D2 X3 Y3 R3 D3 
         X4 Y4 R4 D4 X5 Y5 R5 D5 X6 Y6 R6 D6 X7 Y7 R7 D7)
 	  if( (cir->direction == 0 || cir->direction == 1 || cir->direction == 7) then
   	     X0 = cir->X + grid
   	     Y0 = cir->Y
	     R0 = (X0**2 + Y0**2)**0.5
	     D0 = abs(R0-cir->radius)
          );if
	  if( (cir->direction ==  1 || cir->direction == 2 || cir->direction == 0) then
	     X1 = cir->X + grid
	     Y1 = cir->Y - grid
	     R1 = (X1**2 + Y1**2)**0.5
	     D1 = abs(R1-cir->radius)
	  );if
	  if( (cir->direction ==  2 || cir->direction == 3 || cir->direction == 1) then
	     X2 = cir->X
	     Y2 = cir->Y - grid
	     R2 = (X2**2 + Y2**2)**0.5
	     D2 = abs(R2-cir->radius)
	  );if
	  if( (cir->direction == 3 || cir->direction == 4 || cir->direction == 2) then
	     X3 = cir->X - grid
   	     Y3 = cir->Y - grid
	     R3 = (X3**2 + Y3**2)**0.5
	     D3 = abs(R3-cir->radius)
 	  );if
	  if( (cir->direction == 4 || cir->direction == 5 || cir->direction == 3) then
	     X4 = cir->X - grid
	     Y4 = cir->Y
	     R4 = (X4**2 + Y4**2)**0.5
	     D4 = abs(R4-cir->radius)
	  );if
	  if( (cir->direction == 5 || cir->direction == 6 || cir->direction == 4) then
	     X5 = cir->X - grid
	     Y5 = cir->Y + grid
	     R5 = (X5**2 + Y5**2)**0.5
	     D5 = abs(R5-cir->radius)
	  );if
	  if( (cir->direction == 6 || cir->direction == 7 || cir->direction == 5) then
	     X6 = cir->X
	     Y6 = cir->Y + grid
	     R6 = (X6**2 + Y6**2)**0.5
	     D6 = abs(R6-cir->radius)
	  );if
	  if( (cir->direction == 7 || cir->direction == 0 || cir->direction == 6) then
	     X7 = cir->X + grid
	     Y7 = cir->Y + grid
	     R7 = (X7**2 + Y7**2)**0.5
	     D7 = abs(R7-cir->radius)
	  );if
	  caseq( cir->direction
	 	(0
		  ; Possible 7 0 1  
		  if( (D0 < D1 && D0 < D7) then
		    ;Go D0 
		    cir->X = X0
 		    cir->Y = Y0
		    cir->direction= 0
	          else
	            if( (D1 < D0 && D1 < D7) then
	              ; Go D1 
		      cir->X = X1
 		      cir->Y = Y1
		      cir->direction= 1
		    else
		      ; Go D7 
		      cir->X = X7
 		      cir->Y = Y7
		      cir->direction= 7
		    );if
		  );if
	        );0
                (1
		  ; Possible 0 1 2   
		  if( (D1 < D2 && D1 < D0) then
		     ;Go D1 
		     cir->X = X1
 		     cir->Y = Y1
		     cir->direction= 1
		   else
		      if( (D2 < D1 && D2 < D0) then
		        ; Go D2 
			cir->X = X2
 		     	cir->Y = Y2
		     	cir->direction= 2
		       else
		        ; Go D0
			cir->X = X0
 		     	cir->Y = Y0
		     	cir->direction= 0 
		    );if
		  );if
	        );1
                (2
		  ;  Possible 1 2 3
		  if( (D2 < D3 && D2 < D1) then
		    ; Go D2 
		     cir->X = X2
 		     cir->Y = Y2
		     cir->direction= 2 
		  else
		    if( (D3 < D2 && D3 < D1) then
 		       ; Go D3 
		       cir->X = X3
 		       cir->Y = Y3
		       cir->direction= 3 
 		    else
 		       ;Go D1 
		       cir->X = X1
 		       cir->Y = Y1
		       cir->direction= 1 
 		   );if
   		  );if
 	       	);2
                (3
 	          ;Possible 2 3 4 
		  if( (D3 < D4 && D3 < D2) then
   		    ;Go D3 
		    cir->X = X3
 		    cir->Y = Y3
		    cir->direction= 3 
   		   else
		     if( (D4 < D3 && D4 < D2) then
 		       ; Go D4 
		       cir->X = X4
 		       cir->Y = Y4
		       cir->direction= 4
 		      else
			; Go D2 
			cir->X = X2
 		        cir->Y = Y2
		        cir->direction= 2
 		     );if
   		  );if
 	        );3
   	        (4
		  ; Possible  3 4 5 
 		  (if D4 < D5 && D4 < D3 then
   		    ; Go D4
		     cir->X = X4
 		     cir->Y = Y4
		     cir->direction= 4
   		   else
		     (if D5 < D4 && D5 < D3 then
 		       ; Go D5 
		       cir->X = X5
 		       cir->Y = Y5
		       cir->direction= 5
 		      else
 		       ; Go D3 
		       cir->X = X3
 		       cir->Y = Y3
		       cir->direction= 3
 		     );if
   		   );if
                 );4
	         (5
		   ;Possible 4 5 6 
 		   if( (D5 < D6 && D5 < D4) then
   		     ; Go D5 
		     cir->X = X5
 		     cir->Y = Y5
		     cir->direction= 5
   		    else
   		      if( (D6 < D5 && D6 < D4) then
 		        ; Go D6 
			cir->X = X6
 		        cir->Y = Y6
		        cir->direction= 6
 		      else
 		       ; Go D4
		         cir->X = X4
 		         cir->Y = Y4
		         cir->direction= 4 
		     );if
   		   );if
 	         );5
   	         (6
		   ; Possible  5 6 7 
 		   if( (D6 < D7 && D6 < D5) then
   		     ; Go D6 
		     cir->X = X6
 		     cir->Y = Y6
		     cir->direction= 6
                    else
                      if( (D7 < D6 && D7 < D5) then
 		        ;Go D7 
			cir->X = X7
 		     	cir->Y = Y7
		     	cir->direction= 7
 		      else
		        ;Go D5 
			cir->X = X5
 		     	cir->Y = Y5
		     	cir->direction= 5
 		     );if
   		   );if
	         );6
    	         (7
	           ;Possible 6 7 0 
 		   if( D7 < D0 && D7 < D6 then
   		     ;Go D7 
		     cir->X = X7
 		     cir->Y = Y7
		     cir->direction= 7
   		    else
   		       if( (D0 < D7 && D0 < D6) then
 		         ;Go D0 
			 cir->X = X0
 		    	 cir->Y = Y0
		     	 cir->direction= 0
 		        else
		         ;Go D6
			 cir->X = X6
 		     	 cir->Y = Y6
		     	 cir->direction= 6 
 		       );if
   		    );if
 	         );7
  	   );caseq
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method generates the ON-GRID "circle" vertex list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generate (( cir circle ))
	   let( (count)
	   	;Initialize Members
	   	cir->vertices = '()
           	cir->direction= 0
	   	cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
		cir->X = 0.0
		cir->Y = cir->radius
		cir->orig = list(cir->X cir->Y)
		genNextVertex(cir)
		count = 0
	   	while( !( (abs(cir->X) < (cir->grid)) && (abs((cir->radius)-(cir->Y)) < (cir->grid)) )
	   	        count = count + 1
		 	genNextVertex(cir)
		 	cir->vertices = cons(list(cir->X cir->Y) cir->vertices)	  		      
	   	);while
	   	if( count > 0 then
		    ; add in origin vertex to close circle
		    ;cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
	       	    count
	   	else
		    nil
	   	);if
		; Need to add starting point for algorithms that rely upon
 		; vertice perimeter completion (start vertex = end vertex)
		setCentroid(cir list(0.0 0.0))
		setRectTran(cir)
		calculateCentroid(cir->rtran)
	   );let
) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method generates the ON-GRID "half circle" vertex list
; forming the end shapes of capsules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generateHalfCircle (( cir circle ))
	   let( (count)
	   	;Initialize Members
	   	cir->vertices = '()
           	cir->direction= 0
		cir->vertices = cons(list(0.0 0.0) cir->vertices)
	   	cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
		cir->X = 0.0
		cir->Y = cir->radius
		cir->orig = list(0.0 0.0)
		genNextVertex(cir)
		count = 0
	   	while( !( (abs(cir->X) < (cir->grid)) && ((cir->Y)+cir->radius < (cir->grid)) )
	   	        count = count + 1
		 	genNextVertex(cir)
		 	cir->vertices = cons(list(cir->X cir->Y) cir->vertices)	  		      
	   	);while
	   	if( count > 0 then
		    ; add in origin vertex to close circle
		    cir->vertices = cons(list(0.0 -1*cir->radius) cir->vertices)
;		    cir->vertices = cons(list(0.0 0.0) cir->vertices)
	   	else
		    nil
	   	);if
		; Need to add starting point for algorithms that rely upon
 		; vertice perimeter completion (start vertex = end vertex)
		setCentroid(cir list(0.0 0.0))
		setRectTran(cir)
		calculateCentroid(cir->rtran)
	   );let
) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method generates the ON-GRID "quarter circle" vertex list
; forming a rounded corner or arc polygon
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generateQuarterCircle (( cir circle ))
	   let( (count)
	   	;Initialize Members
	   	cir->vertices = '()
           	cir->direction= 0
		cir->vertices = cons(list(0.0 0.0) cir->vertices)
	   	cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
		cir->X = 0.0
		cir->Y = cir->radius
		cir->orig = list(0.0 0.0)
		genNextVertex(cir)
		count = 0
	   	while( !( (abs(cir->X-cir->radius) < (cir->grid)) && (abs(cir->Y) < (cir->grid)) )
	   	        count = count + 1
		 	genNextVertex(cir)
		 	cir->vertices = cons(list(cir->X cir->Y) cir->vertices)	  		      
	   	);while
	   	if( count > 0 then
		    ; add in origin vertex to close circle
		    cir->vertices = cons(list(0.0 0.0) cir->vertices)
	       	    count
	   	else
		    nil
	   	);if
		; Need to add starting point for algorithms that rely upon
 		; vertice perimeter completion (start vertex = end vertex)
		setCentroid(cir list(0.0 0.0))
		setRectTran(cir)
		calculateCentroid(cir->rtran)
	   );let
) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method generates the ON-GRID "inverse quarter circle" vertex list
; forming a rounded inner corner or inverse arc polygon
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generateQuarterCircleInv (( cir circle ))
	   let( (count)
	   	;Initialize Members
	   	cir->vertices = '()
           	cir->direction= 0
		cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
	   	cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
		cir->X = 0.0
		cir->Y = cir->radius
		cir->orig = list(0.0 0.0)
		genNextVertex(cir)
		count = 0
	   	while( !( (abs(cir->X-cir->radius) < (cir->grid)) && (abs(cir->Y) < (cir->grid)) )
	   	        count = count + 1
		 	genNextVertex(cir)
		 	cir->vertices = cons(list(cir->X cir->Y) cir->vertices)	  		      
	   	);while
	   	if( count > 0 then
		    ; add in radial vertex to close circle
		    cir->vertices = cons(list(cir->radius 0.0) cir->vertices)
		    cir->vertices = cons(list(cir->radius cir->radius) cir->vertices)
	       	    count
	   	else
		    nil
	   	);if
		; Need to add starting point for algorithms that rely upon
 		; vertice perimeter completion (start vertex = end vertex)
		setCentroid(cir list(0.0 0.0))
		setRectTran(cir)
		calculateCentroid(cir->rtran)
	   );let
) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method generates the ON-GRID "circle" vertex list. The number of 
; circle polygon vertices is controlled by the nvert argument
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generatePolygon (( cir circle ) nvert )
	   let( (pi twoPi incr ang pnt theta x y n coord)
                pi = 3.1425972
		twoPi = 2*pi
	   	incr = 360.0 / nvert
		ang = 0.0
		n = 0
		while(ang < 360.0
		  pnt = makeInstance( 'point2 )
		  ;printf("Angle %f\n" ang)
		  theta = ang / twoPi
		  x = xCoord(cir->origin) + cir->radius
		  y = xCoord(cir->origin) + cir->radius 
		  coord = list(x y)
		  ;printf("Coord: %L\n" coord)
		  setPoint(pnt coord)
		  rotate(pnt ang)
		  scale(pnt 1.0/2**0.5)
		  printf("Coord: %L\n" getPoint(pnt))
		  appendPoint(cir->points pnt)
		  ang = ang + incr
		  n = n + 1
                );while
                n
	   );let
);defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;





	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  frame.il: Frame Vertex Generator Object 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;      v1 -----------------------v2  v7--v8
;      |                           ||     |
;      |    v4_____________________||     |
;      |     |        origin      v3|     |
;      |     |          +           |     |
;      |    v5-----------------------v6   |
;      |                                  |
;      v0--------------------------------v9
;      
; wido = outter frame width: V1 to V8
; widi = inner frame width: V4 to V3
; hgto = outter frame height: V0 to V1
; hgti = inner fram height: V5 to V4
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( frame (polygon2)
	  (
		( wido @reader getWido @writer setWido )
		( widi @reader getWidi @writer setWidi )
		( hgto @reader getHgto @writer setHgto )		
		( hgti @reader getHgti @writer setHgti )
		( v0 )
		( v1 )
		( v2 )
		( v3 )
		( v4 )
		( v5 )
		( v6 )
		( v7 )
		( v8 )
   		( v9 )		  
	  )
) ; defClass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Class Constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj frame)) 
	   obj->wido = 4.0
	   obj->hgto = 4.0
	   obj->widi = 1.0
           obj->hgti = 1.0
	   obj->v0=list(-obj->wido/2.0 -obj->hgto/2.0)
	   obj->v1=list(xCoord(obj->v0)  yCoord(obj->v0)+obj->hgto)
	   obj->v2=list(xCoord(obj->v1)+obj->wido-(obj->wido-obj->widi)/2.0 yCoord(obj->v1))
	   obj->v3=list(xCoord(obj->v2) yCoord(obj->v2)-(obj->hgto-obj->hgti)/2.0)
	   obj->v4=list(xCoord(obj->v3)-obj->wido+(obj->wido-obj->widi) yCoord(obj->v3))
	   obj->v5=list(xCoord(obj->v4) yCoord(obj->v4)-obj->hgti)
	   obj->v6=list(xCoord(obj->v5)+obj->widi yCoord(obj->v5))
	   obj->v7=list(xCoord(obj->v6) yCoord(obj->v1))
	   obj->v8=list(xCoord(obj->v1)+obj->wido yCoord(obj->v7))
	   obj->v9=list(xCoord(obj->v0)+obj->wido yCoord(obj->v0))
	   obj->vertices = list(obj->v0 obj->v1 obj->v2 obj->v3 obj->v4
                                obj->v5 obj->v6 obj->v7 obj->v8 obj->v9)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generate frame method
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generate ((frm frame))
  let((v0 v1 v2 v3 v4 v5 v6 v7 v8 v9)
	   v0=list(-frm->wido/2.0 -frm->hgto/2.0)
	   v1=list(xCoord(v0)  yCoord(v0)+frm->hgto)
	   v2=list(xCoord(v1)+frm->wido-(frm->wido-frm->widi)/2.0 yCoord(v1))
	   v3=list(xCoord(v2) yCoord(v2)-(frm->hgto-frm->hgti)/2.0)
	   v4=list(xCoord(v3)-frm->wido+(frm->wido-frm->widi) yCoord(v3))
	   v5=list(xCoord(v4) yCoord(v4)-frm->hgti)
	   v6=list(xCoord(v5)+frm->widi yCoord(v5))
	   v7=list(xCoord(v6) yCoord(v1))
	   v8=list(xCoord(v1)+frm->wido yCoord(v7))
	   v9=list(xCoord(v0)+frm->wido yCoord(v0))
	   frm->vertices = list(v0 v1 v2 v3 v4
                                v5 v6 v7 v8 v9)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Gets the vertices of the polygon
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getVertices ((frm frame))
   frm->vertices
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;######################################################
; trirect.ils: Triangle/Rectangle combination geometry class
;              Overall centroid of this geometry is defined
;              as the centroid of the rectangular body (not 
;              the actual centroid, but conveniently defined
;              for translation and rotation purposes)
;######################################################
defclass( trirect (geometry)
   (
	  ( width @reader getWidth @writer setWidth )
	  ( height @reader getHeight @writer setHeight )
   )				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj trirect)) 
	   obj->width  = 1.0
	   obj->height = 1.0 		     
);defmethod

;######################################################
; Generates the trirect geometry
;######################################################
defmethod( generate (( tr trirect ))
  let((body head bodyTran headTran)
    body = makeInstance( 'rectangle )			
    setHeight(body tr->height)
    setWidth(body tr->width)
    generate(body)
    setCentroid(tr getCentroid(body))
    head = makeInstance( 'triangle )
    setBase(head tr->height)
    setHeight(head tr->height)
    generate(head)
    bodyTran = makeInstance( 'transform2 )
    setVertices(bodyTran getVertices(body))
    setCentroid(bodyTran getCentroid(body))
    cloneRectTran(bodyTran)
    headTran = makeInstance( 'transform2 )
    setVertices(headTran getVertices(head))
    setCentroid(headTran getCentroid(head))
    cloneRectTran(headTran)
    rotate(headTran 270.0)
    translate(headTran list((tr->width+tr->height)/2.0 0.0)) 
    addTransform(tr bodyTran)
    addTransform(tr headTran)
    rectTranUnion(tr) 	   
  );let	   
);defmethod
;######################################################
;######################################################
;######################################################;######################################################
; capsule.ils: Capsule geometry class. Inherits from 
;              rectangle and circle objects
;              Centroid of this object is geometric
;              center of mass
;######################################################
defclass( capsule (geometry)
   (
	  ( width @reader getWidth @writer setWidth )
	  ( height @reader getHeight @writer setHeight )
   )				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj capsule))
	   obj->width  = 1.0
	   obj->height = 1.0 	     
);defmethod

;#####################################################
; This method generates the vertices and translation
; of the vertices of the object
;#####################################################
defmethod( generate (( cap capsule ))
  let((body capR capL bodyTran capRTran capLTran)
    ; Body Polygon
    body = makeInstance( 'rectangle )
    setHeight(body cap->height)
    setWidth(body cap->width)
    generate(body)
    setCentroid(cap getCentroid(body))
    ; Body Transform	
    bodyTran = makeInstance( 'transform2 )
    setVertices(bodyTran getVertices(body))
    setCentroid(bodyTran getCentroid(body))
    cloneRectTran(bodyTran)
    ; Right Cap Polygon   
    capR = makeInstance( 'circle )
    setGrid(capR 0.025)
    setRadius(capR cap->height/2.0)
    generateHalfCircle(capR)
    center(capR)
    ; Rigth Cap Transform
    capRTran = makeInstance( 'transform2 )
    setVertices(capRTran getVertices(capR))
    setCentroid(capRTran getCentroid(capR))
    cloneRectTran(capRTran)
    ; Left Cap Polygon
    capL = makeInstance( 'circle )
    setGrid(capL 0.025)
    setRadius(capL cap->height/2.0)
    generateHalfCircle(capL)
    center(capL)
    ; Left Cap Transform
    capLTran = makeInstance( 'transform2 )
    setVertices(capLTran getVertices(capL))
    setCentroid(capLTran getCentroid(capL))
    cloneRectTran(capLTran)
    ; Translations and Rotation of Transforms
    rotate(capLTran 180.0)
    translate(capRTran list((cap->width+cap->height/2.0)/2.0 0.0))
    translate(capLTran list( -(cap->width+cap->height/2.0)/2.0 0.0))
    ; Add Transforms (same layer) to the Geometry (layer group)
    addTransform(cap bodyTran)
    addTransform(cap capLTran)
    addTransform(cap capRTran) 
    rectTranUnion(cap)
  );let	   
);defmethod

;######################################################
;######################################################
;######################################################
;######################################################
;  gatePad.ils: FET gate pad class.
;               Width and height variables are associated
;               with the inner gate pad capsule     
;######################################################
defclass( gatePad (assembly)
   (
	  ( widthInner @reader getWidthInner @writer setWidthInner )
	  ( heightInner @reader getHeightInner @writer setHeightInner )
	  ( widthOutter @reader getWidthOutter @writer setWidthOutter )
	  ( heightOutter @reader getHeightOutter @writer setHeightOutter )
	  ( innerLayer @reader getInnerLayer @writer setInnerLayer )
	  ( innerPurpose @reader getInnerPurpose @writer setInnerPurpose )
	  ( outterLayer @reader getOutterLayer @writer setOutterLayer )
	  ( outterPurpose @reader getOutterPurpose @writer setOutterPurpose )
	  ( bsegLayer @reader getBsegLayer @writer setBsegLayer )
	  ( bsegPurpose @reader getBsegPurpose @writer setBsegPurpose )
	  ( centroid @reader getCentroid @writer setCentroid )
   )				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj gatePad)) 
	   obj->widthInner   = 1.0
	   obj->heightInner  = 1.0
 	   obj->widthOutter  = 1.0
	   obj->heightOutter = 1.1
	   obj->innerLayer = "text"
	   obj->outterLayer = "text"
	   obj->innerPurpose = "drawing"
	   obj->outterPurpose = "drawing"
	   obj->bsegLayer = "text"
	   obj->bsegPurpose = "drawing"
	   obj->centroid = makeInstance( 'point2 )
);defmethod

;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( gp gatePad ))
  capOutter = makeInstance('capsule)
  setWidth(capOutter gp->widthOutter)
  setHeight(capOutter gp->heightOutter)
  generate(capOutter)
  setLayer(capOutter getOutterLayer(gp))
  setPurpose(capOutter getOutterPurpose(gp))
  addGeometry(gp capOutter)
  rtsAdd(gp->rtrans getRectTran(capOutter))
;
  capInner = makeInstance('capsule)
  setWidth(capInner gp->widthInner)
  setHeight(capInner gp->heightInner)
  generate(capInner)
  setLayer(capInner getInnerLayer(gp))
  setPurpose(capInner getInnerPurpose(gp))
  addGeometry(gp capInner)
  rtsAdd(gp->rtrans getRectTran(capInner))
;
  bseg = makeInstance('rectangle)
  setWidth(bseg 2*gp->widthOutter)
  setHeight(bseg 2*gp->heightOutter)
  generate(bseg)
  bsegTran = makeInstance( 'transform2 )
  setVertices(bsegTran getVertices(bseg))
  setCentroid(bsegTran getCentroid(bseg))
  cloneRectTran(bsegTran)
  setLayer(bsegTran getBsegLayer(gp))
  setPurpose(bsegTran getBsegPurpose(gp))
  bsegGeom = makeInstance( 'geometry )
  addTransform(bsegGeom bsegTran)
  rectTranUnion(bsegGeom)
  addGeometry(gp bsegGeom)
  rtsAdd(gp->rtrans getRectTran(bsegGeom))
  rtsUnion(gp->rtrans)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;######################################################
; gateStem.ils: Capsule geometry class. Inherits from 
;               rectangle and circle objects
;               Centroid is defined as the center of 
;               mass of the body of the gateStem taper
;######################################################
defclass( gateStem (assembly)
   (
	  ( width @reader getWidth @writer setWidth )
	  ( length  @reader getLength @writer setLength )	  
	  ( widthTaper @reader getWidthTaper @writer setWidthTaper )
	  ( centroid @reader getCentroid @writer setCentroid )
	  ( layer @reader getLayer @writer setLayer )
	  ( purpose @reader getPurpose @writer setPurpose )
   )				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj gateStem)) 
	   obj->width  = 1.0
	   obj->length = 1.0 
	   obj->widthTaper = 1.0
	   obj->centroid = makeInstance( 'point2 )
	   obj->layer = "text"
	   obj->purpose = "drawing"
);defmethod

;######################################################
; Generates the geometry
;######################################################
defmethod( generate (( gs gateStem ))
  setCentroid(gs list(0.0 0.0))
  ; Gate Taper
  taper = makeInstance('trirect)
  setWidth(taper getWidthTaper(gs))
  setHeight(taper 3*getLength(gs))
  generate(taper)
  setLayer(taper getLayer(gs))
  setPurpose(taper getPurpose(gs))
  addGeometry(gs taper)
  rtsAdd(gs->rtrans getRectTran(taper))
  ; Gate stem
  rect = makeInstance('rectangle)
  setWidth(rect getWidth(gs))
  setHeight(rect getLength(gs))
  generate(rect)
  rectTran = makeInstance('transform2)
  addPolygon(rectTran rect)
  cloneRectTran(rectTran)
  setLayer(rectTran getLayer(gs))
  setPurpose(rectTran getPurpose(gs))
  translate(rectTran list(0.5*(getWidth(gs)+getWidthTaper(gs))+2*getLength(gs) 0.0))
  rectGeom = makeInstance('geometry)
  addTransform(rectGeom rectTran )
  rectTranUnion(rectGeom)
  addGeometry(gs rectGeom)
  rtsAdd(gs->rtrans getRectTran(rectGeom))
  rtsUnion(gs->rtrans)
  translate(gs list(8.75 0.0))
);defmethod

;######################################################
; FIXME: This should be in the assembly class
; Translates the entire assembly
;######################################################
defmethod( translate (( gs gateStem ) arg)
  foreach(geom getCollection(gs->geometries)
     translate(geom arg)
  );foreach
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; planarResistor.ils: Base planar resistor class 
;                     FIXME: Need to implement min len and wid checks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( planarResistor (assembly)
	  (
		( width @reader getWidth @writer setWidth )
		( length @reader getLength @writer setLength )
		( minWidth @reader getMinWidth @writer setMinWidth )
		( minLength @reader getMinLength @writer setMinLength )
		( termLen @reader getTermLen @writer setTermLen )
		( termEnc @reader getTermEnc @writer setTermEnc )
		( bodyLayer @reader getBodyLayer @writer setBodyLayer )
	  	( bodyPurpose @reader getBodyPurpose @writer setBodyPurpose )
		( contLayer @reader getContLayer @writer setContLayer )
	  	( contPurpose @reader getContPurpose @writer setContPurpose )
		( centroid @reader getCentroid @writer setCentroid )			
	  )				  
);defclass
;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj planarResistor)) 
	   obj->width  = 1.0
           obj->length = 1.0
	   obj->minWidth = 0.5
	   obj->minLength = 0.5
	   obj->termEnc = 0.5
	   obj->termLen = 1.0
	   obj->bodyLayer = "text"
	   obj->bodyPurpose = "drawing"
	   obj->contLayer = "text"
	   obj->contPurpose = "drawing"
	   obj->centroid = makeInstance( 'point2 )
);defmethod
;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( res planarResistor ))
  let((termWid termLen bodyLen cptrn cntrn body cont bTran 
       pConTran nConTran geomGroup cv)	
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Dimension Calculations
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    termWid = res->width+2.0*res->termEnc
    termLen = res->termLen+res->termEnc
    bodyLen = res->length+2*res->termLen 
    ; Contact transform shifts from Centroid of resistor body
    cptrn = -1.0*(res->termLen+res->termEnc+res->length)/2.0
    cntrn = -1.0*cptrn
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create the resistor body
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    body = makeInstance( 'rectangle )
    setWidth(body bodyLen)
    setHeight(body res->width)
    generate(body)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create the end contacts
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    cont = makeInstance( 'rectangle )
    setWidth(cont termLen)
    setHeight(cont termWid)
    generate(cont)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; body Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    bTran = makeInstance( 'transform2 )
    setVertices(bTran getVertices(body))
    setCentroid(bTran getCentroid(body))
    cloneRectTran(bTran)
    setLayer(bTran getBodyLayer(res))
    setPurpose(bTran getBodyPurpose(res))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; P Contact Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    pConTran = makeInstance( 'transform2 )
    setVertices(pConTran getVertices(cont))
    setCentroid(pConTran getCentroid(cont))
    cloneRectTran(pConTran)
    setLayer(pConTran getContLayer(res))
    setPurpose(pConTran getContPurpose(res))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; N Contact Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    nConTran = makeInstance( 'transform2 )
    setVertices(nConTran getVertices(cont))
    setCentroid(nConTran getCentroid(cont))
    cloneRectTran(nConTran)
    setLayer(nConTran getContLayer(res))
    setPurpose(nConTran getContPurpose(res))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Translate the P and N contacts to 
    ; the proper position
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    translate(pConTran list(cptrn 0))
    translate(nConTran list(cntrn 0))
    ; Add the transforms to a geometry
    ; group
    geomGroup = makeInstance('geometry)
    addTransform(geomGroup bTran)
    addTransform(geomGroup pConTran)
    addTransform(geomGroup nConTran )
    rectTranUnion(geomGroup)
    addGeometry(res geomGroup)
    rtsAdd(res->rtrans getRectTran(geomGroup))
    rtsUnion(res->rtrans)

  ; This is the target cellview add pins and
  ; nets to ...
  ;  cv = getRef(res)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Add in electrical nets and
  ; pins - Need to have net and
  ; purposes set on target layers
  ; in TF
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  pNet = dbMakeNet(cv "POS")
;  dbCreateTerm(pNet "P" "inputOutput")
;  nNet = dbMakeNet(cv "NEG")
;  dbCreateTerm(nNet "N" "inputOutput")
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Make a pin rectangle
;  pr = makeInstance( 'rectangle )
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Add in POS pin shape
  ; FIXME: Replace shape with new  flow
;  ppShp = makeInstance( 'shape )
;  setVertices(ppShp genRect(pr))
;  setLayer(ppShp "sd")
;  setPurpose(ppShp "net")
  ; Translate POS Pin Shape to proper position
;  shapeTranslate(ppShp list(cptrn  0))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Add in POS pin shape
  ; FIXME: Replace shape with new  flow
;  pnShp = makeInstance( 'shape )
;  setVertices(pnShp genRect(pr))
;  setLayer(pnShp "sd")	
;  setPurpose(pnShp "net")
  ; Translate POS Pin Shape to proper position
;  shapeTranslate(pnShp list(cntrn  0))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Set the shape references to the
  ; cv
;  setCvRef(ppShp  cv)
;  setCvRef(pnShp  cv)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Render the two pin shapes
;  pp = render(ppShp)
;  pn = render(pnShp)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Add Electrical Pins to the Pin Shapes
;  dbCreatePin(pNet pp "pp")
;  dbCreatePin(nNet pp "pn")
  
  );let
);defmethod
;######################################################
;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; planarCap.ils: Base planar capacitor class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( planarCap (assembly)
	  (
		( widthTop @reader getWidthTop @writer setWidthTop )
		( lengthTop @reader getLengthTop @writer setLengthTop )
		( layerTop @reader getLayerTop @writer setLayerTop)
		( purposeTop @reader getPurposeTop @writer setPurposeTop)
		( widthDiel @reader getWidthDiel @writer setWidthDiel )
		( lengthDiel @reader getLengthDiel @writer setLengthDiel )
		( layerDiel @reader getLayerDiel @writer setLayerDiel)
		( purposeDiel @reader getPurposeDiel @writer setPurposeDiel)
		( widthBot @reader getWidthBot @writer setWidthBot )
		( lengthBot @reader getLengthBot @writer setLengthBot )
		( layerBot @reader getLayerBot @writer setLayerBot)
		( purposeBot @reader getPurposeBot @writer setPurposeBot)
		( centroid @reader getCentroid @writer setCentroid )			
	  )				  
);defclass
;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj planarCap)) 
	   obj->widthTop  = 100.0
           obj->lengthTop = 100.0
	   obj->layerTop = "Text"
	   obj->purposeTop = "drawing"
	   obj->widthDiel  = 102.0
           obj->lengthDiel = 102.0
	   obj->layerDiel = "Text"
	   obj->purposeDiel = "drawing"
	   obj->widthBot  = 104.0
           obj->lengthBot = 104.0
	   obj->layerBot = "Text"
	   obj->purposeBot = "drawing"
	   obj->centroid = makeInstance( 'point2 )
);defmethod
;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( cap planarCap ))
  let((diel bot cv)	
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create Dielectric Layer
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    diel = makeInstance( 'rectangle )
    setWidth(diel cap->widthDiel)
    setHeight(diel cap->lengthDiel)
    generate(diel)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create Bottom Layer
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    bot = makeInstance( 'rectangle )
    setWidth(bot cap->widthBot)
    setHeight(bot cap->lengthBot)
    generate(bot)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create Top Layer
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    top = makeInstance( 'rectangle )
    setWidth(top cap->widthTop)
    setHeight(top cap->lengthTop)
    generate(top)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Dielectric Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    dTran = makeInstance( 'transform2 )
    setVertices(dTran getVertices(diel))
    setCentroid(dTran getCentroid(diel))
    cloneRectTran(dTran)
    setLayer(dTran getLayerDiel(cap))
    setPurpose(dTran getPurposeDiel(cap))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;  Bottom Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    bTran = makeInstance( 'transform2 )
    setVertices(bTran getVertices(bot))
    setCentroid(bTran getCentroid(bot))
    cloneRectTran(bTran)
    setLayer(bTran getLayerBot(cap))
    setPurpose(bTran getPurposeBot(cap))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Top Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    tTran = makeInstance( 'transform2 )
    setVertices(tTran getVertices(top))
    setCentroid(tTran getCentroid(top))
    cloneRectTran(tTran)
    setLayer(tTran getLayerTop(cap))
    setPurpose(tTran getPurposeTop(cap))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Geometry Group
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    geomGroup = makeInstance('geometry)
    addTransform(geomGroup dTran)
    addTransform(geomGroup bTran)
    addTransform(geomGroup tTran )
    rectTranUnion(geomGroup)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; This Assembly 
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    addGeometry(cap geomGroup)
    rtsAdd(cap->rtrans getRectTran(geomGroup))
    rtsUnion(cap->rtrans)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; FIXME: Defer Pins and Nets until
    ;        CDF flow is established 
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; This is the target cellview add pins and
    ; nets to ...
    ;  cv = getRef(res)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Add in electrical nets and
    ; pins - Need to have net and
    ; purposes set on target layers
    ; in TF
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;  pNet = dbMakeNet(cv "POS")
    ;  dbCreateTerm(pNet "P" "inputOutput")
    ;  nNet = dbMakeNet(cv "NEG")
    ;  dbCreateTerm(nNet "N" "inputOutput")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Make a pin rectangle
    ;  pr = makeInstance( 'rectangle )
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Add in POS pin shape
    ; FIXME: Replace shape with new  flow
    ;  ppShp = makeInstance( 'shape )
    ;  setVertices(ppShp genRect(pr))
    ;  setLayer(ppShp "sd")
    ;  setPurpose(ppShp "net")
    ; Translate POS Pin Shape to proper position
    ;  shapeTranslate(ppShp list(cptrn  0))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Add in POS pin shape
    ; FIXME: Replace shape with new  flow
    ;  pnShp = makeInstance( 'shape )
    ;  setVertices(pnShp genRect(pr))
    ;  setLayer(pnShp "sd")	
    ;  setPurpose(pnShp "net")
    ; Translate POS Pin Shape to proper position
    ;  shapeTranslate(pnShp list(cntrn  0))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Set the shape references to the
    ; cv
    ;  setCvRef(ppShp  cv)
    ;  setCvRef(pnShp  cv)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Render the two pin shapes
    ;  pp = render(ppShp)
    ;  pn = render(pnShp)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Add Electrical Pins to the Pin Shapes
    ;  dbCreatePin(pNet pp "pp")
    ;  dbCreatePin(nNet pp "pn")
  );let
);defmethod
;######################################################
;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; outline.ils: Chip/Reticle Outline class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( outline (assembly)
	  (
		( width @reader getWidth @writer setWidth )
		( length @reader getLength @writer setLength )
		( edgeWidth @reader getEdgeWidth @writer setEdgeWidth )
		( overlap @reader getOverlap @writer setOverlap )
		( layer @reader getLayer @writer setLayer )
	  	( purpose @reader getPurpose @writer setPurpose )
		( centroid @reader getCentroid @writer setCentroid )			
	  )				  
);defclass
;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj outline)) 
	   obj->width     = 10000.0
           obj->length    = 10000.0
	   obj->edgeWidth = 95.0
	   obj->overlap   = 4.0
	   obj->layer = "text"
	   obj->purpose = "drawing"
	   obj->centroid = makeInstance( 'point2 )
);defmethod
;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( ol outline ))
  let((frm0 wido widi hgto hgti delx delyi mwid mlen)
    wido = ol->width 
    widi = wido-2*ol->edgeWidth
    hgto = ol->length
    hgti = hgto-2*ol->edgeWidth
    frm0 = makeInstance( 'frame )
    setWido(frm0 wido)
    setWidi(frm0 widi)
    setHgto(frm0 hgto)
    setHgti(frm0 hgti)
    generate(frm0)
    mwid = 4.0
    mlen = 4.0
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame 0 transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    f0Tran = makeInstance( 'transform2 )
    setVertices(f0Tran getVertices(frm0))
    setCentroid(f0Tran getCentroid(frm0))
    cloneRectTran(f0Tran)
    setLayer(f0Tran getLayer(ol))
    setPurpose(f0Tran getPurpose(ol))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Alignment marker
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    am = makeInstance( 'rectangle )
    setWidth(am mwid)
    setHeight(am mlen)
    generate(am)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UR marker transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    urTran = makeInstance( 'transform2 )
    setVertices(urTran getVertices(am))
    setCentroid(urTran getCentroid(am))
    cloneRectTran(urTran)
    setLayer(urTran getLayer(ol))
    setPurpose(urTran getPurpose(ol))
    delx = (wido-mwid)/2.0
    dely = (hgto-mlen)/2.0
    translate(urTran list(delx dely))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UL marker transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ulTran = makeInstance( 'transform2 )
    setVertices(ulTran getVertices(am))
    setCentroid(ulTran getCentroid(am))
    cloneRectTran(ulTran)
    setLayer(ulTran getLayer(ol))
    setPurpose(ulTran getPurpose(ol))
    delx = -(wido-mwid)/2.0
    dely = (hgto-mlen)/2.0
    translate(ulTran list(delx dely))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR marker transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lrTran = makeInstance( 'transform2 )
    setVertices(lrTran getVertices(am))
    setCentroid(lrTran getCentroid(am))
    cloneRectTran(lrTran)
    setLayer(lrTran getLayer(ol))
    setPurpose(lrTran getPurpose(ol))
    delx = (wido-mwid)/2.0
    dely = -(hgto-mlen)/2.0
    translate(lrTran list(delx dely))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LL marker transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    llTran = makeInstance( 'transform2 )
    setVertices(llTran getVertices(am))
    setCentroid(llTran getCentroid(am))
    cloneRectTran(llTran)
    setLayer(llTran getLayer(ol))
    setPurpose(llTran getPurpose(ol))
    delx = -(wido-mwid)/2.0
    dely = -(hgto-mlen)/2.0
    translate(llTran list(delx dely))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Geometry Group
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    geomGroup = makeInstance('geometry)
    addTransform(geomGroup f0Tran)
    addTransform(geomGroup urTran)
    addTransform(geomGroup ulTran)
    addTransform(geomGroup lrTran)
    addTransform(geomGroup llTran)
    addGeometry(ol geomGroup)
    rtsAdd(ol->rtrans getRectTran(geomGroup))
    ;FIXME: bug in the this union!
    ; probably don't have a check to see if the markers
    ; are fully enclosed in the frame. Not checking that
    ; the union of a smaller poly contained fully in a 
    ; larger poly is simply the larger poly ...
    ;rtsUnion(ol->rtrans)
  );let
);defmethod
;###################################################################
;###################################################################
;###################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; memsCapBotCont.ils: Bottom plate connnection to mems cap 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( memsCapBotCont (assembly)
	  (
		( width @reader getWidth @writer setWidth )
		( length @reader getLength @writer setLength )
		( centroid @reader getCentroid @writer setCentroid )			
	  )				  
);defclass
;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj memsCapBotCont)) 
	   obj->width  = 100.0
           obj->length = 100.0
	   obj->centroid = makeInstance( 'point2 )
);defmethod
;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( mbc memsCapBotCont ))
  let((bot botCon dstp thk btran brTran dTran tTran)	
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Bottom plate attachement
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    bot = makeInstance( 'rectangle )
    setWidth(bot mbc->width)
    setHeight(bot mbc->length)
    generate(bot)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Electrode bottom plate bridge connection to Thick 
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    botCon = makeInstance( 'rectangle )
    setWidth(botCon 29.0)
    setHeight(botCon 254.0)
    generate(botCon)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Dielectric Strip
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    dstp = makeInstance( 'rectangle )
    setWidth(dstp 6.0)
    setHeight(dstp 264.0)
    generate(dstp)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Thick bottom plate attachment connection to MEMS switch
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    thk = makeInstance( 'rectangle )
    setWidth(thk 26.0)
    setHeight(thk 264.0)
    generate(thk)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Bottom Plate Connection Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    bTran = makeInstance( 'transform2 )
    setVertices(bTran getVertices(bot))
    setCentroid(bTran getCentroid(bot))
    cloneRectTran(bTran)
    setLayer(bTran "electrode")
    setPurpose(bTran "drawing")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Electrode Bridge Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    brTran = makeInstance( 'transform2 )
    setVertices(brTran getVertices(botCon))
    setCentroid(brTran getCentroid(botCon))
    cloneRectTran(brTran)
    setLayer(brTran "electrode")
    setPurpose(brTran "drawing")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Dielectric Strip Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    dTran = makeInstance( 'transform2 )
    setVertices(dTran getVertices(dstp))
    setCentroid(dTran getCentroid(dstp))
    cloneRectTran(dTran)
    setLayer(dTran "dielectric")
    setPurpose(dTran "drawing")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Thick Attach Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    tTran = makeInstance( 'transform2 )
    setVertices(tTran getVertices(thk))
    setCentroid(tTran getCentroid(thk))
    cloneRectTran(tTran)
    setLayer(tTran "thick")
    setPurpose(tTran "drawing")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Translate transforms to 
    ; their proper position
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    translate(brTran list(0.5*getWidth(mbc)+14.5 0.0))
    translate(dTran list(0.5*getWidth(mbc)+10.5 0.0))
    translate(tTran list(0.5*getWidth(mbc)+20.5 0.0))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Geometry Group
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    geomGroup = makeInstance('geometry)
    addTransform(geomGroup bTran)
    addTransform(geomGroup brTran)
    addTransform(geomGroup dTran )
    addTransform(geomGroup tTran )
    rectTranUnion(geomGroup)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Complete this assembly 
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    addGeometry(mbc geomGroup)
    rtsAdd(mbc->rtrans getRectTran(geomGroup))
    rtsUnion(mbc->rtrans)
  );let
);defmethod
;######################################################
;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; memsCapTopCont.ils: Top plate connnection to mems cap 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( memsCapTopCont (assembly)
	  (
		( width @reader getWidth @writer setWidth )
		( length @reader getLength @writer setLength )
		( centroid @reader getCentroid @writer setCentroid )			
	  )				  
);defclass
;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj memsCapTopCont)) 
	   obj->width  = 100.0
           obj->length = 100.0
	   obj->centroid = makeInstance( 'point2 )
);defmethod
;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( mtc memsCapTopCont ))
  let((bot botCon dstp thk btran brTran dTran tTran ttwidth)	
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Top plate connection
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    top = makeInstance( 'rectangle )
    setWidth(top mtc->width)
    setHeight(top mtc->length)
    generate(top)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Top plate tab 
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ttwidth = 35.0
    topTab = makeInstance( 'rectangle )
    setWidth(topTab ttwidth)
    setHeight(topTab 146.0)
    generate(topTab)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Thick connection
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    thkwidth = 18.0
    thk = makeInstance( 'rectangle )
    setWidth(thk thkwidth)
    setHeight(thk 150.0)
    generate(thk)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Dielectric Post
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    dwidth = 9.0
    diel = makeInstance( 'rectangle )
    setWidth(diel dwidth)
    setHeight(diel 142.0)
    generate(diel)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Top Plate Connection Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    tTran = makeInstance( 'transform2 )
    setVertices(tTran getVertices(top))
    setCentroid(tTran getCentroid(top))
    cloneRectTran(tTran)
    setLayer(tTran "membrane")
    setPurpose(tTran "drawing")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Top Tab Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ttTran = makeInstance( 'transform2 )
    setVertices(ttTran getVertices(topTab))
    setCentroid(ttTran getCentroid(topTab))
    cloneRectTran(ttTran)
    setLayer(ttTran "membrane")
    setPurpose(ttTran "drawing")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Thick Attach Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    thkTran = makeInstance( 'transform2 )
    setVertices(thkTran getVertices(thk))
    setCentroid(thkTran getCentroid(thk))
    cloneRectTran(thkTran)
    setLayer(thkTran "thick")
    setPurpose(thkTran "drawing")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Dielectric Post Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    dTran = makeInstance( 'transform2 )
    setVertices(dTran getVertices(diel))
    setCentroid(dTran getCentroid(diel))
    cloneRectTran(dTran)
    setLayer(dTran "spacer_via")
    setPurpose(dTran "drawing")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Translate transforms to 
    ; their proper position
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    translate(ttTran list(-0.5*getWidth(mtc)-ttwidth/2.0 0.0))
    translate(thkTran list(-0.5*getWidth(mtc)-thkwidth/2.0-19.0 0.0))
    translate(dTran list(-0.5*getWidth(mtc)-dwidth/2.0-24.0 0.0))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Geometry Group
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    geomGroup = makeInstance('geometry)
    addTransform(geomGroup tTran)
    addTransform(geomGroup ttTran)
    addTransform(geomGroup thkTran )
    addTransform(geomGroup dTran )
    rectTranUnion(geomGroup)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Complete this assembly 
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    addGeometry(mtc geomGroup)
    rtsAdd(mtc->rtrans getRectTran(geomGroup))
    rtsUnion(mtc->rtrans)
  );let
);defmethod
;######################################################
;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; cframe.ils: Chip/Reticle frame with specilized corners  
; FIXME: This cornered frame has limitations. The radius is defined via 
;        the the frame edgewidth. For edgewidths larger than TBD (~500um) 
;        the number of on grid, rounded corner points exceeds the Cadence
;        rendering maximum of 2048. The problem is that the circle class
;        needs to detect when a circle class polygon is greater than 2048,
;        and then create a collection of arcs that have points less than 2048.
;        This collection needs to be rendered, and then a post rendering merge
;        conducted within Cadence to form the large circumference radial 
;        geometry.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( cframe (assembly)
	  (
		( width @reader getWidth @writer setWidth )
		( height @reader getHeight @writer setHeight )
		( edgeWidth @reader getEdgeWidth @writer setEdgeWidth )
		( rounded @reader getRounded @writer setRounded )		
		( layer @reader getLayer @writer setLayer )
	  	( purpose @reader getPurpose @writer setPurpose )
		( centroid @reader getCentroid @writer setCentroid )			
	  )				  
);defclass
;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj cframe)) 
	   obj->width     = 10000.0
           obj->height    = 10000.0	   
	   obj->edgeWidth = 100.0
	   obj->rounded = 't
	   obj->layer = "text"
	   obj->purpose = "drawing"
	   obj->centroid = makeInstance( 'point2 )
);defmethod
;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( cfr cframe ))
  let((wid hgt ewid mwid mhgt bot top left right lTran
       rTran bTran tTran uro ulo llo lro medg grid
       uri uli lli lri uroTran uloTran lloTran lroTran
       uriTran uliTran lliTran lriTran)
    wid = cfr->width 
    hgt = cfr->height
    ewid = cfr->edgeWidth
    medg = 20.0
    mwid = 2*ewid
    mhgt = mwid
    grid = 0.1
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Minimum and clamp checks
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; edge
    if(ewid < medg then
      ewid = medg
    );if
    ; width
    if(wid < mwid then
      wid = mwid
    );if
    ; height
    if(hgt < mhgt then
      hgt = mhgt
    );if
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Bottom
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    bot = makeInstance( 'rectangle )
    setWidth(bot wid-2*ewid+2*grid)
    setHeight(bot ewid)
    generate(bot)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Top
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    top = makeInstance( 'rectangle )
    setWidth(top wid-2*ewid+2*grid)
    setHeight(top ewid)
    generate(top)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Left
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    left = makeInstance( 'rectangle )
    setWidth(left ewid)
    setHeight(left hgt-2*ewid+2*grid)
    generate(left)
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Right
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    right = makeInstance( 'rectangle )
    setWidth(right ewid)
    setHeight(right hgt-2*ewid+2*grid)
    generate(right)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UR Outside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uro = makeInstance( 'circle )
    setRadius(uro ewid)
    setGrid(uro 0.1)
    generateQuarterCircle(uro)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UL Outside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ulo = makeInstance( 'circle )
    setRadius(ulo ewid)
    setGrid(ulo 0.1)
    generateQuarterCircle(ulo)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Outside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lro = makeInstance( 'circle )
    setRadius(lro ewid)
    setGrid(lro 0.1)
    generateQuarterCircle(lro)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Outside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    llo = makeInstance( 'circle )
    setRadius(llo ewid)
    setGrid(llo 0.1)
    generateQuarterCircle(llo)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UR Inside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uri = makeInstance( 'circle )
    setRadius(uri ewid)
    setGrid(uri 0.1)
    generateQuarterCircleInv(uri)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UL Inside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uli = makeInstance( 'circle )
    setRadius(uli ewid)
    setGrid(uli 0.1)
    generateQuarterCircleInv(uli)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Inside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lri = makeInstance( 'circle )
    setRadius(lri ewid)
    setGrid(lri 0.1)
    generateQuarterCircleInv(lri)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LL Inside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lli = makeInstance( 'circle )
    setRadius(lli ewid)
    setGrid(lli 0.1)
    generateQuarterCircleInv(lli)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Bottom transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    bTran = makeInstance( 'transform2 )
    setVertices(bTran getVertices(bot))
    setCentroid(bTran getCentroid(bot))
    cloneRectTran(bTran)
    setLayer(bTran getLayer(cfr))
    setPurpose(bTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Top transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    tTran = makeInstance( 'transform2 )
    setVertices(tTran getVertices(top))
    setCentroid(tTran getCentroid(top))
    cloneRectTran(tTran)
    setLayer(tTran getLayer(cfr))
    setPurpose(tTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Left transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lTran = makeInstance( 'transform2 )
    setVertices(lTran getVertices(left))
    setCentroid(lTran getCentroid(left))
    cloneRectTran(lTran)
    setLayer(lTran getLayer(cfr))
    setPurpose(lTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Right transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    rTran = makeInstance( 'transform2 )
    setVertices(rTran getVertices(right))
    setCentroid(rTran getCentroid(right))
    cloneRectTran(rTran)
    setLayer(rTran getLayer(cfr))
    setPurpose(rTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UR Outside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uroTran = makeInstance( 'transform2 )
    setVertices(uroTran getVertices(uro))
    setCentroid(uroTran getCentroid(uro))
    cloneRectTran(uroTran)
    setLayer(uroTran getLayer(cfr))
    setPurpose(uroTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UL Outside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uloTran = makeInstance( 'transform2 )
    setVertices(uloTran getVertices(ulo))
    setCentroid(uloTran getCentroid(ulo))
    cloneRectTran(uloTran)
    setLayer(uloTran getLayer(cfr))
    setPurpose(uloTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Outside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lroTran = makeInstance( 'transform2 )
    setVertices(lroTran getVertices(lro))
    setCentroid(lroTran getCentroid(lro))
    cloneRectTran(lroTran)
    setLayer(lroTran getLayer(cfr))
    setPurpose(lroTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LL Outside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lloTran = makeInstance( 'transform2 )
    setVertices(lloTran getVertices(llo))
    setCentroid(lloTran getCentroid(llo))
    cloneRectTran(lloTran)
    setLayer(lloTran getLayer(cfr))
    setPurpose(lloTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UR Inside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uriTran = makeInstance( 'transform2 )
    setVertices(uriTran getVertices(uri))
    setCentroid(uriTran getCentroid(uri))
    cloneRectTran(uriTran)
    setLayer(uriTran getLayer(cfr))
    setPurpose(uriTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UL Inside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uliTran = makeInstance( 'transform2 )
    setVertices(uliTran getVertices(uli))
    setCentroid(uliTran getCentroid(uli))
    cloneRectTran(uliTran)
    setLayer(uliTran getLayer(cfr))
    setPurpose(uliTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Inside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lriTran = makeInstance( 'transform2 )
    setVertices(lriTran getVertices(lri))
    setCentroid(lriTran getCentroid(lri))
    cloneRectTran(lriTran)
    setLayer(lriTran getLayer(cfr))
    setPurpose(lriTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LL Inside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lliTran = makeInstance( 'transform2 )
    setVertices(lliTran getVertices(lli))
    setCentroid(lliTran getCentroid(lli))
    cloneRectTran(lliTran)
    setLayer(lliTran getLayer(cfr))
    setPurpose(lliTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
    ; Translate Frame Edges to correct positions
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    translate(bTran list(0.0 hgt/2.0-ewid/2.0))
    translate(tTran list(0.0 -hgt/2.0+ewid/2.0))
    translate(lTran list(-wid/2.0+ewid/2.0 0.0))
    translate(rTran list(wid/2.0-ewid/2.0 0.0))
    translate(uroTran list(wid/2.0-ewid hgt/2.0-ewid))
    rotate(uloTran 90.0)
    translate(uloTran list(-wid/2.0+ewid hgt/2.0-ewid))
    rotate(lroTran -90.0)
    translate(lroTran list(wid/2.0-ewid -hgt/2.0+ewid))
    rotate(lloTran 180.0)
    translate(lloTran list(-wid/2.0+ewid -hgt/2.0+ewid))
    translate(uriTran list(wid/2.0-2*ewid hgt/2.0-2.0*ewid))
    rotate(uliTran 90.0)
    translate(uliTran list(-wid/2.0+2*ewid hgt/2.0-2.0*ewid))    
    rotate(lriTran -90.0)
    translate(lriTran list(wid/2.0-2*ewid -hgt/2.0+2.0*ewid))  
    rotate(lliTran 180.0)
    translate(lliTran list(-wid/2.0+2*ewid -hgt/2.0+2.0*ewid))   
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Geometry Group
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    geomGroup = makeInstance('geometry)
    addTransform(geomGroup bTran)
    addTransform(geomGroup tTran)
    addTransform(geomGroup lTran)
    addTransform(geomGroup rTran)
    addTransform(geomGroup uroTran)
    addTransform(geomGroup uloTran)
    addTransform(geomGroup lroTran)
    addTransform(geomGroup lloTran)
    addTransform(geomGroup uriTran)
    addTransform(geomGroup uliTran)
    addTransform(geomGroup lriTran)
    addTransform(geomGroup lliTran)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; this assembly
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    addGeometry(cfr geomGroup)
    rtsAdd(cfr->rtrans getRectTran(geomGroup))
    ;rtsUnion(cfr->rtrans)
  );let
);defmethod
;###################################################################
;###################################################################
;###################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; cframe2.ils: Chip/Reticle frame with specilized corners. This version has
;              corner dimensions controlled by a radius member.
; FIXME: This cornered frame has limitations. The radius is defined via 
;        the the frame edgewidth. For edgewidths larger than TBD (~500um) 
;        the number of on grid, rounded corner points exceeds the Cadence
;        rendering maximum of 2048. The problem is that the circle class
;        needs to detect when a circle class polygon is greater than 2048,
;        and then create a collection of arcs that have points less than 2048.
;        This collection needs to be rendered, and then a post rendering merge
;        conducted within Cadence to form the large circumference radial 
;        geometry.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( cframe2 (assembly)
	  (
		( width @reader getWidth @writer setWidth )
		( height @reader getHeight @writer setHeight )
		( edgeWidth @reader getEdgeWidth @writer setEdgeWidth )
		( rounded @reader getRounded @writer setRounded )
		( radius @reader getRadius @writer setRadius )
		( plate  @reader getPlate @writer setPlate )		
		( layer @reader getLayer @writer setLayer )
	  	( purpose @reader getPurpose @writer setPurpose )
		( centroid @reader getCentroid @writer setCentroid )			
	  )				  
);defclass
;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj cframe2)) 
	   obj->width     = 10000.0
           obj->height    = 10000.0	   
	   obj->edgeWidth = 500.0
	   obj->rounded = 't
	   obj->radius = 100.0
	   obj->plate = nil
	   obj->layer = "text"
	   obj->purpose = "drawing"
	   obj->centroid = makeInstance( 'point2 )
);defmethod
;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( cfr cframe2 ))
  let((plt wid hgt ewid mwid mhgt mrad radius ibot itop ileft iright 
       obot otop oleft oright ilTran irTran ibTran itTran 
       olTran orTran obTran otTran uro ulo llo lro medg grid
       owid uri uli lli lri uroTran uloTran lloTran lroTran
       uriTran uliTran lliTran lriTran pTran)
    wid = cfr->width 
    hgt = cfr->height
    ewid = cfr->edgeWidth
    radius = cfr->radius
    mrad = 5.0
    medg = 20.0
    mwid = 2*ewid
    mhgt = mwid
    grid = 0.1
    owid = ewid-radius
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Minimum and clamp checks (Guard Rails)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; radiux
    if(radius < mrad then
      radius = mrad
    );if
    ; edge
    if(ewid < medg then
      ewid = medg
    );if
    ; width
    if(wid < mwid then
      wid = mwid
    );if
    ; height
    if(hgt < mhgt then
      hgt = mhgt
    );if
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Plate
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    plt = makeInstance( 'rectangle )
    setWidth(plt wid-radius)
    setHeight(plt hgt-radius)
    generate(plt)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Inner Bottom
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ibot = makeInstance( 'rectangle )
    setWidth(ibot wid-2.0*radius)
    setHeight(ibot owid)
    generate(ibot)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Inner Top
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    itop = makeInstance( 'rectangle )
    setWidth(itop wid-2.0*radius)
    setHeight(itop owid)
    generate(itop)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Inner Left
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ileft = makeInstance( 'rectangle )
    setWidth(ileft owid)
    setHeight(ileft hgt-2.0*radius)
    generate(ileft)
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Inner Right
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    iright = makeInstance( 'rectangle )
    setWidth(iright owid)
    setHeight(iright hgt-2.0*radius)
    generate(iright)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Outter Bottom
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    obot = makeInstance( 'rectangle )
    setWidth(obot wid-2*radius)
    setHeight(obot radius)
    generate(obot)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Outter Top
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    otop = makeInstance( 'rectangle )
    setWidth(otop wid-2*radius)
    setHeight(otop radius)
    generate(otop)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Outter Left
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    oleft = makeInstance( 'rectangle )
    setWidth(oleft radius)
    setHeight(oleft hgt-2*radius)
    generate(oleft)
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Outter Right
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    oright = makeInstance( 'rectangle )
    setWidth(oright radius)
    setHeight(oright hgt-2*radius)
    generate(oright)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UR Outside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uro = makeInstance( 'circle )
    setRadius(uro radius)
    setGrid(uro grid)
    generateQuarterCircle(uro)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UL Outside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ulo = makeInstance( 'circle )
    setRadius(ulo radius)
    setGrid(ulo grid)
    generateQuarterCircle(ulo)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Outside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lro = makeInstance( 'circle )
    setRadius(lro radius)
    setGrid(lro grid)
    generateQuarterCircle(lro)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Outside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    llo = makeInstance( 'circle )
    setRadius(llo radius)
    setGrid(llo grid)
    generateQuarterCircle(llo)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UR Inside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uri = makeInstance( 'circle )
    setRadius(uri radius)
    setGrid(uri grid)
    generateQuarterCircleInv(uri)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UL Inside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uli = makeInstance( 'circle )
    setRadius(uli radius)
    setGrid(uli grid)
    generateQuarterCircleInv(uli)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Inside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lri = makeInstance( 'circle )
    setRadius(lri radius)
    setGrid(lri grid)
    generateQuarterCircleInv(lri)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LL Inside Corner
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lli = makeInstance( 'circle )
    setRadius(lli radius)
    setGrid(lli grid)
    generateQuarterCircleInv(lli)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Plate transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    pTran = makeInstance( 'transform2 )
    setVertices(pTran getVertices(plt))
    setCentroid(pTran getCentroid(plt))
    cloneRectTran(pTran)
    setLayer(pTran getLayer(cfr))
    setPurpose(pTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Inner Bottom transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ibTran = makeInstance( 'transform2 )
    setVertices(ibTran getVertices(ibot))
    setCentroid(ibTran getCentroid(ibot))
    cloneRectTran(ibTran)
    setLayer(ibTran getLayer(cfr))
    setPurpose(ibTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Inner Top transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    itTran = makeInstance( 'transform2 )
    setVertices(itTran getVertices(itop))
    setCentroid(itTran getCentroid(itop))
    cloneRectTran(itTran)
    setLayer(itTran getLayer(cfr))
    setPurpose(itTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Inner Left transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ilTran = makeInstance( 'transform2 )
    setVertices(ilTran getVertices(ileft))
    setCentroid(ilTran getCentroid(ileft))
    cloneRectTran(ilTran)
    setLayer(ilTran getLayer(cfr))
    setPurpose(ilTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Inner Right transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    irTran = makeInstance( 'transform2 )
    setVertices(irTran getVertices(iright))
    setCentroid(irTran getCentroid(iright))
    cloneRectTran(irTran)
    setLayer(irTran getLayer(cfr))
    setPurpose(irTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Outter Bottom transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    obTran = makeInstance( 'transform2 )
    setVertices(obTran getVertices(obot))
    setCentroid(obTran getCentroid(obot))
    cloneRectTran(obTran)
    setLayer(obTran getLayer(cfr))
    setPurpose(obTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Outter Top transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    otTran = makeInstance( 'transform2 )
    setVertices(otTran getVertices(otop))
    setCentroid(otTran getCentroid(otop))
    cloneRectTran(otTran)
    setLayer(otTran getLayer(cfr))
    setPurpose(otTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Outter Left transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    olTran = makeInstance( 'transform2 )
    setVertices(olTran getVertices(oleft))
    setCentroid(olTran getCentroid(oleft))
    cloneRectTran(olTran)
    setLayer(olTran getLayer(cfr))
    setPurpose(olTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Outter Right transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    orTran = makeInstance( 'transform2 )
    setVertices(orTran getVertices(oright))
    setCentroid(orTran getCentroid(oright))
    cloneRectTran(orTran)
    setLayer(orTran getLayer(cfr))
    setPurpose(orTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UR Outside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uroTran = makeInstance( 'transform2 )
    setVertices(uroTran getVertices(uro))
    setCentroid(uroTran getCentroid(uro))
    cloneRectTran(uroTran)
    setLayer(uroTran getLayer(cfr))
    setPurpose(uroTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UL Outside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uloTran = makeInstance( 'transform2 )
    setVertices(uloTran getVertices(ulo))
    setCentroid(uloTran getCentroid(ulo))
    cloneRectTran(uloTran)
    setLayer(uloTran getLayer(cfr))
    setPurpose(uloTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Outside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lroTran = makeInstance( 'transform2 )
    setVertices(lroTran getVertices(lro))
    setCentroid(lroTran getCentroid(lro))
    cloneRectTran(lroTran)
    setLayer(lroTran getLayer(cfr))
    setPurpose(lroTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LL Outside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lloTran = makeInstance( 'transform2 )
    setVertices(lloTran getVertices(llo))
    setCentroid(lloTran getCentroid(llo))
    cloneRectTran(lloTran)
    setLayer(lloTran getLayer(cfr))
    setPurpose(lloTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UR Inside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uriTran = makeInstance( 'transform2 )
    setVertices(uriTran getVertices(uri))
    setCentroid(uriTran getCentroid(uri))
    cloneRectTran(uriTran)
    setLayer(uriTran getLayer(cfr))
    setPurpose(uriTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; UL Inside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    uliTran = makeInstance( 'transform2 )
    setVertices(uliTran getVertices(uli))
    setCentroid(uliTran getCentroid(uli))
    cloneRectTran(uliTran)
    setLayer(uliTran getLayer(cfr))
    setPurpose(uliTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LR Inside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lriTran = makeInstance( 'transform2 )
    setVertices(lriTran getVertices(lri))
    setCentroid(lriTran getCentroid(lri))
    cloneRectTran(lriTran)
    setLayer(lriTran getLayer(cfr))
    setPurpose(lriTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; LL Inside Corner Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    lliTran = makeInstance( 'transform2 )
    setVertices(lliTran getVertices(lli))
    setCentroid(lliTran getCentroid(lli))
    cloneRectTran(lliTran)
    setLayer(lliTran getLayer(cfr))
    setPurpose(lliTran getPurpose(cfr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
    ; Translate Frame Edges to correct positions
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    translate(ibTran list(0.0 -hgt/2.0+owid/2.0+radius))
    translate(itTran list(0.0  hgt/2.0-owid/2.0-radius))
    translate(ilTran list(-wid/2.0+owid/2.0+radius 0.0))
    translate(irTran list( wid/2.0-owid/2.0-radius 0.0))
    translate(obTran list(0.0 -hgt/2.0+radius/2.0))
    translate(otTran list(0.0 hgt/2.0-radius/2.0))
    translate(olTran list(-wid/2.0+radius/2.0 0.0))
    translate(orTran list(wid/2.0-radius/2.0 0.0))
    translate(uroTran list(wid/2.0-radius hgt/2.0-radius))
    rotate(uloTran 90.0)
    translate(uloTran list(-wid/2.0+radius hgt/2.0-radius))
    rotate(lroTran -90.0)
    translate(lroTran list(wid/2.0-radius -hgt/2.0+radius))
    rotate(lloTran 180.0)
    translate(lloTran list(-wid/2.0+radius -hgt/2.0+radius))
    translate(uriTran list(wid/2.0-ewid-radius hgt/2.0-ewid-radius))
    rotate(uliTran 90.0)
    translate(uliTran list(-wid/2.0+ewid+radius hgt/2.0-ewid-radius)) 
    rotate(lriTran -90.0)  
    translate(lriTran list(wid/2.0-ewid-radius -hgt/2.0+ewid+radius)) 
    rotate(lliTran 180.0)
    translate(lliTran list(-wid/2.0+ewid+radius -hgt/2.0+ewid+radius))  
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Frame Geometry Group
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    geomGroup = makeInstance('geometry)
    addTransform(geomGroup obTran)
    addTransform(geomGroup otTran)
    addTransform(geomGroup olTran)
    addTransform(geomGroup orTran)
    addTransform(geomGroup uroTran)
    addTransform(geomGroup uloTran)
    addTransform(geomGroup lroTran)
    addTransform(geomGroup lloTran)
    if(cfr->plate then
      addTransform(geomGroup pTran)
    else
      addTransform(geomGroup ibTran)
      addTransform(geomGroup itTran)
      addTransform(geomGroup ilTran)
      addTransform(geomGroup irTran)
      addTransform(geomGroup uriTran)
      addTransform(geomGroup uliTran)
      addTransform(geomGroup lriTran)
      addTransform(geomGroup lliTran)
    );if
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; this assembly
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    addGeometry(cfr geomGroup)
    rtsAdd(cfr->rtrans getRectTran(geomGroup))
    ;rtsUnion(cfr->rtrans)
  );let
);defmethod
;###################################################################
;###################################################################
;###################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; sdArray.ils: Source/Drain Array for FETs 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( sdArray (assembly)
  (
    ( m @reader getM @writer setM )
    ( width @reader getWidth @writer setWidth )
    ( length @reader getLength @writer setLength )
    ( spacing @reader getSpacing @writer setSpacing )
    ( layer @reader getLayer @writer setLayer )
    ( purpose @reader getPurpose @writer setPurpose )
    ( sourceOrig @reader getSourceOrig @writer setSourceOrig )
    ( refRect )
    ( sTrans )
    ( dTrans )			
  )				  
);defclass
;######################################################
; Constructor
;######################################################
defmethod( initializeInstance @after ((obj sdArray)) 
	   obj->m          = 1
	   obj->width      = 100.0
           obj->length     =  50.0
	   obj->spacing    =  50.0 
	   obj->layer      = "text"
	   obj->purpose    = "drawing"
	   obj->sourceOrig =  makeInstance( 'point2 )
	   obj->refRect    = makeInstance( 'rectangle )
	   obj->sTrans     = makeInstance( 'collection )
	   obj->dTrans     = makeInstance( 'collection )
);defmethod
;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( array sdArray ))
  let(( m r2r do tran snum dnum)
    m = getM(array)	
    if(evenp(array->m) then
      snum = m-(m/2-1)
      dnum = m/2
    else
      snum = m - m/2
      dnum = snum
    );if
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Dimension Calculations
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    r2r = 2*(array->length + array->spacing)
    do  = array->length + array->spacing
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create Geometry Group
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    geomGroup = makeInstance('geometry)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; FIXME: Initially generate EVEN only finger structure
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create the reference source
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    setWidth(array->refRect array->width)
    setHeight(array->refRect array->length)
    generate(array->refRect)
    ;tran = makeInstance( 'transform2 )
    ;setVertices(tran getVertices(array->refRect))
    ;setCentroid(tran getCentroid(array->refRect))
    ;cloneRectTran(tran)
    ;setLayer(tran getLayer(array))
    ;setPurpose(tran getPurpose(array))
    ;addTransform(geomGroup tran) 
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Generate all sources
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    for( i 0 sub1(snum)
       tran = makeInstance( 'transform2 )
       setVertices(tran getVertices(array->refRect))
       setCentroid(tran getCentroid(array->refRect))
       cloneRectTran(tran)
       setLayer(tran getLayer(array))
       setPurpose(tran getPurpose(array))
       translate(tran list(0.0 i*r2r))
       addTransform(geomGroup tran)
    );for
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Generate all drains
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    for( i 0 sub1(dnum)
       tran = makeInstance( 'transform2 )
       setVertices(tran getVertices(array->refRect))
       setCentroid(tran getCentroid(array->refRect))
       cloneRectTran(tran)
       setLayer(tran "electrode")
       setPurpose(tran getPurpose(array))
       translate(tran list(0.0 i*r2r+do))
       addTransform(geomGroup tran)
    );for
    rectTranUnion(geomGroup)
    addGeometry(array geomGroup)
    rtsAdd(array->rtrans getRectTran(geomGroup))
    rtsUnion(array->rtrans)
  );let
);defmethod
;######################################################
;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ab.ils: Air bridge assembly
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( ab (assembly)
	  (
		( width @reader getWidth @writer setWidth )
		( length @reader getLength @writer setLength )
		( minWidth @reader getMinWidth @writer setMinWidth )
		( minLength @reader getMinLength @writer setMinLength )
		( termLen @reader getTermLen @writer setTermLen )
		( termEnc @reader getTermEnc @writer setTermEnc )
		( bodyLayer @reader getBodyLayer @writer setBodyLayer )
	  	( bodyPurpose @reader getBodyPurpose @writer setBodyPurpose )
		( pillowLayer @reader getPillowLayer @writer setPillowLayer )
	  	( pillowPurpose @reader getPillowPurpose @writer setPillowPurpose )
		( pext @reader getPext @writer setPext )
		( contLayer @reader getContLayer @writer setContLayer )
	  	( contPurpose @reader getContPurpose @writer setContPurpose )
		( centroid @reader getCentroid @writer setCentroid )			
	  )				  
);defclass
;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj ab)) 
	   obj->width         = 1.0
           obj->length        = 1.0
	   obj->minWidth      = 0.5
	   obj->minLength     = 0.5
	   obj->termEnc       = 0.5
	   obj->termLen       = 1.0
	   obj->pext          = 20.0
	   obj->bodyLayer     = "text"
	   obj->bodyPurpose   = "drawing"
	   obj->pillowLayer   = "text"
	   obj->pillowPurpose = "drawing"
	   obj->contLayer     = "text"
	   obj->contPurpose   = "drawing"
	   obj->centroid      = makeInstance( 'point2 )
);defmethod
;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( abr ab ))
  let((termWid termLen bodyLen cptrn cntrn body pillow cont bTran 
       pConTran nConTran pTran cv)	
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Dimension Calculations
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    termWid = abr->width+2.0*abr->termEnc
    termLen = abr->termLen+abr->termEnc
    bodyLen = abr->length+2*abr->termLen 
    ; Air Bridge contact transformation
    cptrn = -1.0*(abr->termLen+abr->termEnc+abr->length)/2.0
    cntrn = -1.0*cptrn
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Formal Parameters
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    pext = 10.0
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create the bridge strip
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    body = makeInstance( 'rectangle )
    setWidth(body bodyLen)
    setHeight(body abr->width)
    generate(body)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create the bridge "pillow"
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    pillow = makeInstance( 'rectangle )
    setWidth(pillow bodyLen-2*abr->termLen)
    setHeight(pillow abr->width+abr->pext)
    generate(pillow)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Create the end contacts
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    cont = makeInstance( 'rectangle )
    setWidth(cont termLen)
    setHeight(cont termWid)
    generate(cont)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Bridge Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    bTran = makeInstance( 'transform2 )
    setVertices(bTran getVertices(body))
    setCentroid(bTran getCentroid(body))
    cloneRectTran(bTran)
    setLayer(bTran getBodyLayer(abr))
    setPurpose(bTran getBodyPurpose(abr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Pillow Transform
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    pTran = makeInstance( 'transform2 )
    setVertices(pTran getVertices(pillow))
    setCentroid(pTran getCentroid(pillow))
    cloneRectTran(pTran)
    setLayer(pTran getPillowLayer(abr))
    setPurpose(pTran getPillowPurpose(abr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Bridge Footing Transform A
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    pConTran = makeInstance( 'transform2 )
    setVertices(pConTran getVertices(cont))
    setCentroid(pConTran getCentroid(cont))
    cloneRectTran(pConTran)
    setLayer(pConTran getContLayer(abr))
    setPurpose(pConTran getContPurpose(abr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Bridge Footing Transform B
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    nConTran = makeInstance( 'transform2 )
    setVertices(nConTran getVertices(cont))
    setCentroid(nConTran getCentroid(cont))
    cloneRectTran(nConTran)
    setLayer(nConTran getContLayer(abr))
    setPurpose(nConTran getContPurpose(abr))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Translate the Bridge Footings to 
    ; their proper position
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    translate(pConTran list(cptrn 0))
    translate(nConTran list(cntrn 0))
    ; Add the transforms to a geometry
    ; group
    geomGroup = makeInstance('geometry)
    addTransform(geomGroup bTran)
    addTransform(geomGroup pTran)
    addTransform(geomGroup pConTran)
    addTransform(geomGroup nConTran )
    rectTranUnion(geomGroup)
    addGeometry(abr geomGroup)
    rtsAdd(abr->rtrans getRectTran(geomGroup))
    rtsUnion(abr->rtrans)
  );let
);defmethod
;######################################################
;######################################################
;######################################################
;######################################################
;######################################################
; ganGate.ils: GaN fet gate class. Inherits from 
;              component class
;######################################################
defclass( ganGate (component)
  (
    ( width  @reader getWidth @writer setWidth )
    ( length @reader getLength @writer setLength )
    ( stem )
    ( pad )
    ( centroid )
    ( ref @reader getRef @writer setRef )
    ( rtrans )
    ( coreBBox @initarg coreBBox )
  ) 				  
);defclass
;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj ganGate)) 
  obj->width = 100.0
  obj->length = 0.5
  obj->stem = makeInstance( 'gateStem )
  obj->pad = makeInstance( 'gatePad )
  obj->centroid = makeInstance('point2)
  obj->rtrans = makeInstance('rectTrans)
);defmethod
;######################################################
; Draws the gate
;######################################################
defmethod( generate (( gt ganGate ))
  let( (width length stemRectTran padRectTran)
    width = getWidth(gt)
    length = getLength(gt)
    setWidthInner(gt->pad 13.5)
    setHeightInner(gt->pad 4.0)
    setWidthOutter(gt->pad 13.5)
    setHeightOutter(gt->pad 5.6)
    setInnerLayer(gt->pad "resistor")
    setOutterLayer(gt->pad "membrane")
    setBsegLayer(gt->pad "thick")
    setRef(gt->pad getRef(gt))
    generate(gt->pad)
    addAssembly(gt gt->pad)
    setWidth(gt->stem width)
    setLength(gt->stem length)
    setWidthTaper(gt->stem 2.5)
    setLayer(gt->stem "membrane")
    setRef(gt->stem getRef(gt))
    generate(gt->stem)
    addAssembly(gt gt->stem)
    stemRectTran = getRectTran(gt->stem)
    padRectTran = getRectTran(gt->pad)
    rtsAdd(gt->rtrans stemRectTran) 
    rtsAdd(gt->rtrans padRectTran)
    rtsUnion(gt->rtrans)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;######################################################
; fetBody.ils: FET body class. Inherits from 
;              component class. Container class for
;              assemblies
;######################################################
defclass( fetBody (component)
  (
    ( m       @reader getM       @writer setM )
    ( width   @reader getWidth   @writer setWidth )
    ( length  @reader getLength  @writer setLength )
    ( spacing @reader getSpacing @writer setSpacing )
    ( centroid )
    ( rtrans )
  ) 				  
);defclass
;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj fetBody))
  obj->m        = 1 
  obj->width    = 100.0
  obj->length   = 50.0
  obj->spacing  = 50.0
  obj->centroid = makeInstance('point2)
  obj->rtrans   = makeInstance('rectTrans)
);defmethod
;######################################################
; Draws the gate
;######################################################
defmethod( generate (( fb fetBody ))
  let( (width length sd )
    width = getWidth(fb)
    length = getLength(fb)
    sd = makeInstance( 'sdArray )
    setM(sd getM(fb))
    setWidth(sd width)
    setLength(sd length)
    setSpacing(sd getSpacing(fb))
    generate(sd)
    rectTran = getRectTran(sd->rtrans)
    rtsAdd(fb->rtrans rectTran) 
    rtsUnion(fb->rtrans)
    addAssembly(fb sd)
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;######################################################
; sodBridgeArray.ils: Array of air bridges which connect
;                     the sources of a FET forming a SOD
;                     structure. Inherits from 
;                     component class. Container class for
;                     assemblies
;######################################################
defclass( sodBridgeArray (component)
  (
    ( m       @reader getM       @writer setM )
    ( width   @reader getWidth   @writer setWidth )
    ( length  @reader getLength  @writer setLength )
    ( spacing @reader getSpacing @writer setSpacing )
    ( centroid )
    ( rtrans )
  ) 				  
);defclass
;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj sodBridgeArray))
  obj->m        = 1 
  obj->width    = 100.0
  obj->length   = 50.0
  obj->spacing  = 50.0
  obj->centroid = makeInstance('point2)
  obj->rtrans   = makeInstance('rectTrans)
);defmethod
;######################################################
; Draws the gate
;######################################################
defmethod( generate (( ba sodBridgeArray ))
  let( (enc width length m spacing num blen s2s shift so br)
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Formal Params
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    enc = 5.0
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    m = getM(ba)
    if(m > 1 then
      width = getWidth(ba)
      length = getLength(ba)   
      spacing = getSpacing(ba)	
      if(evenp(m) then
        num = m/2
      else
        num = m - m/2
      );if
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; Dimension Calculations
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
      blen = length+2*spacing
      shift  = blen + length
      so   = (blen-length)/2.0
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;m
      ; Generate bridges
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      for( i 0 sub1(num)
        br = makeInstance( 'ab )
        setWidth(br width)
        setLength(br blen)
	setTermLen(br length)
	setTermEnc(br 5.0)
        setBodyLayer(br "thick")
        setPillowLayer(br "dielectric")
        setContLayer(br "electrode")
        setPext(br 25.0)
        generate(br)
	rotate(br 90.0)
        translate(br list(0.0 i*shift+so))
        addAssembly(ba br)
      );for
    else
      nil
    );if
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;######################################################
; ganFet.ils: GaN FET Structure. Inherits from structure
;             class which is an aggregate component class.
;######################################################
defclass( ganFet (structure)
  (	  
    ( m      @reader getM      @writer setM )
    ( width  @reader getWidth  @writer setWidth)
    ( length @reader getLength @writer setLength )
    ( centroid @reader getCentroid @writer setCentroid )
    ( ref @reader getRef @writer setRef )
    ( rtrans )
    ( coreBBox @initarg coreBBox )
  ) 				  
);defclass
;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj ganFet)) 
  obj->m = 2
  obj->width = 100.0
  obj->length = 0.2
  obj->centroid = makeInstance('point2)
  obj->rtrans = makeInstance('rectTrans)
);defmethod
;######################################################
; Draws the gate
;######################################################
defmethod( generate (( gf ganFet ))
  let( (m gateWidth extension gateLength sdLength sdSpacing 
       xtran ytran fb gate rtran gdSpacing gSdSpacing sod
       aba)
    sod = nil
    sdLength   = 25.0
    sdSpacing  = 5.0
    extension  = 5.0
    gdSpacing  = 1.0
    gSdSpacing = 5.0
    m          = getM(gf)
    gateWidth  = getWidth(gf) + extension + gSdSpacing
    gateLength  = getLength(gf)
    fb = makeInstance( 'fetBody )
    setM(fb m)
    setWidth(fb getWidth(gf))
    setLength(fb sdLength)
    setSpacing(fb sdSpacing)
    generate(fb)
    rtran = getRectTran(fb->rtrans)
    rtsAdd(gf->rtrans rtran)
    addComponent(gf fb)
    ytran = sdLength/2.0+sdSpacing-getLength(gf)-gdSpacing
    gtran = sdLength + sdSpacing
    xtran = -10.4 - getWidth(gf)/2.0 - gSdSpacing
    for( i 0 sub1(m)
       println("INFO(ganFet): Generating gate structure")
       gate = makeInstance( 'ganGate )
       setRef(gate getRef(gf))
       setWidth(gate gateWidth)
       setLength(gate gateLength)
       generate(gate)
       translate(gate list(xtran ytran))
       rtran = getRectTran(gate->rtrans)
       rtsAdd(gf->rtrans rtran)
       addComponent(gf gate)
       ytran = ytran + gtran
    );for
    if(sod then
      aba = makeInstance( 'sodBridgeArray )
      setM(aba m)
      setWidth(aba getWidth(gf))
      setLength(aba sdLength)
      setSpacing(aba sdSpacing)
      generate(aba)
      addComponent(gf aba)
    );if
    rtsUnion(gf->rtrans)
    ; No multiple inheritance
    ;callNextMethod()
  );let
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; generic.ils: generic functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Defines the generic function for draw. Redefining a generic function
; removes all methods defined by the previous defgeneric from
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defgeneric( draw (device)
	    t
);defgeneric;#################################################################
; PcellParam.ils: class for pcell parameters
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Defines a base class for the PCELL API with a single slot for 
; holding the PCELL master ID. This PCELL ID is the same as the
; the pcCellView variable using in the a standard SKILL Pcell
;..................................................................
; cvId will hold the pcCellView reference which is set in the 
; extremely important "setPcellParams" method.
; The cvId is the reference to the Pcell Supermaster Cellview
; in the Pcell Libarary
;#################################################################
defclass( PcellParam ()
  (
	(cvId @initarg cvId)
  )
);defclass

;#################################################################
; Transfers the Pcell parameters from the super master cell view to 
; a Pcell API Call device's slots.
;
; Input argument cv is the built in "pcCellView" class object's
; reference . The "pcCellView" is the standard variable, representing
; the PCELL master ID,  used in a standard SKILL++ Pcell.
; 
; NOTE: 
; This important method does the mapping of the desired user
; parameters to the required built in "pcCellView" parameters.
; This ensures that the user defined pcell object code has full access to the
; built in class' parameters (pcCellView). During pcell compilation
; this method is called in order to update (trigger callback) the user pcell 
; code object from the parameterized inputs of the built in pcell object (pcCellView).
; Every time a pcell's parameter is changed, the user pcell is 
; recompiled and executed using the new parameter values of the built 
; in pcell (pcCellView) object. 
;#################################################################
defmethod( setPcellParams ((device PcellParam) cv)
  when( cv && dbIsId(cv)
  	setSlotValue(device 'cvId cv)
	foreach( param cv~>parameters~>value
	  setParamValue(device concat(param~>name) param~>value)
	);foreach
  );when
);defmethod

;#################################################################
; A function to define a Pcell parameter stored as a Pcell class'
; slot. The optional argument _isParam is set to 't to indicate
; this parameter is a Pcell parameter
;#################################################################
defun( defineParam (g_type g_value @optional (_isParam t))
  list(nil 'type g_type 'value g_value 'isParam _isParam)
);defun

;#################################################################
; A method to get Pcell parameter's type
;#################################################################
defmethod( getParamType ((device PcellParam) (propName symbol))
  slotValue(device propName)->type
);defmethod

;#################################################################
; A method to get Pcell parameter's value
;#################################################################
defmethod( getParamValue ((device PcellParam) (propName symbol))
  slotValue(device propName)->value
);defmethod

;#################################################################
; A method to set Pcell parameter's value
;#################################################################
defmethod( setParamValue ((device PcellParam) (propName symbol) val)
  slotValue(device propName)->value = val
);defmethod

;#################################################################
; A method to check if the given name is a Pcell parameter. Based
; upon setting the of the isParam attribute
;#################################################################
defmethod( isParam ((device PcellParam) (propName symbol))
  slotValue(device propName)->isParam
);defmethod

;#################################################################
; A method to to get a list of Pcell parameters with their names,
; types, and values
;#################################################################
defmethod( getPcellParams ((device PcellParam) )
  let((params)
    params = setof(p device->? isParam(device p))
    params = foreach( mapcar p params 
    	              list( p getParamType(device p) getParamValue(device p))
	     );foreach
  );let
);defmethod
;#################################################################
;#################################################################
;#################################################################;############################################################################
; RING.ils: Draws a polygon that wraps around a devices' coreBBox 
;           with a griven spacing value and width of the polygon.
;           Inherits from PcellParam class
;############################################################################
defclass( RING (PcellParam)
  (
	(ringW @initform defineParam("float" 0.1))
	(ringS @initform defineParam("float" 0.1))
  )
);defclass

;#################################################################
; Draw a polygon that wraps around the devices coreBBox with a
; given spacing value and width
;#################################################################
defmethod( draw ((device RING))
  let((cv ringS ringW coreBBox llx lly urx ury pts ring)
    ringS = getParamValue(device 'ringS)
    ringW = getParamValue(device 'ringW)
    coreBBox = getCoreBBox(device)
    llx = xCoord( lowerLeft(coreBBox))
    lly = yCoord( lowerLeft(coreBBox))
    urx = xCoord( upperRight(coreBBox))
    ury = yCoord( upperRight(coreBBox))
    pts = list(
    	llx-ringS:lly-ringS ; points on inner edges
	urx+ringS:lly-ringS
	urx+ringS:ury+ringS
	llx-ringS:ury+ringS
	llx-ringS:lly-ringS-ringW         ; extending to outer edge
	llx-ringS-ringW:lly-ringS-ringW   ; points on outer edges
	llx-ringS-ringW:ury+ringS+ringW   
	urx+ringS+ringW:ury+ringS+ringW
	urx+ringS+ringW:lly-ringS-ringW
	llx-ringS:lly-ringS-ringW
	);list
    ; layer chosen for its color's visibility
    ; you can replace the layer names mentioned here with the layer
    ; name present in your library
    cv = slotValue(device 'cvId)
    ring = dbCreatePolygon(cv list("numbers" "drawing") pts)
    callNextMethod()
    );let
);defmethod

;#################################################################
; This method is called when RING is used on its own
; Returns and empty box
;#################################################################
defmethod(getCoreBBox ((device RING))
  list(0:0 0:0)
);defmethod
;#################################################################
;#################################################################
;#################################################################

;#####################################################################
; CORE.ils: core pcell class inheriting from PcellParam class
; Note: Parameter created via defineParam will be treated as
;       a Pcell parameter; otherwise it is treated as a normal
;       class slot (e.g. coreBBox is not a Pcell parameter)
;#####################################################################
; cyanW: Width of the verticle cross block
; cyanL: Lenth of the verticle cross blcok
; greenW: Width of the verticle cross block
; greenL: Lenth of the verticle cross blcok
;#####################################################################
defclass( CORE (PcellParam)
  (
	( cyanW @initform defineParam("float" 0.6) )
	( cyanL @initform defineParam("float" 0.8) )
	( greenW @initform defineParam("float" 0.2) )
	( greenL @initform defineParam("float" 0.2) )
	( coreBBox @initarg coreBBox )
  )
);defclass

;######################################################################
; Draw a simple cross represented by two rectangles
;######################################################################
defmethod( draw ((device CORE))
  let((cv cyanW cyanL greenW greenL rectId llx lly urx ury)
    cyanW = getParamValue(device 'cyanW)
    cyanL = getParamValue(device, 'cyanL)
    greenW = getParamValue(device, 'greenW)
    greenL = getParamValue(device, 'greenL)
    ; layers are choosen for their color's visibility
    ; you can replace the layer names here with the 
    ; the layer names present in the library
    cv = slotValue(device 'cvId)
    rectId = dbCreateRect(cv list("numbers" "drawing") list(0:0 greenL:greenW))
    llx = 0.5 * greenL - 0.5 * cyanL
    lly = 0.5 * greenW - 0.5 * cyanW
    urx = 0.5 * greenL + 0.5 * cyanL
    ury = 0.5 * greenW + 0.5 * cyanW
    rectId = dbCreateRect(cv list("numbers" "drawing") list(llx:lly urx:ury))
    setSlotValue(device 'coreBBox list( 0.0:lly greenL:ury))
    callNextMethod()
    );let
);defmethod

;######################################################################
; Returns CORE's bounding box which is stored in coreBBox slot
;######################################################################
defmethod( getCoreBBox ((device CORE))
  slotValue(device 'coreBBox)
);defmethod

;#######################################################################
;#######################################################################
;#######################################################################
;#############################################################
; WRAP.ils: Defines a wrapped core class that inherits both
;           CORE and RING classes
;
; Used for testing the Skill++ PCELL API 
;#############################################################
defclass( WRAP (CORE RING)
	  ()
);defclass
;#############################################################
; Draw method for WRAP is just a simple call to callNextMethod()
; Due to the specificity of WRAP's superclasses, the draw
; methods for CORE and RING will be called in this order
;#############################################################
defmethod(draw ((device WRAP))
  callNextMethod()
);defmethod
;#############################################################
;#############################################################
;#############################################################
;######################################################
; gate.ils: fet gate PCELL class. Inherits from PcellParam
;           making it a Cadence PCELL class
;######################################################
defclass( gate (PcellParam)
  (
    ( width  @initform defineParam("float" 50.0) )
    ( length @initform defineParam("float" 0.25) )
    ( stem )
    ( pad )
    ( centroid )
    ( ref @reader getRef @writer setRef )
    ( rtrans )
    ( coreBBox @initarg coreBBox )
  ) 				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj gate)) 
	   obj->stem = makeInstance( 'gateStem )
	   obj->pad = makeInstance( 'gatePad )
	   obj->centroid = makeInstance('point2)
	   obj->rtrans = makeInstance('rectTrans)
);defmethod

;######################################################
; Draws the gate
;######################################################
defmethod( drawGate (( gt gate ))
  let( (width length stemRectTran padRectTran)
    width = getParamValue(gt 'width)
    length = getParamValue(gt 'length)
    setWidthInner(gt->pad 13.5)
    setHeightInner(gt->pad 4.0)
    setWidthOutter(gt->pad 13.5)
    setHeightOutter(gt->pad 5.6)
    setInnerLayer(gt->pad "resistor")
    setOutterLayer(gt->pad "membrane")
    setBsegLayer(gt->pad "thick")
    setRef(gt->pad getRef(gt))
    generate(gt->pad)
    render(gt->pad)
    setWidth(gt->stem width)
    setLength(gt->stem length)
    setWidthTaper(gt->stem 2.5)
    setLayer(gt->stem "membrane")
    setRef(gt->stem getRef(gt))
    generate(gt->stem)
    render(gt->stem)
    stemRectTran = getRectTran(gt->stem)
    padRectTran = getRectTran(gt->pad)
    rtsAdd(gt->rtrans stemRectTran) 
    rtsAdd(gt->rtrans padRectTran)
    rtsUnion(gt->rtrans)
    setSlotValue(gt 'coreBBox list( gt->rtrans->rtran->ll gt->rtrans->rtran->ur))
    ;callNextMethod()
  );let
);defmethod

;######################################################################
; Returns gates's bounding box which is stored in coreBBox slot
;######################################################################
defmethod( getCoreBBox ((gt gate))
  slotValue(gt 'coreBBox)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  list.il: Some extensions to skill list functionality 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( res (PcellParam)
	  (
		( wid @initform defineParam("float" 1.0))	
		( len @initform defineParam("float" 1.0))
		( plRes )
		( centroid )
		( ref @reader getRef @writer setRef )
		( rtrans )
		( coreBBox @initarg coreBBox )	  
	  )
) ; defClass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj res)) 
	   obj->plRes = makeInstance( 'planarResistor )
	   obj->centroid = makeInstance('point2)
	   obj->rtrans = makeInstance('rectTrans)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method draws the shapes of the mesa resistor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( draw ((device res))
  let( (wid len pr resRectTran )
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; Formal Parameters
   wid = getParamValue(device 'wid)
   len = getParamValue(device 'len)
   setWidth(device->plRes wid)
   setLength(device->plRes len)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; FIXME: Get these from TF
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   setMinWidth(device->plRes 1.0)
   setMinLength(device->plRes 1.0)
   setTermLen(device->plRes 1.0)
   setTermEnc(device->plRes 0.5)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   setBodyLayer(device->plRes "resistor")
   setBodyPurpose(device->plRes "drawing")
   setContLayer(device->plRes "electrode")
   setContPurpose(device->plRes "drawing")
   setRef(device->plRes getRef(device))
   generate(device->plRes)
   render(device->plRes)
   resRectTran = getRectTran(device->plRes)
   rtsAdd(device->rtrans resRectTran)
   setSlotValue(device 'coreBBox list( getLowerLeft(device->rtrans->rtran) getUpperRight(device->rtrans->rtran)))
   callNextMethod()
  );let
);defmethod;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  outlineChip.ils: Chip outline Pcell Skill++ code 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( outlineChip (PcellParam)
	  (
		( width @initform defineParam("float" 1000.0))	
		( length @initform defineParam("float" 1000.0))
		( edgeWidth @initform defineParam("float" 95.0))
		( col )
		( centroid )
		( ref @reader getRef @writer setRef )
		( rtrans )
		( coreBBox @initarg coreBBox )	  
	  )
) ; defClass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj outlineChip)) 
	   obj->col = makeInstance( 'outline )
	   obj->centroid = makeInstance('point2)
	   obj->rtrans = makeInstance('rectTrans)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method draws the shapes of the mesa resistor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( draw ((device outlineChip))
  let( (width length edgeWidth colRectTran )
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; Formal Parameters
   width = getParamValue(device 'width)
   length = getParamValue(device 'length)
   edgeWidth = getParamValue(device 'edgeWidth)
   setWidth(device->col width)
   setLength(device->col length)
   setEdgeWidth(device->col edgeWidth)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   setLayer(device->col "GRID")
   setPurpose(device->col "drawing")
   setRef(device->col getRef(device))
   generate(device->col)
   render(device->col)
   colRectTran = getRectTran(device->col)
   rtsAdd(device->rtrans colRectTran)
   setSlotValue(device 'coreBBox list( getLowerLeft(device->rtrans->rtran) getUpperRight(device->rtrans->rtran)))
   callNextMethod()
  );let
);defmethod;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  memsChipFrame.ils: Chip outline Pcell for MEMS Skill++ code 
;;;;;;;;;;;;;;;;  FIXME: Refactor into an assembly - very slow to compile when due to
;;;;;;;;;;;;;;;;         on-grid, rounded corners!!!
;;;;;;;;;;;;;;;;  FIMXE: Need to set min/max width and height to the frame's 
;;;;;;;;;;;;;;;;         edge width 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( memsChipFrame (PcellParam)
	  (
		( width @initform defineParam("float" 1000.0))	
		( length @initform defineParam("float" 1000.0))
                ( spm @initform defineParam("boolean" "FALSE"))
		(  pm @initform defineParam("boolean" "FALSE"))
		( ol0 )
		( ol1 )
		( ol2 )
		( ol3 )
		( ol4 )
		( centroid )
		( ref @reader getRef @writer setRef )
		( rtrans )
		( coreBBox @initarg coreBBox )			  
	  )
);defClass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj memsChipFrame)) 
	   obj->ol0 = makeInstance( 'outline )
	   obj->ol1 = makeInstance( 'outline )
	   obj->ol2 = makeInstance( 'cframe2 )
	   obj->ol3 = makeInstance( 'cframe )
	   obj->ol4 = makeInstance( 'cframe2 )
	   obj->centroid = makeInstance('point2)
	   obj->rtrans = makeInstance('rectTrans)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method draws the shapes of the mesa resistor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( draw ((device memsChipFrame))
  let( (minwid minlen width length spm pm edgeWidth ol0RectTran 
        backSideEdgeWidth nitrideEtchEdgeWidth bondRingEdgeWidth 
        lidMetalRingEdgeWidth lidMetalEdgeInnerOffset 
        bondRingEdgeInnerOffset lidEtchRingEdgeInnerOffset lib 
        view name type cv spmlen bo bnbKo)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; Formal Parameters - From Techfile
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; FIXME: hard wired here temporarily. Need to get the from TF.
   ; (need to finalize on frame specifications!)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   spmlen = 747.0
   minwid = 2000.0
   minlen = 2000.0
   ; frame widths
   backSideEdgeWidth = 39.5
   nitrideEtchEdgeWidth = 95.0
   bondRingEdgeWidth = 500.0
   lidMetalRingEdgeWidth = 100.0
   lidEtchRingEdgeWidth = 1000.0
   ; frame offsets from outter edge references
   bondRingEdgeInnerOffset = 145.0
   lidMetalEdgeInnerOffset = 200.0
   lidEtchRingEdgeInnerOffset = 200.0
   ; layers
   setLayer(device->ol0 "dot_etch")
   setPurpose(device->ol0 "drawing")
   setLayer(device->ol1 "Backside")
   setPurpose(device->ol1 "drawing")
   setLayer(device->ol2 "Bond_Ring")
   setPurpose(device->ol2 "drawing")
   setLayer(device->ol3 "Lid_Metal")
   setPurpose(device->ol3 "drawing")
   setLayer(device->ol4 "LID_ETCH")
   setPurpose(device->ol4 "drawing")
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; User Parameters 
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;  Outside Dimensions
   width = getParamValue(device 'width)
   length = getParamValue(device 'length)
   ; SPMs
   spm = getParamValue(device 'spm)
   pm = getParamValue(device 'pm)
   ;printf("spm value: %L\n" spm)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Minimum and clamp checks
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; width
   if(width < minwid then
      width = minwid
   );if
   ; height
   if(length < minlen then
      length = minlen
   );if
;  edgeWidth = getParamValue(device 'edgeWidth)
   ; Outline 0
   setWidth(device->ol0 width)
   setLength(device->ol0 length)
   setEdgeWidth(device->ol0 nitrideEtchEdgeWidth)
   ; Outline 1
   setWidth(device->ol1 width)
   setLength(device->ol1 length)
   setEdgeWidth(device->ol1 backSideEdgeWidth)
   ; Outline 2
   setWidth(device->ol2 width-2*bondRingEdgeInnerOffset)
   setHeight(device->ol2 length-2*bondRingEdgeInnerOffset)
   setEdgeWidth(device->ol2 bondRingEdgeWidth)
   setRadius(device->ol4 nitrideEtchEdgeWidth)
   ; Outline 3
   setWidth(device->ol3 width-2*bondRingEdgeInnerOffset-2*lidMetalEdgeInnerOffset)
   setHeight(device->ol3 length-2*bondRingEdgeInnerOffset-2*lidMetalEdgeInnerOffset)
   setEdgeWidth(device->ol3 lidMetalRingEdgeWidth)
   ; Outline 4
   setWidth(device->ol4 width-2*bondRingEdgeInnerOffset-2*bondRingEdgeWidth-2*lidEtchRingEdgeInnerOffset)
   setHeight(device->ol4 length-2*bondRingEdgeInnerOffset-2*bondRingEdgeWidth-2*lidEtchRingEdgeInnerOffset)
   setEdgeWidth(device->ol4 lidEtchRingEdgeWidth)
   setRadius(device->ol4 nitrideEtchEdgeWidth)
   setPlate(device->ol4 't)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Set the References
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   setRef(device->ol0 getRef(device))
   setRef(device->ol1 getRef(device))
   setRef(device->ol2 getRef(device))
   setRef(device->ol3 getRef(device))
   setRef(device->ol4 getRef(device))
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Generate the assemblies 
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   generate(device->ol0)
   generate(device->ol1)
   generate(device->ol2)
   generate(device->ol3)
   generate(device->ol4)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Render the assemblies
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   render(device->ol0)
   render(device->ol1)
   render(device->ol2)
   render(device->ol3)
   render(device->ol4)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Generate a RectTran - Only need the outter oultine
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ol0RectTran = getRectTran(device->ol0)
   rtsAdd(device->rtrans ol0RectTran)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Set the CV boundary box
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   setSlotValue(device 'coreBBox list( getLowerLeft(device->rtrans->rtran) getUpperRight(device->rtrans->rtran)))
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Call the next draw in the 
   ; case of multiple inheritance
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Fixed Cellview Instantiations
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   lib = "reticle"
   view = "layout"
   type = "maskLayout"
   name = "bug"
   bo = 2.0*bondRingEdgeInnerOffset+2.0*lidMetalEdgeInnerOffset+2.0*lidEtchRingEdgeInnerOffset
   cv = dbOpenCellViewByType( lib name view "maskLayout" "r")
   dbCreateInst(getRef(device) cv name list(-width/2.0+bo -length/2.0+bo) "R0" 1)
   if(spm == "TRUE" then
     name = "xyPad_SLB"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(-width/2.0+300.0+bo -length/2.0+bo) "R0" 1)
     name = "SPM_X_AH32"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(width/2.0-spmlen/2.0-2*nitrideEtchEdgeWidth length/2.0-nitrideEtchEdgeWidth/2.0) "R0" 1)
     name = "SPM_Y_AH32"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(width/2.0-nitrideEtchEdgeWidth/2.0 length/2.0-spmlen/2.0-2*nitrideEtchEdgeWidth) "R0" 1)
     name = "SPM_X_AH53"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(-width/2.0+spmlen/2.0+2*nitrideEtchEdgeWidth -length/2.0+nitrideEtchEdgeWidth/2.0) "R0" 1)
     name = "SPM_Y_AH53"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(-width/2.0+nitrideEtchEdgeWidth/2.0 -length/2.0+spmlen/2.0+2*nitrideEtchEdgeWidth) "R0" 1)
     callNextMethod()
    else
     name = "xyPad_SLA"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(-width/2.0+bo+300.0 -length/2.0+bo) "R0" 1)
     callNextMethod()
   );if
   if(pm == "TRUE" then
     name = "ASML_PM_LO"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(0.0 0.0) "R0" 1)
   else
     bnbKo = 50.0
     name = "asml_1_bnb_RE_BR"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(0.0 0.0) "R0" 1)
     name = "asml_1_bnb_RE_DL"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(bnbKo/2.0 0.0) "R0" 1)
     name = "asml_1_bnb_RE_EL"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(-bnbKo/2.0 0.0) "R0" 1)
     name = "asml_1_bnb_RE_GL"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(0.0 bnbKo/2.0) "R0" 1)
     name = "asml_1_bnb_RE_LM"
     cv = dbOpenCellViewByType( lib name view type "r")
     dbCreateInst(getRef(device) cv name list(0.0 -bnbKo/2.0) "R0" 1)
   );if
  );let
);defmethod;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  cap.ils: MEMs Capacitor PCELL 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( cap (PcellParam)
	  (
		( wid @initform defineParam("float" 100.0))	
		( len @initform defineParam("float" 100.0))
		( plCap )
		( plBpc )
		( plTpc )
		( centroid )
		( ref @reader getRef @writer setRef )
		( rtrans )
		( coreBBox @initarg coreBBox )	  
	  )
);defClass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj cap)) 
	   obj->plCap = makeInstance( 'planarCap )
	   obj->plBpc = makeInstance( 'memsCapBotCont )
	   obj->plTpc = makeInstance( 'memsCapTopCont )
	   obj->centroid = makeInstance('point2)
	   obj->rtrans = makeInstance('rectTrans)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method draws the shapes of the mems planar capacitor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( draw ((device cap))
  let( (wid len overlap capRectTran topRectTran botRectTran bpOverlap)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;; Formal Parameters
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   overlap = 2.0
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; User Parameters
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   wid = getParamValue(device 'wid)
   len = getParamValue(device 'len)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Cap body
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Dielectric "Sandwiched" layer
   setWidthDiel(device->plCap wid)
   setLengthDiel(device->plCap len)
   setLayerDiel(device->plCap "spacer_via")
   setPurposeDiel(device->plCap "drawing")
   ; Top Plate Definition
   setWidthTop(device->plCap wid+2*overlap)
   setLengthTop(device->plCap len+2*overlap)
   setLayerTop(device->plCap "membrane")
   setPurposeTop(device->plCap "drawing")
   ; Bottom Plate Definition
   setWidthBot(device->plCap wid+4*overlap)
   setLengthBot(device->plCap len+4*overlap)
   setLayerBot(device->plCap "thick")
   setPurposeBot(device->plCap "drawing")
   setRef(device->plCap getRef(device))
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Cap top contact
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   setWidth(device->plTpc wid+2*overlap)
   setLength(device->plTpc len+2*overlap)
   setRef(device->plTpc getRef(device))
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Cap bottom contact
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   bpOverlap = 12.0;
   setWidth(device->plBpc wid+2*bpOverlap)
   setLength(device->plBpc len+2*bpOverlap)
   setRef(device->plBpc getRef(device))
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   generate(device->plCap)
   generate(device->plTpc)
   generate(device->plBpc)
   render(device->plCap)
   render(device->plTpc)
   render(device->plBpc)
   capRectTran = getRectTran(device->plCap)
   topRectTran = getRectTran(device->plTpc)
   botRectTran = getRectTran(device->plBpc)
   rtsAdd(device->rtrans capRectTran)
   rtsAdd(device->rtrans topRectTran)
   rtsAdd(device->rtrans botRectTran)
   rtsUnion(device->rtrans)
   setSlotValue(device 'coreBBox list( getLowerLeft(device->rtrans->rtran) getUpperRight(device->rtrans->rtran)))
   callNextMethod()
  );let
);defmethod;######################################################
; ganFetPc.ils: GaN FET PCELL class. Inherits from PcellParam
;           making it a Cadence PCELL class
;######################################################
defclass( ganFetPc (PcellParam)
  (	  
    ( m      @initform defineParam("int"   2) )
    ( width  @initform defineParam("float" 100.0) )
    ( centroid )
    ( ref @reader getRef @writer setRef )
    ( rtrans )
    ( coreBBox @initarg coreBBox )
    ( pcode @reader getPcode @writer setPcode )
  ) 				  
);defclass
;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj ganFetPc)) 
  obj->centroid = makeInstance('point2)
  obj->pcode = "D91"
);defmethod
;######################################################
; Draws the gate
;######################################################
defmethod( drawFet (( gfpc ganFetPc ))
  let( (width length spacing rtran gf tf)
    tf = makeInstance( 'techfile )
    setName(tf gfpc->pcode)
    getControls(tf)
    m     = getParamValue(gfpc 'm)
    width = getParamValue(gfpc 'width)
    length = getControl(tf "gateLength")
;    length = 0.2
    gf = makeInstance( 'ganFet )
    setRef(gf getRef(gfpc))
    setM(gf m)
    setWidth(gf width)
    setLength(gf length)
    generate(gf)
    render(gf)
    setSlotValue(gfpc 'coreBBox list( gf->rtrans->rtran->ll gf->rtrans->rtran->ur))
    ; No multiple inheritance
    ;callNextMethod()
  );let
);defmethod
;######################################################################
; Returns gates's bounding box which is stored in coreBBox slot
;######################################################################
defmethod( getCoreBBox ((gf ganFetPc))
  slotValue(gf 'coreBBox)
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;