;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  cadObj.ils: base CAD class. Most all classes will be derived/Inherit from 
;              this class
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
; Program SKILL Lint started on Sep 13 13:43:12 2017.
; IQ score is 100 (best is 100).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( cadObj ()
	  (
		( oid @reader getOid @writer setOid )
		( cid @reader getCid @writer setCid )
		( ref @reader getRef @writer setRef )
		( attributes @reader getAttributes  )
		( layer @reader getLayer @writer setLayer )
		( purpose @reader getPurpose @writer setPurpose )
		( grid @writer setGrid @reader getGrid )			
	  )
) ; defclass

;########################################################
;# Class Constructor
;########################################################

defmethod( initializeInstance @after ((obj cadObj)) 
	   obj->oid=nil
	   obj->cid=nil
	   obj->ref=nil
	   obj->attributes=nil
	   obj->layer = "text"
	   obj->purpose = "drawing"
	   obj->grid = 0.025
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Stores a List of Attributes the attributes member given
; that the reference to that CAD object has been set
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( setAttrList (( cobj cadObj ))
	cobj->attributes = cobj->ref->?
) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method selects an attribute from the attribute list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( getAttrByIndex (( cobj cadObj ) index)
		nth(index cobj->attributes)
) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method selects an attribute's contents from the attribute list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
defmethod( getAttrValueByIndex (( cobj cadObj ) index)
		nth(index cobj->attributes)->?
) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Returns Attribute Based Upon the Attribute Name
; key value must be a string i.e. "prop"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
defmethod( getAttrValueByKey (( cobj cadObj ) key)
	let( (  vals
		value
		attribute
		m
		y
		rlist
	        hashlist
	        keyind )
		vals = cobj->ref->??
		;FIXME: Need to detect cv type reference or lib reference (ddGetObj)
		vals = cdr(vals) ;; peel off the redundant dbid
		attribute = '()
		value = '()
		m = 1
		foreach(x vals
	  	  if( (m > 0) then
	      	    attribute = cons(x attribute)
	      	    m = -1
	  	  else
		    value = cons(x value)
              	    m = 1
	  	  ) ; if
		) ; foreach
		hashlist = '()
		m=0
		foreach(z attribute
	          y = nth(m value)
	  	  m=m+1
	  	  rlist = '()
	  	  rlist = cons(y rlist)
	  	  rlist = cons(z rlist)	  
	  	  hashlist = cons(rlist hashlist)
		) ; foreach
		keyind = stringToSymbol(key)
        	nth(1 assq( keyind hashlist))
	) ; let
) ; defMethod
;############################################################
;############################################################
;############################################################
;######################################################
;# 2-D Coordinate Class
;######################################################
defclass( coord2 ()
  (
    ( x @reader getX @writer setX )
    ( y @reader getY @writer setY )	
  )				  
) ; defclass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj coord2)) 
  obj->x = nil
  obj->y = nil
);defmethod

;#####################################################
; returns the coordinate in list form
;#####################################################
defmethod( getCoord (( c2 coord2 ))
  list(getX(c2) getY(c2))	   
);defmethod

;#####################################################
; Sets coordinated based upon a list argument
;#####################################################
defmethod( setCoord (( c2 coord2 ) arg )
  c2->x = xCoord(arg)
  c2->y = yCoord(arg)
  list(c2->x c2->y)	   
);defmethod

;######################################################
;######################################################
;######################################################



;######################################################
;# Primitive 2-D Point Class
;######################################################
defclass( point2 (coord2 cadObj)
  ()				  
) ; defclass

;#####################################################
; Constructor Method
;#####################################################
;defmethod( initializeInstance @after ((obj point2)) 
 ; obj->point = nil
;);defmethod

;#####################################################
;
;#####################################################
;defmethod( setPoint (( pt point2 ) arg )
;  pt->point = list(float(xCoord(arg)) float(yCoord(arg)))	   
;);defmethod

;#####################################################
;
;#####################################################
;defmethod( getPoint (( pt point2 ))
;  pt->point	   
;);defmethod

;#####################################################
; translate point in 2-D space. Argument is list:
; list( xTran ytran)
;#####################################################
defmethod( translate (( pt point2 ) arg )
	   setX(pt getX(pt)+xCoord(arg))
	   setY(pt getY(pt)+yCoord(arg))
);defmethod

;#####################################################
; rotate a point in 2-D space about the origin
;#####################################################
defmethod( rotate (( pt point2 ) arg )
  let( (pi xcd ycd theta thetaPrime)
    pi = 3.14159265
    xcd = xCoord(getCoord(pt))
    ycd = yCoord(getCoord(pt))
    mag = (xcd**2+ycd**2)**0.5
    theta = atan2(ycd xcd)
    thetaPrime = theta+arg/180*pi
    setCoord(pt list(mag*cos(thetaPrime) mag*sin(thetaPrime)))
  );let
);defmethod

;#####################################################
; scale a point in 2-D space. Argument is a scaler
;#####################################################
defmethod( scale (( pt point2 ) arg )
	   setX(pt getX(pt)*scale)
	   setY(pt getY(pt)*scale)
);defmethod


; FIXME: Need to update for new coord2 inheritance
;#####################################################
; This method indicates whether class member point2 point
; is located to the lower-left of the input point argument pnt
; (logically lower OR left )
;#####################################################
;defmethod( lowerLeftPoint ((pt point2) arg)
;  let( ( pt1y pt2y )
;       cond(
;  ( xCoord(pt->point) < xCoord(arg)
;	     t
;	   );xCoord(pt->point) ...
;	   ( xCoord(pt->point) == xCoord(arg)
;	     	   pt1y = yCoord(pt->point)
;		   pt2y = yCoord(arg)
;		   pt1y < pt2y
;;	   );
;	   ( xCoord(pt->point) < xCoord(arg)
;	     t
;	   );xCoord(pt->point) ...
;	   ( t
;	     nil
;	   );t
 ;      );cond
;  );let
;);defmethod

;#####################################################
; FIXME: Should be in shape class as this is where
;        we begin to recognize grid
;#####################################################
;defmethod( isOnGrid (( pt point2 ))
;  let( (compFactor ret) 
;    compFactor = 1 / pt->dbuPerUu
;    ret = t
;    if(float(pt->x) != round( ( float(pt->x) + compFactor ) / pt->mfg ) * pt->mfg then
;      printf("WARNING: X Coordinate is off the manufacturing grid of %f: %f\n" pt->mfg float(pt->x))
;      ret = nil
;      if(float(pt->y) != round( ( float(pt->y) + compFactor ) / pt->mfg ) * pt->mfg then	
;        printf("WARNING: Y Coordinate is off the manufacturing grid of %f: %f\n" pt->mfg float(pt->y))
;      else
;        printf("WARNING: Both X and Y Coordinates are off the manufacturing grid of %f: (%f,%f)\n" pt->mfg float(pt->x) float(pt->y))
;      );if
;    else
;      printf("INFO: X Coordinate is on the manufacturing grid of %f: %f\n" pt->mfg float(pt->x))
;      if(float(pt->y) != round( ( float(pt->y) + compFactor ) / pt->mfg ) * pt->mfg then	
;        printf("WARNING: Y Coordinate is off the manufacturing grid of %f: %f\n" pt->mfg float(pt->y))
;        ret = nil
;      else
;	 printf("INFO: Y Coordinate is on the manufacturing grid of %f: %f\n" float(pt->mfg) float(pt->y))
;      );if
;    );if
;    ret	       
;  );let	     
;);defmethod

;#####################################################
; FIXME: Should be in shape class as this is where
;        we begin to recognize grid
;#####################################################
;defmethod( setOnGrid (( pt point2 ))
;  let( (compFactor) 
;    compFactor = 1 / pt~>dbuPerUu 
;    pt->x=round( ( pt->x + compFactor ) / pt->mfg ) * pt->mfg
;    pt->y=round( ( pt->y + compFactor ) / pt->mfg ) * pt->mfg
;    list(  pt->x pt->y  ) 
;  );let  
;);defmethod

;#####################################################
; This method corrects machine dependent round-off error.
;#####################################################
defmethod( pcFixPoint (( pt point2 ))
           setX(pt pcFix(getX(pt)))
	   setY(pt pcFix(getY(pt)))	   
);defmethod

;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  points.ils: container class for 2-D points 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( points2 ()
	  (
		( points @reader getPoints @writer setCollection)		  
	  )
) ; defclass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj points2)) 
  obj->points = makeInstance( 'collection )
);defmethod

;#####################################################
; Add point2 object to points collection
;#####################################################
defmethod( appendPoint ((pts points2) arg) 
  if(classp( arg 'point2) then
    add(pts->points arg)
  else
    println("ERROR(points2): Argument is not a point2 object")
  );if
);defmethod

;#####################################################
; Add a list of point2 object to points collection
; argument is a simple list of points
;#####################################################
defmethod( addPoints ((pts points2) arg)
  let( (temp) 
    if(listp(arg) then
      foreach(pt arg
        temp = makeInstance( 'point2 )
	setCoord(temp pt) 
        appendPoint(pts temp)
      );foreach
    else
      println("ERROR(points2): Argument is not a simple list")
    );if
  );let
);defmethod

;#####################################################
; Reset points points collection
;#####################################################
defmethod( resetPoints ((pts points2)) 
  resetCollection(pts->points)
);defmethod

;#####################################################
; Translate all points in the collection based
; upon a list coordinate input
;#####################################################
defmethod( translate ((pts points2) arg)
  if( listp(arg) then
    foreach(p2 getCollection(pts->points)
      translate(p2 arg)
    );foreach
  else
    println("ERROR(points2): argument must be a simple list")
  );if
);defmethod 


;#####################################################
; Translate all points in the collection based
; upon a list coordinate input
;#####################################################
defmethod( rotate ((pts points2) arg)
    foreach(p2 getCollection(pts->points)
      rotate(p2 arg)
    );foreach
);defmethod 

;#####################################################
; scale all points in the collection based
; upon a scalar argument
;#####################################################
defmethod( scale ((pts points2) arg)
  foreach(p2 getCollection(pts->points)
    scale(p2 arg)
  );foreach
);defmethod

;#####################################################
; mirror all points about the y axis referenced to
; origin. Origin of the points list should be translated
; to the centroid of it's rectTran
;#####################################################
defmethod( mirrory ((pts points2))
  let( (newpnts temp)
    newPnts = makeInstance( 'collection )
    foreach( pnt getCollection(pts->points)
      temp = makeInstance( 'point2 )
      setCoord(temp list(-1*xCoord(getCoord(pnt)) yCoord(getCoord(pnt))))
      add(newPnts temp)
    );foreach
    setCollection(pts newPnts)
  );let
);defmethod 

;#####################################################
; mirror all points about the x axis referenced to
; origin. Origin of the points list should be translated
; to the centroid of it's rectTran
;#####################################################
defmethod( mirrorx ((pts points2))
  let( (newpnts temp)
    newPnts = makeInstance( 'collection )
    foreach( pnt getCollection(pts->points)
      temp = makeInstance( 'point2 )
      setCoord(temp list(xCoord(getCoord(pnt)) -1*yCoord(getCoord(pnt))))
      add(newPnts temp)
    );foreach
    setCollection(pts newPnts)
  );let
);defmethod 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  polygon2.ils: Layout Polygon Object 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( polygon2 (cadObj)
  (	
    ( vertices @reader getVertices )
    ( area )
    ( centroid )
    ( scale )
    ( rtran @reader getRectTran )			  	
  )
);defClass

;#####################################################
; Constructor method
;#####################################################
defmethod( initializeInstance @after ((obj polygon2)) 
	   obj->vertices = nil
	   obj->area = nil
	   obj->centroid = makeInstance( 'point2 )
	   obj->scale = 1.0
	   obj->rtran = makeInstance( 'rectTran )
);defmethod

;####################################################
; Checks to make sure that the centroid of the
; rectTran is at the origin
;####################################################
defmethod( isCentered (( poly polygon2 ))
  let( (c)
    c = getCentroid(poly->rtran)
    if( xCoord(c) < 0.000001 && yCoord(c) < 0.000001 then
      t
    else
      nil
    )	 
  );let	   
);defmethod

;####################################################
; Centers the polygon's rectTran at the origin
; if not already centered
;####################################################
defmethod( center (( poly polygon2 ))
  let( (c)
    if( !isCentered(poly) then
       c = getCentroid(poly->rtran)
       translate(poly list(-xCoord(c) -yCoord(c)))
       setCentroid(poly->rtran list(0.0 0.0))
       setCentroid(poly list(0.0 0.0))
       getCentroid(poly->rtran)
    else
      t
    );if
  );let	 	   
);defmethod

;####################################################
; Sets the polygon vertices and calculates the
; area and centroid of the polygon
;####################################################
defmethod( setVertices (( poly polygon2 ) arg)
  poly->vertices = arg
  centroid(poly)
  poly->vertices	 	   
);defmethod

;####################################################
; Sets the polygon centroid value
;####################################################
defmethod( setCentroid (( poly polygon2 ) arg)
  setCoord(poly->centroid arg)	   
);defmethod

;####################################################
; Gets the polygon centroid value
;####################################################
defmethod( getCentroid (( poly polygon2 ))
  getCoord(poly->centroid)	   
);defmethod

;###############################################################################
; Area of a closed non-self intersecting polygon
;###############################################################################
defmethod( area (( poly polygon2 ))
	   let( (term0
	   	 term1 
	   	 j
	   	 len)
		poly->area = 0.0
		len = length(poly->vertices)
	   	for( i 0 length( poly->vertices)-1
		     j = modulo(i+1 len)
		     term0 = xCoord(nth(i poly->vertices))*yCoord(nth(j poly->vertices))
		     term1 = xCoord(nth(j poly->vertices))*yCoord(nth(i poly->vertices))
		     poly->area = poly->area + (term0 - term1)
		     i = i+1
	   	);for
		if( poly->area < 0 then
		    poly->area = -1*poly->area
		)
		poly->area = 0.5*(poly->area)
	   );let	   
);defmethod

;###############################################################################
; Centroid of a closed non-self intersecting 2-D transform
;###############################################################################
defmethod( centroid (( poly polygon2 ))
	   let( (term0
	   	 term1 
		 term2
		 term3
		 term4
		 term5
	   	 j
	   	 len
		 cx
		 cy)
		area(poly)
		len = length(poly->vertices)
		cx=0.0
		cy=0.0
	   	for( i 0 length( poly->vertices)-1
		     j = modulo(i+1 len)
		     term0 = xCoord(nth(i poly->vertices))+xCoord(nth(j poly->vertices))
		     term1 = xCoord(nth(i poly->vertices))*yCoord(nth(j poly->vertices))
		     term2 = xCoord(nth(j poly->vertices))*yCoord(nth(i poly->vertices))
		     term3 = yCoord(nth(i poly->vertices))+yCoord(nth(j poly->vertices))
		     term4 = xCoord(nth(i poly->vertices))*yCoord(nth(j poly->vertices))
		     term5 = xCoord(nth(j poly->vertices))*yCoord(nth(i poly->vertices))
		     cx=cx+(term0*(term1+term2))/(6*poly->area)
		     cy=cy+(term3*(term4+term5))/(6*poly->area)
		     i = i+1
	   	);for
		if( cx > 1000 || cy > 1000 then
		    println("WARNING(polygon2): Centroid calculation may have failed")
		    println("                   Setting centroid manually is recommended")
		) 
		setCoord(poly->centroid list(cx cy))
	   );let	   
);defmethod

;###############################################################################
; Rotate Polygon. Polygon's centroid must be at origin prior to rotation
;###############################################################################
defmethod( rotate (( poly polygon2 ) arg)
  let( (rVerts mag theta thetaPrime tvert pi)
    pi = 3.14159265
    foreach( vert poly->vertices
      mag   = (xCoord(vert)**2+yCoord(vert)**2)**0.5
      theta = atan2(yCoord(vert) xCoord(vert))
      thetaPrime = theta+arg/180*pi
      tvert = list(mag*cos(thetaPrime) mag*sin(thetaPrime))
      rVerts = cons(tvert rVerts)
    );foreach
      setVertices(poly rVerts)
  );let	   
);defmethod

;#####################################################
; This method scales the polygon by the arg value
;#####################################################
defmethod( scale (( poly polygon2 ) arg)
  let( (new rvert)
    new = '()
    foreach( vert poly->vertices
      rvert = list(arg*xCoord(vert) arg*yCoord(vert))
      new = cons(rvert new)
    );foreach
      poly->vertices = new
  );let	   
);defmethod

;###############################################################################
; render the polygon
;###############################################################################
defmethod( render (( poly polygon2 ))
  if( !null(poly->vertices) then
    println("INFO(polygon): Rendering")
    dbCreatePolygon(poly->ref
	     	    list(poly->layer poly->purpose)
		    poly->vertices
    );dbCreatePolygon
  else
    println("ERROR(polygon): No vertices to render")
  );if   
);defmethod

;#####################################################
; Find max x 
;#####################################################
defmethod( maxx (( poly polygon2 ))
  let( (maxx)
    ;FIXME: Need to ensure with a check that the origin is inside
    ;       the polygon. By construction rules, polygons will always
    ;       have the origin withih the polygon, but it should have
    ;       an extra check
    maxx = 0.0
    foreach( vert poly->vertices
      if(xCoord(vert) > maxx then
        maxx = xCoord(vert)
      else
        maxx = maxx
      );if
    );foreach
    maxx 
   );let		     	 
);defmethod

;#####################################################
; Find min x 
;#####################################################
defmethod( minx (( poly polygon2 ))
  let( (minx)
    ;FIXME: Need to ensure with a check that the origin is inside
    ;       the polygon. By construction rules, polygons will always
    ;       have the origin withih the polygon, but it should have
    ;       an extra check
    minx = 0.0
    foreach( vert poly->vertices
      if(xCoord(vert) < minx then
        minx = xCoord(vert)
      else
        minx = minx
      );if
    );foreach
    minx 
   );let		     	 
);defmethod

;#####################################################
; Find max y 
;#####################################################
defmethod( maxy (( poly polygon2 ))
  let( (maxy)
    ;FIXME: Need to ensure with a check that the origin is inside
    ;       the polygon. By construction rules, polygons will always
    ;       have the origin withih the polygon, but it should have
    ;       an extra check
    maxy = 0.0
    foreach( vert poly->vertices
      if(yCoord(vert) > maxy then
        maxy = yCoord(vert)
      else
        maxy = maxy
      );if
    );foreach
    maxy 
   );let		     	 
);defmethod

;#####################################################
; Find min y
;#####################################################
defmethod( miny (( poly polygon2 ))
  let( (miny)
    ;FIXME: Need to ensure with a check that the origin is inside
    ;       the polygon. By construction rules, polygons will always
    ;       have the origin withih the polygon, but it should have
    ;       an extra check
    miny = 0.0
    foreach( vert poly->vertices
      if(yCoord(vert) < miny then
        miny = yCoord(vert)
      else
        miny = miny
      );if
    );foreach
    miny
   );let		     	 
);defmethod

;#####################################################
; Set the rectangular transformation rectTran of the
; polygon
;#####################################################
defmethod( setRectTran (( poly polygon2 ))
  setUpperRight(poly->rtran list(maxx(poly) maxy(poly)))
  setLowerLeft(poly->rtran list(minx(poly) miny(poly)))
  calculateCentroid(poly->rtran)
);defmethod

;#####################################################
; FIXME: this should be in transform2 class
; This method "spins" the polygon vertices in a 
; counter-clockwise direction by one increment every call 
;#####################################################
;defmethod( spin (( poly polygon2 ))
;	    let( (j temp)  
;	   	temp = '()
;		j=1
;		for( i 0 length( poly->vertices)-2    
;		     temp = append1(temp nth(j poly->vertices))
;		     j = j+1
;	   	);for
;		temp = append1(temp nth(0 poly->vertices)) 
;		poly->vertices = temp
;	    );let
;);defmethod

;#####################################################
; This method translates the position of each polygon2
; vertex and it's current centroid value by the point 
; value argument "list(x y)" 
;#####################################################
defmethod( translate (( poly polygon2 ) trn)
  let( (new len tvert) 
    new = '()
    len = length(poly->vertices)
    foreach( vert poly->vertices
      tvert = list(xCoord(vert)+xCoord(trn) yCoord(vert)+yCoord(trn))
      new = cons(tvert new)
    );foreach
    poly->vertices = new
    poly->centroid->x = poly->centroid->x + xCoord(trn)
    poly->centroid->y = poly->centroid->y + yCoord(trn)
  );let	   
);defmethod

;###############################################################################
; Check that there are at least 3 vertices (not a line or a point)
;###############################################################################

;###############################################################################
; Make Vertex List
;###############################################################################
;defmethod( setVertexList (( poly polygon2 ))
;  let( (i vobj)
;   poly->vertObjList = '()
;   i=0
;    foreach(vert poly->vertices
;  	   vobj = makeInstance('vertex2)
;	   setxy(vobj vert)
;	   setNum(vobj i)
;  	   poly->vertObjList = cons(vobj poly->vertObjList)
;	   i++
;    );foreach	       
;  );let   
;);defmethod

;###############################################################################
; FIXME: Edge object?
; Make Poly Edge List
;###############################################################################
;defmethod( setEdgeList (( poly polygon2 ))
;  let( (eobj)
;    poly->edgeObjList = '()
;    for(i 0 sub1(sub1(poly->vertices))
;  	   eobj = makeInstance('edge)
;	   setxy(eobj->p0 nth(i poly->vertices))
;	   setxy(eobj->p1 nth(i+1 poly->vertices))
;	   update(eobj)
;  	   poly->vertObjList = cons(eobj poly->vertObjList)
;    );for       
;  );let   
;);defmethod

;###############################################################################
; FIXME: Merge Object?
; Get lower-left vertex of the polygon
;###############################################################################
;defmethod( getLowerLeft (( poly polygon2 ))
;  let( ()  
;    foreach(vert poly->vertices
;      
;    );foreach
;  );let
;  nil
;);defmethod

;###############################################################################
; FIXME: Merge Object?
; Detect if polygon is intersecting the argument
;###############################################################################
;defmethod( isIntersecting (( poly polygon2 ) arg )
;  nil
;);defmethod
;###############################################################################
; Close Vertices
;###############################################################################

;###############################################################################
; Derivative Filtering of Vertice List - eliminate dy/dx=0 vertices
;###############################################################################


;###############################################################################
; Perimeter of a 2-D Polygon
;###############################################################################

;###############################################################################
; Diff the vertices of another set of vertices of a second 2-D Polygon
;###############################################################################



;###############################################################################
; FIXME: This method should be in the transform class and it should be using the  
; point2 on grid method
; Determine if all polygon points are on the manufacturing grid
;###############################################################################
;defmethod( isPolyOnGrid (( poly polygon2 ))
;  let( (ret)
;    ret = t
;    foreach( vert poly->vertObjList
;      if(isOnGrid(vert) then
;        println("Point on Grid")
;      else
;        ret = nil
;      );if
;    );foreach
;    ret
;  );let
;);defmethod

;###############################################################################
; FIXME: This method should be in the transform class 
; FIXME: Should be in the points2 class
; Place all polygon points on the manufacturing grid
;###############################################################################
;defmethod( setPolyOnGrid (( poly polygon2 ))
;    foreach( vert poly->vertObjList
;      setOnGrid(vert) 
;    );foreach
;);defmethod

;###############################################################################
; WIP: DEBUG MODE ...
; Detect if point is inside the member polygon.
; Implements "overlap rule" where the point needs to be inside
; and not lie on the perimeter of the polygon.
; FIXME: could make this identify if a point is ON a edge or vertex
;        by adding in additional abs(cp) equal zero checks
;        Check if the detected point is a vertex gives you a vertex
;        overlap and if not it's an edge overlap
;###############################################################################
defmethod( isPointInside (( poly polygon2 ) pnt )
  let( (vectList vect vp rotation vect0 vect1 ret cp)
     vectList = '()
     foreach( vert poly->vertices
       vect = makeInstance( 'vector2 )
       setHead(vect vert)
       setTail(vect pnt)
       vectList = cons(vect vectList) 
     );foreach
     rotation = 0.0
     vect0 = nth(0 vectList)
     vect1 = nth(1 vectList)
     cp = cross(vect0 vect1)
     ret = t
     if( cp != abs(0.0) then
       if( cp > 0.0 then
       	 printf("0: Initial Pos CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y )
       else
	 printf("0: Initial Neg CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y )
       );if
       if(cp > 0.0 then
         for( i 1 sub1(sub1(length(vectList)))
           vect0 = nth(i vectList)
	   vect1 = nth(i+1 vectList)
	   cp = cross(vect0 vect1)
	   printf("%d: Pos Incremental CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" i cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y ) 
	   if(cp <= 0.0 then
	     ret = nil
	   else 
	     ret = ret
	   );
       );for
       else
         for( i 1 sub1(sub1(length(vectList)))
           vect0 = nth(i vectList)
	   vect1 = nth(i+1 vectList)
	   cp = cross(vect0 vect1)
	   printf("%d: Neg Incremental CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" i cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y ) 
	   if(cp >= 0.0 then
	     ret = nil
	   else
	     ret = ret
	   );
         );for
       );if
     else
       printf("0: Initial Zero CP :%f [(%f,%f),(%f,%f)] X [(%f,%f),(%f,%f)]\n" cp vect0->head->x vect0->head->y vect0->tail->x vect0->tail->y vect1->head->x vect1->head->y vect1->tail->x vect1->tail->y )
       ret=nil
     );if
     ret
  );let
);defmethod


;###############################################################################
; FIXME: Edge object?
; Using the vertices, generate a list of edge2 objects in the edge collection
;###############################################################################
;defmethod( genEdges (( poly polygon2 ) )
;  nil
;);defmethod

;###############################################################################
; Is polygon a rectangle
;###############################################################################
defmethod( isRectangle (( poly polygon2 ))
  nil
)

;###############################################################################
;###############################################################################
;###############################################################################




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  shape2.ils: Layout Shape Object 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( shape2 (cadObj)
	  (	
	  	( geometries )	
		( layer @writer setLayer @reader getLayer )
		( purpose @writer setPurpose @reader getPurpose )
		( dbg )
		( mfg )				
	  )
) ; defClass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj shape2))
	   obj->geometries = makeInstance( 'collection )  
	   obj->layer = nil 
	   obj->purpose = nil 
	   obj->dbg = nil
	   obj->mfg = nil	     
);defmethod

;#####################################################
; Add polygon to polygons collection of the shape2
;#####################################################
defmethod( addGeometry (( shp shape2 ) arg)
  add(shp->geometries arg)
);defmethod

;#####################################################
; Shape2 is the "foundation" Rendering Class for all
; higher "layer" classes above shape2 - assembly, layer,
; stackup and layout ...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Renders the shape2 using the contained geometries
; in the the focus cv reference
;#####################################################
defmethod( render (( shp shape2 ))
  if( !null(shp->geometries->list) then
    foreach( geom shp->geometries->list->elems
      foreach( polygon geom->polygons->list->elems
        printf("INFO(shape2): Rendering Shape2 Polygon\n")
        dbCreatePolygon(shp->ref
	     	        list(shp->layer shp->purpose)
		        polygon->vertices
		        );dbCreatePolygon
      );foreach
    );foreach
  else
    printf("ERROR(shape2): Shape2 Null Vertices - ")
 );if   
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FIXME: Need to update code below to process multiple 
;        polygons in the new polygons collection 
;        member. Most of this code should drop down
;        into the geometry and polygon2 class definitions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;#####################################################
; Reset the shape2's transform
;#####################################################
;defmethod( shape2Reset (( shp shape2 ))
;	   shp->transform->vertices = shp->vertices
;	   shp->transform->area = shp->area
;	   shp->transform->centroid->x = shp->centroid->x
;	   shp->transform->centroid->y = shp->centroid->y
;);defmethod

;#####################################################
; This method sets the virtex list the the vertices
; argument
;#####################################################
defmethod( setVertices (( shp shape2 ) vertices)
	   shp->vertices = vertices
	   shp->transform->vertices = vertices
	   area(shp)
	   shp->transform->area = shp->area
	   centroid(shp)
	   shp->transform->centroid->x = shp->centroid->x
	   shp->transform->centroid->y = shp->centroid->y
	   length(shp->transform->vertices)
);defmethod

;#####################################################
; This method works on an existing Cadence layout, and
; creates polygons for all layout shape2s
;#####################################################
;
; FIXME: This needs to go into a new "snapshot" class
;
;defmethod( genVertices (( shp shape2 ))
;	   let( (bbox
;	   	 v0
;		 v1
;		 v2
;		 v3)
;	   	shp->type = shp->ref~>objType 
;		shp->vertices='()
;		shp->transform->vertices='()
;		case( shp~>ref~>objType 
;		  ( ( "polygon" )
;		    println("polygon detected")
;	   	    foreach(point shp~>ref~>points
;	      	      shp~>vertices=cons(point shp~>vertices)
;		      shp~>transform~>vertices=cons(point shp~>transform~>vertices)
;	    	    )	     
;	   	  );polygon
;		  ( ( "dot" )
;		    println("dot detected")
;	   	    foreach(point shp~>ref~>points
;	      	      shp~>vertices=cons(point shp~>vertices)
;		      shp~>transform~>vertices=cons(point shp~>transform~>vertices)
;	    	    )	     
;	   	  );dot
;		  ( ( "line" )
;		    println("line detected")
;		    bbox=shp~>ref~>bBox
;		    v3 = list(nth(0 nth( 0 bbox)) nth(1 nth(1 bbox)))
;		    v2 = list(nth(0 nth( 1 bbox)) nth(1 nth(1 bbox)))
;		    v1 = list(nth(0 nth( 1 bbox)) nth(1 nth(0 bbox)))
;		    v0 = list(nth(0 nth( 0 bbox)) nth(1 nth(0 bbox)))
;		    shp->vertices=list(v0 v1 v2 v3)
;		    shp->transform->vertices=list(v0 v1 v2 v3)
;		    shp->layer = shp~>ref~>layerName
;		    shp->purpose = shp~>ref~>purpose
;		    shp->type = shp~>ref~>objType
;		  );line
;		  ( ( "rect" )
;		    println("rect dectected")
;		    bbox=shp~>ref~>bBox
;		    v3 = list(nth(0 nth( 0 bbox)) nth(1 nth(1 bbox)))
;		    v2 = list(nth(0 nth( 1 bbox)) nth(1 nth(1 bbox)))
;		    v1 = list(nth(0 nth( 1 bbox)) nth(1 nth(0 bbox)))
;		    v0 = list(nth(0 nth( 0 bbox)) nth(1 nth(0 bbox)))
;		    shp->vertices=list(v0 v1 v2 v3)
;		    shp->transform->vertices=list(v0 v1 v2 v3)
;		    shp->layer = shp~>ref~>layerName
;		    shp->purpose = shp~>ref~>purpose
;		    shp->type = shp~>ref~>objType
;		  );rect
;		  ( ( "path" )
;		    println("path detected")
;		    bbox=shp~>ref~>bBox
;		    v3 = list(nth(0 nth( 0 bbox)) nth(1 nth(1 bbox)))
;		    v2 = list(nth(0 nth( 1 bbox)) nth(1 nth(1 bbox)))
;		    v1 = list(nth(0 nth( 1 bbox)) nth(1 nth(0 bbox)))
;		    v0 = list(nth(0 nth( 0 bbox)) nth(1 nth(0 bbox)))
;		    shp->vertices=list(v0 v1 v2 v3)
;		    shp->transform->vertices=list(v0 v1 v2 v3)
;		    shp->layer = shp~>ref~>layerName
;		    shp->purpose = shp~>ref~>purpose
;		    shp->type = shp~>ref~>objType
;		  );path
;		  ( "label"
;		    println("label detected")
;		    shp->vertices=nil
;		  );label
;		  ( t
;			error( "ERROR SHAPE2: Encountered unknown shape2" )
;			return()
;		  );t
;		);case	
;		area(shp)
;		shp->transform->area = shp->area
;		centroid(shp)
;		shp->transform->centroid->x = shp->centroid->x
;		shp->transform->centroid->y = shp->centroid->y
;		list(shp->transform->centroid->x shp->transform->centroid->y)
;	   );let	   
;);defmethod

;#####################################################
; Translates the shape2's transform
;#####################################################
; Note: Class no longer inherits from polygon2
;defmethod( shape2Translate (( shp shape2 ) trn)
;	   if( listp(trn) then
;	   ;FIXME: Need to check that inputs are in on grid increments
;	     translate(shp->transform trn)
;	     list(shp->transform->centroid->x shp->transform->centroid->y)
;	   else
;	      println("ERROR(shape2): argument must be a coordinate list")
;           );if
;);defmethod

;#####################################################
; Scales the shape2's transform
;#####################################################
; NOTE: Class no longer inherits from polygon2
;defmethod( shape2Scale (( shp shape2 ) arg)
;	   ;FIXME: Need to check that inputs are in on grid increments
;	   scale(shp->transform arg)
;	   list(shp->transform->centroid->x shp->transform->centroid->y)
;);defmethod

;#####################################################
; Rotate the shape2's transform (rot is in degrees
; with positive being counter-clockwise about the origin)
;#####################################################
; Note: Class no longer inherits from polygon2
;defmethod( shape2Rotate (( shp shape2 ) rot)
;  ;FIXME: Need to check that input arg in on grid increments
;  rotate(shp->transform rot/180*3.14159)
;);defmethod

;#####################################################
; Returns the transform's centroid
;#####################################################
;  Note: Class no longer inherits from polygon2
;defmethod( shape2Centroid (( shp shape2 ))
;	   list( shp->transform->centroid->x shp->transform->centroid->y)
;);defmethod

;#####################################################
; Returns the transform's area
;#####################################################
; Note: Class no longer inherits from polygon2
;defmethod( shape2Area (( shp shape2 ))
;	   shp->transform->area 
;);defmethod

;#####################################################
;
;#####################################################
; FIXME: This needs to go into geometry class
;defmethod( setOnDbg (( shp shape2 ))
;	   let( (x
;	   	 y
;		 vertices)
;		 vertices = '()
;		 foreach( vert shp->vertices
;	           x=round(xCoord(vert)/shp->dbg) * shp->dbg
;	           y=round(yCoord(vert)/shp->dbg) * shp->dbg
;		   vertex =list(x y)
;		   vertices = cons(vertex vertices)
;		 );foreach
;		 shp->vertices=reverse(vertices)
;	   );let	   
;);defmethod

;#####################################################
;
;#####################################################
; FIXME: This needs to go into geometry class
;defmethod( setOnMfg (( shp shape2 ))
;	   let( (x
;	   	 y
;		 vertices)
;		 vertices = '()
;		 foreach( vert shp->vertices
;	           x=round(xCoord(vert)/shp->mfg) * shp->mfg
;	           y=round(yCoord(vert)/shp->mfg) * shp->mfg
;		   vertex =list(x y)
;		   vertices = cons(vertex vertices)
;		 );foreach
;		 shp->vertices=reverse(vertices)
;	   );let	   
;);defmethod

;#####################################################
; Center the shape2's transform centroid to align to the 
; origin
;#####################################################
;defmethod( shape2Center (( shp shape2 ))
;	   let( (delx dely)
;	   	delx = shp->transform->origin->x - shp->centroid->x
;	   	dely = shp->transform->origin->y - shp->centroid->y 
;	   	shape2Translate(shp list(delx dely))
;	   	shp->transform->centroid->x = shp->transform->origin->x
;	   	shp->transform->centroid->y = shp->transform->origin->y
;		list(shp->transform->centroid->x shp->transform->centroid->y)
;	   );let
;);defmethod

;#####################################################
; Generate a bounding box for the shape2
;#####################################################
;defmethod( genBbox (( shp shape2 ))
;	   nil
;);defmethod

;#####################################################
; Does the bbox exactly match the veritices. If it
; does the bbox is a rectangle
;#####################################################
;defmethod( isRect (( shp shape2 ))
;	   nil
;);defmethod

;#####################################################
; Merge the two shape2s into one 
; argument is another shape2 reference
;#####################################################
;defmethod( mergeShape2s (( shp shape2 ) arg)
;	  shp->ref = leMergeShape2s(list(shp->ref arg))
;);defmethod

;#####################################################
; Union of two shape2s
;#####################################################
;defmethod( unionShape2s (( shp shape2 ) arg)
;	  leOr(shp->ref shp->ref arg)
;);defmethod

;#####################################################
; Union minus intersection of two shape2s
;#####################################################
;defmethod( intersectionShape2s (( shp shape2 ) arg)
;	  leXor(shp->ref shp->ref arg)
;);defmethod

;#####################################################
; Union minus intersection of two shape2s
;#####################################################
;defmethod( unionMinusintersectionShape2s (( shp shape2 ) arg)
;	   leXor(shp->ref shp->ref arg)
;);defmethod

;#####################################################
; Fiter out redundant adjacent vertexes
;#####################################################
;defmethod( filter (( shp shape2 ) )
;	   nil
;);defmethod

;#####################################################
; Determines if two shape2s have collided. the second
; shape2 is arg
;#####################################################
;defmethod( collide (( shp shape2 ) arg)
;  if( null(dbStraddle(shp->ref "text" shp->ref  arg))
;    nil
;  else	       
;    t
;  );if
;);defmethod

;###############################################################################
;###############################################################################
;###############################################################################




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  rectTran.ils: Rectangle transform class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( rectTran (cadObj)
	  (
		( ur )
		( ll )
		( width )
		( height )
		( transformation )			  
	  )
) ; defClass

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constructor method
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj rectTran)) 
	   obj->ur = makeInstance( 'point2 )
	   obj->ll = makeInstance( 'point2 )
	   obj->width = nil
	   obj->height = nil
	   obj->transformation = makeInstance( 'transformation2 )
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Calculates the centroid of the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( calculateCentroid (( rt rectTran ))
  let( (urx ury llx lly xval yval)
    urx = xCoord(getUpperRight(rt)) 
    ury = yCoord(getUpperRight(rt))
    llx = xCoord(getLowerLeft(rt)) 
    lly = yCoord(getLowerLeft(rt))
    xval = (urx+llx)/2
    yval = (ury+lly)/2 
    setCentroid(rt->transformation list(xval yval))
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Checks if the rectTran is centered at that origin
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( isCentered (( rt rectTran ))
  if( abs(xCoord(getCentroid(rt->transformation))) < 1e-6 && abs(yCoord(getCentroid(rt->transformation))) < 1e-6 then
    t
  else
    nil
  );if
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Centers the rectTran about the origin
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( center (( rt rectTran ))
  let( (cx cy)
    if( !isCentered(rt) then
      translate(rt -1*xCoord(getCentroid(rt->transformation)))
      setLowerLeft(rt -1*yCoord(getCentroid(rt->transformation)))
      setCentroid(rt->transformation list(0.0 0.0))
    );if
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set Upper Right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( setUpperRight (( rt rectTran ) arg )
  setCoord(rt->ur arg)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get Upper Right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getUpperRight (( rt rectTran ))
  getCoord(rt->ur)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set Upper Right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( setLowerLeft (( rt rectTran ) arg )
  setCoord(rt->ll arg)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get Upper Right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getLowerLeft (( rt rectTran ))
  getCoord(rt->ll)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; sets the centroid of the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( setCentroid (( rt rectTran ) arg)
  setCentroid(rt->transformation arg)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; gets the centroid of the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getCentroid (( rt rectTran ))
  getCentroid(rt->transformation)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Zeros out the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( zero (( rt rectTran ))
  setCentroid(rt list(0.0 0.0))
  setUpperRight(rt list(0.0 0.0))
  setLowerLeft(rt list(0.0 0.0))
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clone the current rectTran to the input recTran argument
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( clone (( rt rectTran ) arg)
  if( classp(arg 'rectTran) then
    println("INFO(rectran): Cloning a rectTran")
    setUpperRight(rt getUpperRight(arg))
    setLowerLeft(rt getLowerLeft(arg))
    setCentroid(rt getCentroid(arg))
  else
    println("ERROR(rectTran): recTran object argument required")
  );
);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Area of recTran - rectTran must be centered about origin
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( area (( rt rectTran ))
  if( isCentered(rt) then
    (xCoord(getUpperRight(rt))-xCoord(getLowerLeft(rt))*(yCoord(getUpperRight(rt))-yCoord(getLowerLeft(rt))))
  else
    println("ERROR(rectTran): rectTran is not centered at origin")
  );if
);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method translates the recTran about its centroid
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( translate (( rt rectTran ) arg )
  let( (urx ury llx lly)
	urx = xCoord(getUpperRight(rt)) + xCoord(arg)
        ury = yCoord(getUpperRight(rt)) + yCoord(arg)
	llx = xCoord(getLowerLeft(rt))  + xCoord(arg)
	lly = yCoord(getLowerLeft(rt))  + yCoord(arg)
	setUpperRight(rt list(urx ury))
	setLowerLeft(rt list(llx lly))
	calculateCentroid(rt)
	;setCentroid(rt list( xCoord(getCentroid(rt))+xCoord(arg) yCoord(getCentroid(rt))+yCoord(arg)))
  );let 
);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Get the vertices from the rectTran
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( getVertices (( rt rectTran ))
  let( (v0 v1 v2 v3 v4)
    ;ll
    v0 = getLowerLeft(rt)
    ;lr
    v1 = list( -xCoord(getLowerLeft(rt)) yCoord(getLowerLeft(rt)) )
    ;ur
    v2 = getUpperRight(rt)
    ;ul
    v3 = list( -xCoord(getUpperRight(rt)) yCoord(getUpperRight(rt)) )
    ;ll (closes the polygon)
    v4 = v0
    list(v0 v1 v2 v3 v4)  
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method rotates the rectTran about its centroid
; The rectran's centroid must be centered at origin
; for this to work properly
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( rotate (( rt rectTran ) arg )
  let( (poly)
      poly = makeInstance( 'polygon2)
      setVertices(poly getVertices(rt))
      rotate(poly arg)
      setRectTran(poly)
      setUpperRight(rt getUpperRight(poly->rtran))
      setLowerLeft(rt getLowerLeft(poly->rtran))	
  );let
);defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method scales the rectTran about its centroid
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( scale (( rt rectTran ) arg)
;	nil
;);defMethod

;###############################################################################
; render the rectTran
;###############################################################################
defmethod( render (( rt rectTran ))
  if( !null(getUpperRight(rt)) && !null(getLowerLeft(rt)) then
        println("INFO(rectTran): Rendering")
        dbCreateRect(rt->ref
	     	     list(rt->layer rt->purpose)
		     list(getLowerLeft(rt) getUpperRight(rt))
        );dbCreateRect
  else
    println("ERROR(recTran): No UpperRight or LowerLeft Coordinate")
  );if   
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method returns the smallest bounding rectangle composed of the
; current bounding rectangle and the bounding rectangle of the input 
; rectTran argument
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( union (( rt rectTran ) arg)
 let( ( maxx minx maxy miny )
    if( classp(arg 'rectTran) then
      println("INFO(rectran): Performing the union of two rectTrans")
      maxx =  max(xCoord(getUpperRight(rt)) xCoord(getUpperRight(arg)))
      minx =  min(xCoord(getLowerLeft(rt))  xCoord(getLowerLeft(arg)))
      maxy =  max(yCoord(getUpperRight(rt)) yCoord(getUpperRight(arg)))
      miny =  min(yCoord(getLowerLeft(rt))  yCoord(getLowerLeft(arg)))
      setUpperRight(rt list(maxx maxy))
      setLowerLeft(rt list(minx miny))
    else
      println("ERROR(recTran): Rectran object argument required")
    );if  
  );let
);defMethod


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FIXME: the methods below should be part of a "rectTrans" class that
;        operates on a collection of rectTran objects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method returns the intersection of two class box's object and a 
; list of bboxs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;defmethod( intersection (( bb bbox ) box)
;  let( (llxList llyList urxList uryList maxllx maxlly minurx minury )
;       llxList = foreach(mapcar bb->bbox box xCoord( lowerLeft( bb->bbox )))
;       llyList = foreach(mapcar bb->bbox box yCoord( lowerLeft( bb->bbox )))
;       urxList = foreach(mapcar bb->bbox box xCoord( upperRight( bb->bbox )))
;       uryList = foreach(mapcar bb->bbox box yCoord( upperRight( bb->bbox )))
;       minurx = apply( 'min urxList )
;       minury = apply( 'min uryList )
;       maxllx = apply( 'max llxList )
;       maxlly = apply( 'max llyList )
;       cond(
;		( maxllx >= minurx 
;	  	  nil
;		);maxllx
;		( maxlly >= minury 
;	  	  nil
;		);maxlly
;		( t
;	  	  list(maxllx:maxlly minurx:minury)
;		);t
; 	);cond
;  );let
;);defmethod
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts The bbox Origin To the Upper Right Quadrant of the 
; cellviews master grid field
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( shiftURQ (( bb bbox ))
;  let( ( shift dx dy) 
;	  getbBox(bb)
;	  unless( caar( bb->bbox) == 0 && cadar( bb->bbox) == 0
;		  dx = 0 - bb->origin->x
;     		  dy = 0 - bb->origin->y
;      		  shift = list( list( dx dy) "R0")
;      		  printf( "NOTE:  shifting %s to upper-right quadrant" name)
;      		  printf( "       shift is: %f by %f" caar( shift) cadar( shift))
;		  dbReopen( bb->cvRef "a")
;		  foreach( inst cvRef~>instances dbMoveFig( inst bb->cvRef shift))
;    		  foreach( shape cvRef~>shapes   dbMoveFig( shape bb->cvRef shift))
;      		  dbSave(bb->cvRef)
;		  dbClose(bb->cvRef)
;	  );unless
;	  getbBox(bb)
;  );let
;);defMethod	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts bbox Origin by provided dx and dy values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( setCentroid (( bb bbox ) arg)
;  let( ( sx sy )	
;  );let
;) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This Method Shifts cellview bbox Origin by provided dx and dy values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 	 
;defmethod( shiftCentroidCellView (( bb bbox ) dx dy)
;	let( ( (name bb->cellName)
;		   (lib  bb->library)
;		   shift
;		   sx
;                  sy
;		   cvRef )
;		getbBox(bb)
;		cvRef = dbOpenCellViewByType( lib name "layout" "maskLayout")
;		sx = bb->x0 + dx
;      	sy = bb->y0 + dy
;      	shift = list( list( sx sy) "R0")
;		dbReopen( cvRef "a")
;		foreach( inst cvRef~>instances dbMoveFig( inst cvRef shift))
;    	foreach( shape cvRef~>shapes   dbMoveFig( shape cvRef shift))
;      	dbSave(cvRef)
;		dbClose(cvRef)
;		getbBox(bb)
;		)
;) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  rectTrans.ils: container class for rectTran 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( rectTrans (cadObj)
	  (
		( rtrans @reader getRtrans )
		( rtran @reader getRectTran )		  
	  )
) ; defclass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj rectTrans)) 
  obj->rtrans = makeInstance( 'collection )
  obj->rtran = makeInstance( 'rectTran )
);defmethod

;#####################################################
; Add rectTran object to rectTrans collection
;#####################################################
defmethod( rtsAdd ((rts rectTrans) arg) 
  if(classp( arg 'rectTran) then
    add(rts->rtrans arg)
  else
    println("ERROR(rectTrans): Argument is not a rectTran object")
  );if
);defmethod

;#####################################################
; Generate the rectTran union of all the transforms
; in the  geometry
;#####################################################
defmethod( rtsUnion (( rts rectTrans ))
  zero(rts->rtran)
  foreach( rt getCollection(rts->rtrans)
    union(rts->rtran rt)
  ) 
  calculateCentroid(rts->rtran)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Translates a rectran and rectrans
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( translate (( rts rectTrans ) arg)
  foreach(rtrn getCollection(rts->rtrans)
    translate(rtrn arg)
  );foreach
  translate(rts->rtran arg)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  transform2: Generic Point Class 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( transform2 (cadObj)
	  (
	    ( polygon )
	    ( vertices @reader getVertices)
	    ( area )
	    ( transformation )
	    ( rtran @reader getRectTran)
	  )				  
) ; defclass

;#####################################################
; Constructor method
;#####################################################
defmethod( initializeInstance @after ((obj transform2))
	   obj->polygon = makeInstance( 'polygon2 ) 
	   obj->vertices = makeInstance( 'points2 )
	   obj->area=nil
	   obj->transformation = makeInstance( 'transformation2 )
	   obj->rtran = makeInstance( 'rectTran )
);defmethod

;#####################################################
; sets up the polygon "component" of the transform2 object 
;#####################################################
defmethod( addPolygon (( tran transform2 ) arg)
  if( classp(arg 'polygon2) then
    setVertices(tran getVertices(arg))
    setCentroid(tran getCentroid(arg))
  else
    println("ERROR(transform2): argument is not a polygon.")
  );if
);defmethod

;#####################################################
; Creates a collection of vertex objects from an input
; vertex simple list argument
;#####################################################
defmethod( setVertices (( tran transform2 ) arg)
  let( (p2)
    setVertices(tran->polygon arg)
    setRectTran(tran->polygon)
    foreach(vert arg
      p2 = makeInstance( 'point2 )
      setCoord(p2 vert)
      appendPoint(tran->vertices p2)
    );foreach
    setCentroid(tran->transformation getCoord(tran->polygon->centroid))
    setScale(tran->transformation 1.0)
    setTheta(tran->transformation 0.0)
    cloneRectTran(tran)
    t
  );let
);defmethod

;#####################################################
; Clones the polygons's rectTran into the transform2's
; recTran. Use this to "reset" the recTran when 
; transform2's transformation is reset.
;#####################################################
defmethod( cloneRectTran (( tran transform2 ))
  clone(tran->rtran getRectTran(tran->polygon))
);defmethod

;###############################################################################
; render the transform
;###############################################################################
defmethod( render (( tran transform2 ))
  let( (verts)
    verts = '()
    if( !null(tran->ref) then
      if( !isEmpty(tran->vertices->points) then
        foreach( point getCollection(tran->vertices->points)
	  verts = cons(getCoord(point) verts)
        );foreach
        println("INFO(transform2): Rendering Transform")
        dbCreatePolygon(tran->ref
	     	        list(tran->layer tran->purpose)
		        verts
	);dbCreatePolygon
      else
        println("ERROR(transform2): No vertices to render")
      );if
    else
        println("ERROR(transform2): Layout cellview reference not set")
    );if
  );let   
);defmethod

;#####################################################
; This method translates the position of each transform
; vertex by the point value argument "list(x y)" 
;#####################################################
defmethod( translate (( tran transform2 ) arg)
  let( (centroid)
    if( listp(arg) then
      translate(tran->vertices arg)
      centroid = getCentroid(tran->transformation)
      setCentroid(tran->transformation list(xCoord(centroid)+xCoord(arg) yCoord(centroid)+yCoord(arg)))
      translate(tran->rtran arg)
    else
      println("ERROR(transform2): list argument required")
    );if
  );let	   
);defmethod

;#####################################################
; This method translates the position of each transform
; vertex by the point value argument "list(x y)" 
;#####################################################
defmethod( scale (( tran transform2 ) arg)
  scale(tran->vertices arg)
  setScale(tran->transformation arg*getScale(tran->transformation))	   
);defmethod

;#####################################################
; This method translates the position of each transform
; vertex by the point value argument "list(x y)" 
;#####################################################
defmethod( isCentered (( tran transform2 ))
  isCentered(tran->rtran)	   
);defmethod


;#####################################################
; This method centers the transform based upon its
; rectTran center
;#####################################################
defmethod( center (( tran transform2 ))
  let( (rtcent)
    if( !isCentered(tran->rtran) then
      rtcent = getCentroid(tran->rtran)
      translate(tran list( -xCoord(rtcent) -yCoord(rtcent)))
    else
      t
    );if
  );let	   
);defmethod


;###############################################################################
; Note A: A local rotation requires that the transforms centroid be translated
;         to origin. Global rotations do not need the tranlation to origin
; Note B: positive angles = counter clockwise in according to 
; the "right handedness" convention.
;###############################################################################
defmethod( rotate (( tran transform2 ) arg)
      rotate(tran->vertices arg)	   
);defmethod

;###############################################################################
; Get centroid of transform
;###############################################################################
defmethod( getCentroid (( tran transform2 ))
  getCoord(tran->transformation->centroid)
)

;###############################################################################
; Set centroid of transform
;###############################################################################
defmethod( setCentroid (( tran transform2 ) arg)
  setCoord(tran->transformation->centroid arg)
)	  
	  
;###############################################################################
;###############################################################################
;###############################################################################;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Transformation2: Class representing the transformation of any
;;  2-D geometry
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( transformation2 ()
	  (
	    ( centroid @reader centroid)
	    ( absRotation @reader absRotation)
	    ( relRotation @reader relRotation)
	    ( scale @reader getScale @writer setScale)
	  )				  
) ; defclass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj transformation2)) 
  obj->centroid = makeInstance( 'point2 )
  obj->absRotation = makeInstance( 'rotation2 )
  obj->relRotation = makeInstance( 'rotation2 )
  obj->scale = nil
);defmethod

;#####################################################
; sets the centroid of the transformation
;#####################################################
defmethod( setCentroid (( tr2 transformation2 ) arg)
  if(listp(arg) then
    setCoord(tr2->centroid arg)
  else
    println("ERROR(transformation2): Expecting list argument")
  );if	   
);defmethod

;#####################################################
; gets the centroid of the transformation
;#####################################################
defmethod( getCentroid (( tr2 transformation2 ))
  getCoord(tr2->centroid)	   
);defmethod

;#####################################################
; returns the radius from origin to the centroid
; (normally this is zero representing the base 
;  transform)
;#####################################################
defmethod( getRadius (( tr2 transformation2 ))
  getRadius(tr2->relRotation)	   
);defmethod

;#####################################################
; sets the angle of rotation (relative rotation)
; of the CAD object 
;#####################################################
defmethod( setTheta (( tr2 transformation2 ) arg)
  setTheta(tr2->relRotation arg)	   
);defmethod

;#####################################################
; returns the angle of rotation (relative rotation)
; of the CAD object 
;#####################################################
defmethod( getTheta (( tr2 transformation2 ))
  getTheta(tr2->relRotation)	   
);defmethod

;#####################################################
; returns the radius from origin to the centroid
;#####################################################
defmethod( getRadiusToCentroid (( tr2 transformation2 ))
  getRadius(tr2->absRotation)	   
);defmethod

;#####################################################
; returns the angle of rotation about the 
;#####################################################
defmethod( getThetaToCentroid (( tr2 transformation2 ))
  getTheta(tr2->absRotation)	   
);defmethod

;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  geometry.ils: container class which holds a group
;                of polygon transforms.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( geometry ()
	  (
		( transforms )	
		( centroid )
		( rtran @reader getRectTran )
		( ref @reader getRef @writer setRef )		  
	  )
) ; defClass

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constructor
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( initializeInstance @after ((obj geometry)) 
	   obj->transforms = makeInstance( 'collection )
	   obj->centroid = makeInstance( 'point2 )
	   obj->rtran = makeInstance( 'rectTran )
	   obj->ref = nil
);defmethod

;#####################################################
; Generate the rectTran union of all the transforms
; in the  geometry
;#####################################################
defmethod( rectTranUnion (( geom geometry ))
  zero(geom->rtran)
  foreach( trans getCollection(geom->transforms)
    union(geom->rtran getRectTran(trans))
  ) 
  calculateCentroid(geom->rtran)
);defmethod

;#####################################################
; Sets the centroid of the geometry
;#####################################################
defmethod( setCentroid (( geom geometry ) arg)
  setCoord(geom->centroid arg)
);defmethod

;#####################################################
; Gets the centroid of the geometry
;#####################################################
defmethod( getCentroid (( geom geometry ))
  getCoord(geom->centroid)
);defmethod

;#####################################################
; Sets the layer of the geometry
;#####################################################
defmethod( setLayer (( geom geometry ) arg)
  if( !isEmpty(geom->transforms) then
    foreach( trans getCollection(geom->transforms)
;      println("INFO(geometry): Changing transform Layer")
      setLayer(trans arg)
    );foreach
  else
    println("ERROR(geometry): Empty transform collection")
  );if
);

;#####################################################
; Sets the purpose of the geometry 
;#####################################################
defmethod( setPurpose (( geom geometry ) arg)
  foreach( trans getCollection(geom->transforms)
    setPurpose(trans arg)
  )
);

;#####################################################
; Add transform to transforms collection
;#####################################################
defmethod( addTransform (( geom geometry ) arg)
  if( classp( arg 'transform2) then
    add(geom->transforms arg)
  else
    println("ERROR(geometry): Argument must be a transform object")
  );if
);defmethod


;#####################################################
; Center the geometry based upon the geometry's 
; rectTran centroid
;#####################################################
defmethod( isCentered (( geom geometry ))
  isCentered(geom->rtran)
);defmethod

;#####################################################
; Center the geometry based upon the geometry's 
; rectTran centroid
;#####################################################
defmethod( center (( geom geometry ))
  let( (tval)
    if( !isCentered(geom) then
      tval = list( -xCoord(getCentroid(geom->rtran)) -yCoord(getCentroid(geom->rtran)))
      setCentroid(geom list(0.0 0.0))
      translate(geom->rtran tval)
      translate(geom tval)
    else
      t
    );if
  );let  
);defmethod

;#####################################################
; translate the geometry
;#####################################################
defmethod( translate (( geom geometry ) arg)
  foreach(tran getCollection(geom->transforms)
    translate(tran arg)
  );  
);defmethod

;#####################################################
; rotate the geometry
;#####################################################
defmethod( rotate (( geom geometry ) arg)
  let( (tcent)
    foreach(tran getCollection(geom->transforms)
      rotate(tran arg)
    );foreach
    rotate(geom->rtran arg)
  );let
);defmethod

;#####################################################
; scale the geometry
;#####################################################
defmethod( scale (( geom geometry ) arg)
 nil	  
);defmethod

;#####################################################
; render the geometry
;#####################################################
defmethod( render (( geom geometry ) )
  foreach( trans getCollection(geom->transforms)
    if( classp(trans 'transform2) then
      setRef(trans geom->ref)
      render(trans)
    else
      printf("ERROR(geometry): Render object must be a transform2")
    );if
  )	  
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;######################################################
;# edge2.ils: Polygon edge Class inheriting from line class
;######################################################
defclass( assembly ()
	  (
	     ( geometries @reader getGeometryCollection )
	     ( layers @reader getLayerCollection )
	     ( ref @reader getRef @writer setRef )
	     ( rtrans )
	  )				  
);defclass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj assembly)) 
	   obj->geometries = makeInstance( 'collection )
	   obj->ref = nil
	   obj->layers = makeInstance( 'collection )
	   obj->rtrans = makeInstance( 'rectTrans )
);defmethod

;#####################################################
; Gets a list of layer objects in the assembly
;#####################################################
defmethod( getRectTran (( ass assembly ))
  getRectTran(ass->rtrans)
);defmethod

;#####################################################
; Gets a list of layer objects in the assembly
;#####################################################
defmethod( getLayers (( ass assembly ))
  ass->layers->list
);defmethod

;#####################################################
; Adds shapes to the assembly via the shapes container. 
;#####################################################
defmethod( addGeometry (( ass assembly ) arg )
  if( !null(arg) then
    if( classp(arg 'geometry) then
      add(ass->geometries arg)
      t
    else
      println("ERROR(assembly): Only geometry objects can be added")
      nil
    );if
  else
    println("ERROR(assembly): Cannot add null shape")	       
    nil
  );if
);defmethod

;#####################################################
; Adds shapes to the assembly via the shapes container. 
;#####################################################
defmethod( resetLayers (( ass assembly ))
  resetCollection(ass->layers)
);defmethod

;#####################################################
; Creates the layers in the layer stackup needed to 
; render the shape
;#####################################################
defmethod( setShapesOnLayers (( ass assembly ))
  let( (temp)
    if( !null(ass->shapes->list->elems) then
      foreach( shape ass->shapes->list->elems
      	printf("INFO(Assembly): Processing shape on layer %s\n" getLayer(shape))
	if( !null(ass->layers->list->elems) then
          foreach( layer ass->layers->list->elems
	    printf("INFO(Assembly): Finding layer %s in list\n" getName(layer))
            if(getName(layer) == getLayer(shape) then
	      printf("INFO(Assembly): Layer %s found - Adding shape to layer\n" getLayer(shape))	
	      addShape(layer shape)
	    else
	      printf("INFO(Assembly): Adding shape to new layer %s\n" getName(layer))
              temp = makeInstance( 'techLayer )
    	      setName(temp getLayer(shape))
	      addShape(temp shape)
	      add(ass->layers temp)
	    );if
          );foreach
        else
	  printf("INFO(Assembly): Adding shape to new layer %s (first layer in assembly layer collection)\n" getLayer(shape))
	  temp = makeInstance( 'techLayer )
    	  setName(temp getLayer(shape))
	  addShape(temp shape)
	  add(ass->layers temp)
	);if
      );foreach
      t
    else
      printf("ERROR(Assembly): Shape collection is null\n")
      nil	       
    );if
  );let
);defmethod

;#####################################################
; Renders the layer stackup consisting of the layer
; shapes of the assembly
;#####################################################
defmethod( renderAssembly (( ass assembly ))
  if( !null(arg) then
    setLayers(ass)
    setShapesOnLayers(ass)
    renderStack(ass)
  else
    printf("ERROR: Cannot add null shape" )	       
    t
  );if
);defmethod

;#####################################################
; Translates the assembly
;#####################################################
defmethod( translate (( ass assembly ) arg )
  if(listp(arg) then
    println("INFO:(assembly): translating assembly geometries")
    foreach( geom getCollection(ass->geometries)
      translate(geom arg)
    );foreach
    translate(ass->rtrans arg)
  else
    println("ERROR(assembly): requires a list argument")   
  );if
);defmethod

;#####################################################
; Rotate the assembly
;#####################################################
defmethod( rotate (( ass assembly ) arg )
  foreach( geom getCollection(ass->geometries)
      rotate(geom arg)
    );foreach
    rotate(geom->rtran arg)
);defmethod

;#####################################################
; Renders the layer stackup consisting of the layer
; shapes of the assembly
;#####################################################
defmethod( render (( ass assembly ))
  if( !isEmpty(ass->geometries) then
    foreach( geom getCollection(ass->geometries)
      if( classp(geom 'geometry) then
        setRef(geom getRef(ass))
        render(geom)
      else
        println("ERROR(assembly): Render object must be a geometry")
      );if
    );foreach
  else
    println("ERROR(assembly): Empty geometry collection")
  );if
);defmethod

;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; collection.ils: object collection class. Collections are
;                  lists of objects that can be homegeneous or homogeneous object
;                  lists
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Program SKILL Lint finished on Sep 13 14:51:51 2017 with status PASS.
;IQ score is 100 (best is 100).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( collection (cadObj)
	  (
		( n @reader getN @writer setN )
		( list @reader getList @writer setList )
		( cList )		  
	  )
);defclass

;############################################################
; Class Constructor 
;#############################################################
defmethod( initializeInstance @after ((obj collection)) 
	   obj->n = 1
           obj->list = makeInstance( 'listfun )
	   obj->cList = '()
	   obj->cid="col"
	   obj->oid=""
);defmethod



;############################################################
; Resets the collection list to empty list
;#############################################################
defmethod( resetCollection ((col collection))
       resetList(col->list)
);defmethod

;############################################################
; Returns a reference to the collection list
;#############################################################
defmethod( getCollection ((col collection))
       col->list->elems
);defmethod

;############################################################
; Creates a list of N (objNum) unpopulated lib objects 
; in sequential order 
;#############################################################
defmethod( genCollection ((col collection) arg)
       for( i 0 sub1(col->n)
       	  lappendBeg(col->list makeInstance(stringToSymbol(arg)))
       );for
);defmethod

;############################################################
; Generate a listing of the class the objects belong to in
; the collection
;#############################################################
defmethod( class ((col collection))
  let( (i)
    i=0
    col->cList = '()
    foreach( obs getElems(col->list)
      col->cList = cons(classOf(obs) col->cList) 
      printf("%L\n" classOf(obs)) 
      i++   	  
    );foreach
  );let
);defmethod

;############################################################
; Add and object to the collection's list
;#############################################################
defmethod( add ((col collection) arg)
   addTail(col->list arg)
);defmethod

;############################################################
; Is collection list empty
;#############################################################
defmethod( isEmpty ((col collection))
    null(col->list->elems)
);defmethod


;############################################################
; Creates a list of N (objNum) unpopulated lib objects 
; in sequential order 
;#############################################################
;defmethod( genCon ((cont collection) obj)
;  let( (  vName
;	  estrng )
;       for( i 0 sub1(cont->num)
;	  sprintf(vName "obj%d" i)
;	  sprintf(estrng strcat(vName "=makeInstance( '" obj->cid " )"))
;	  evalstring(estrng)
;	  sprintf(estrng strcat(obj->cid "->objList=cons(" vName " " obj->cid "->objList)"))
;	  evalstring(estrng)
;       );for
;     );let
;);defmethod

;############################################################
; Adds an object to the container list 
; FIXME: WIP!
;#############################################################
;defmethod( add ((obj collection))
;  let( (  vName
;	  estrng 
;;	  i)
;	  sprintf(estrng strcat("i = length(" obj->cid "->objList"))
;	  evalstring(estrng)
;	  sprintf(vName "obj%d" i)
;	  sprintf(estrng strcat(vName "=makeInstance( '" obj->cid " )"))
;	  evalstring(estrng)
;	  sprintf(estrng strcat(obj->cid "->objList=cons(" vName " " obj->cid "->objList)"))
;	  evalstring(estrng)
;	  obj->objNum=obj->objNum+1
;     );let
;);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;######################################################
;# rectangle.ils: Rectangle class
;######################################################
defclass( rectangle (polygon2)
	  (
		( width @reader getWidth @writer setWidth )
		( height @reader getHeight @writer setHeight )
	  )				  
) ; defclass

;######################################################
;# Constructor
;######################################################
defmethod( initializeInstance @after ((obj rectangle)) 
	   obj->width  = 1.0
           obj->height = 1.0
);defmethod

;######################################################
;######################################################
defmethod( generate (( rect rectangle ))
  let( ( vertices )
	   vertices = '()
	   ;ll
	   vertices = cons(list(-abs(rect->width)/2 -abs(rect->height)/2) vertices)
	   ;lr
	   vertices = cons(list( abs(rect->width)/2 -abs(rect->height)/2) vertices)
	   ;ur
	   vertices = cons(list( abs(rect->width)/2  abs(rect->height)/2) vertices)
	   ;ul
	   vertices = cons(list(-abs(rect->width)/2  abs(rect->height)/2) vertices)
	   ;ll (again to close the polygon)
	   vertices = cons(list(-abs(rect->width)/2 -abs(rect->height/2)) vertices)
	   vertice = reverse(vertices)
	   setVertices(rect reverse(vertices))
	   setCentroid(rect list(0.0 0.0))
	   setRectTran(rect)
	   getCentroid(rect)
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method chamfers the upper right and left corners
; of the rectangle
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( chamfer (( rect rectangle ) arg)
  let( (ur nur0 nur1 ul nul0 nul1 xd newVertices)
    ur = nth(2 getVertices(rect))
    ul = nth(3 getVertices(rect))
    xd = abs(xCoord(ul))+abs(xCoord(ur))-2*abs(arg)
    if( xd >= 0.0 then
      nur0 = list( xCoord(ur)     yCoord(ur)-arg)
      nur1 = list( xCoord(ur)-arg yCoord(ur))
      nul0 = list( xCoord(ul)+arg yCoord(ul))
      nul1 = list( xCoord(ul)     yCoord(ul)-arg)
      newVertices = '()
      ;ll (same)
      newVertices = cons(list(-rect->width/2 -rect->height/2) newVertices)
      ;lr (same )
      newVertices = cons(list( rect->width/2 -rect->height/2) newVertices)
      ;;;;;;;;;;;;;;;;;;;;;;
      ;chamfered ur start
      ;;;;;;;;;;;;;;;;;;;;;;
      ;nur0
      newVertices = cons(nur0 newVertices)
      ;nur1
      newVertices = cons(nur1 newVertices)
      ;;;;;;;;;;;;;;;;;;;
      ;chamfered ur end 
      ;;;;;;;;;;;;;;;;;;;
      ;ur (deleted)
      ;newVertices = cons(list( rect->width/2  rect->height/2) newVertices)
      ;;;;;;;;;;;;;;;;;;;;;;
      ;chamfered ul start
      ;;;;;;;;;;;;;;;;;;;;;;
      ;nul0
      newVertices = cons(nul0 newVertices)
      ;nul1
      newVertices = cons(nul1 newVertices)
      ;;;;;;;;;;;;;;;;;;;
      ;chamfered ul end 
      ;;;;;;;;;;;;;;;;;;;
      ;ul (deleted)
      ;newVertices = cons(list(-rect->width/2  rect->height/2) newVertices)
      ;ll (same)
      newVertices = cons(list(-rect->width/2 -rect->height/2) newVertices)
      setVertices(rect newVertices) 
    else
      println("ERROR(rectangle): Intersecting chamfers - operation aborted")
    );if
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method tapers the rigtht side of the rectangle
; using chamferUr and chamferLr above.
; Fixme: A square that is chamfered becomes a triangle
;        which could take the place of the triangle class
;        (centroid remains the same)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( taperLeft (( rect rectangle ) )
  nil
);defmethod



;######################################################
;######################################################
;######################################################
defclass( triangle (polygon2)
	  (
		( base @reader getBase @writer setBase )
		( height @reader getHeight @writer setHeight )
	  )				  
) ; defclass

;######################################################
;
;######################################################
defmethod( initializeInstance @after ((obj triangle)) 
	   obj->base  = 1.0
           obj->height = 1.0
);defmethod

;######################################################
;######################################################
defmethod( generate (( tri triangle ))
  let( (vertices)
	   vertices = '()
	   vertices = cons(list(-tri->base/2 -tri->height/2) vertices)
	   vertices = cons(list( tri->base/2 -tri->height/2) vertices)
	   vertices = cons(list( 0            tri->height/2) vertices)
	   vertices = cons(list(-tri->base/2 -tri->height/2) vertices)
	   setVertices(tri vertices)
	   setCentroid(tri list(0.0 0.0))
	   setRectTran(tri)
	   getCentroid(tri)
  );let
);defmethod
;######################################################
;######################################################
;######################################################
;######################################################
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  circle.ils: On Grid Circle Generator Object based upon CORDIC 
;              vector rotation algorithm.
;              Note: All centroids for subset circles (half, quarter, etc.)
;              are defined to have the same centroid as the original
;              circle
;
;              FIXME: for large diameter circtles need to break the polygons into
;                     a group of segments that are some maximum number of vertices
;                     (maximimum is 2048 for the Cadence rendering). Circle will
;                     have to inherit from geometry rather than polygon2 and 
;                     contain a number of circle transforms ...
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( circle (polygon2)
	  (
		( radius @writer setRadius )
		( orig @writer setOrig @reader getOrig)
		( origin @writer setOrigin @reader getOrigin)
		( area @reader getArea)
		( direction )
		( X )
		( Y )
		( grid )
		( id )			  
	  )
) ; defClass

defmethod( initializeInstance @after ((obj circle)) 
	   obj->radius = 1.0
	   obj->orig = list(0.0 0.0)
	   obj->origin = list(0.0 0.0)
	   obj->X = 0.0
           obj->Y = 0.0
	   obj->grid = 0.025
	   obj->direction = 0
	   obj->id="cir"
);defmethod

defmethod( genNextVertex ((cir circle))
  let( ( (grid cir->grid)
         X0 Y0 R0 D0 X1 Y1 R1 D1 X2 Y2 R2 D2 X3 Y3 R3 D3 
         X4 Y4 R4 D4 X5 Y5 R5 D5 X6 Y6 R6 D6 X7 Y7 R7 D7)
 	  if( (cir->direction == 0 || cir->direction == 1 || cir->direction == 7) then
   	     X0 = cir->X + grid
   	     Y0 = cir->Y
	     R0 = (X0**2 + Y0**2)**0.5
	     D0 = abs(R0-cir->radius)
          );if
	  if( (cir->direction ==  1 || cir->direction == 2 || cir->direction == 0) then
	     X1 = cir->X + grid
	     Y1 = cir->Y - grid
	     R1 = (X1**2 + Y1**2)**0.5
	     D1 = abs(R1-cir->radius)
	  );if
	  if( (cir->direction ==  2 || cir->direction == 3 || cir->direction == 1) then
	     X2 = cir->X
	     Y2 = cir->Y - grid
	     R2 = (X2**2 + Y2**2)**0.5
	     D2 = abs(R2-cir->radius)
	  );if
	  if( (cir->direction == 3 || cir->direction == 4 || cir->direction == 2) then
	     X3 = cir->X - grid
   	     Y3 = cir->Y - grid
	     R3 = (X3**2 + Y3**2)**0.5
	     D3 = abs(R3-cir->radius)
 	  );if
	  if( (cir->direction == 4 || cir->direction == 5 || cir->direction == 3) then
	     X4 = cir->X - grid
	     Y4 = cir->Y
	     R4 = (X4**2 + Y4**2)**0.5
	     D4 = abs(R4-cir->radius)
	  );if
	  if( (cir->direction == 5 || cir->direction == 6 || cir->direction == 4) then
	     X5 = cir->X - grid
	     Y5 = cir->Y + grid
	     R5 = (X5**2 + Y5**2)**0.5
	     D5 = abs(R5-cir->radius)
	  );if
	  if( (cir->direction == 6 || cir->direction == 7 || cir->direction == 5) then
	     X6 = cir->X
	     Y6 = cir->Y + grid
	     R6 = (X6**2 + Y6**2)**0.5
	     D6 = abs(R6-cir->radius)
	  );if
	  if( (cir->direction == 7 || cir->direction == 0 || cir->direction == 6) then
	     X7 = cir->X + grid
	     Y7 = cir->Y + grid
	     R7 = (X7**2 + Y7**2)**0.5
	     D7 = abs(R7-cir->radius)
	  );if
	  caseq( cir->direction
	 	(0
		  ; Possible 7 0 1  
		  if( (D0 < D1 && D0 < D7) then
		    ;Go D0 
		    cir->X = X0
 		    cir->Y = Y0
		    cir->direction= 0
	          else
	            if( (D1 < D0 && D1 < D7) then
	              ; Go D1 
		      cir->X = X1
 		      cir->Y = Y1
		      cir->direction= 1
		    else
		      ; Go D7 
		      cir->X = X7
 		      cir->Y = Y7
		      cir->direction= 7
		    );if
		  );if
	        );0
                (1
		  ; Possible 0 1 2   
		  if( (D1 < D2 && D1 < D0) then
		     ;Go D1 
		     cir->X = X1
 		     cir->Y = Y1
		     cir->direction= 1
		   else
		      if( (D2 < D1 && D2 < D0) then
		        ; Go D2 
			cir->X = X2
 		     	cir->Y = Y2
		     	cir->direction= 2
		       else
		        ; Go D0
			cir->X = X0
 		     	cir->Y = Y0
		     	cir->direction= 0 
		    );if
		  );if
	        );1
                (2
		  ;  Possible 1 2 3
		  if( (D2 < D3 && D2 < D1) then
		    ; Go D2 
		     cir->X = X2
 		     cir->Y = Y2
		     cir->direction= 2 
		  else
		    if( (D3 < D2 && D3 < D1) then
 		       ; Go D3 
		       cir->X = X3
 		       cir->Y = Y3
		       cir->direction= 3 
 		    else
 		       ;Go D1 
		       cir->X = X1
 		       cir->Y = Y1
		       cir->direction= 1 
 		   );if
   		  );if
 	       	);2
                (3
 	          ;Possible 2 3 4 
		  if( (D3 < D4 && D3 < D2) then
   		    ;Go D3 
		    cir->X = X3
 		    cir->Y = Y3
		    cir->direction= 3 
   		   else
		     if( (D4 < D3 && D4 < D2) then
 		       ; Go D4 
		       cir->X = X4
 		       cir->Y = Y4
		       cir->direction= 4
 		      else
			; Go D2 
			cir->X = X2
 		        cir->Y = Y2
		        cir->direction= 2
 		     );if
   		  );if
 	        );3
   	        (4
		  ; Possible  3 4 5 
 		  (if D4 < D5 && D4 < D3 then
   		    ; Go D4
		     cir->X = X4
 		     cir->Y = Y4
		     cir->direction= 4
   		   else
		     (if D5 < D4 && D5 < D3 then
 		       ; Go D5 
		       cir->X = X5
 		       cir->Y = Y5
		       cir->direction= 5
 		      else
 		       ; Go D3 
		       cir->X = X3
 		       cir->Y = Y3
		       cir->direction= 3
 		     );if
   		   );if
                 );4
	         (5
		   ;Possible 4 5 6 
 		   if( (D5 < D6 && D5 < D4) then
   		     ; Go D5 
		     cir->X = X5
 		     cir->Y = Y5
		     cir->direction= 5
   		    else
   		      if( (D6 < D5 && D6 < D4) then
 		        ; Go D6 
			cir->X = X6
 		        cir->Y = Y6
		        cir->direction= 6
 		      else
 		       ; Go D4
		         cir->X = X4
 		         cir->Y = Y4
		         cir->direction= 4 
		     );if
   		   );if
 	         );5
   	         (6
		   ; Possible  5 6 7 
 		   if( (D6 < D7 && D6 < D5) then
   		     ; Go D6 
		     cir->X = X6
 		     cir->Y = Y6
		     cir->direction= 6
                    else
                      if( (D7 < D6 && D7 < D5) then
 		        ;Go D7 
			cir->X = X7
 		     	cir->Y = Y7
		     	cir->direction= 7
 		      else
		        ;Go D5 
			cir->X = X5
 		     	cir->Y = Y5
		     	cir->direction= 5
 		     );if
   		   );if
	         );6
    	         (7
	           ;Possible 6 7 0 
 		   if( D7 < D0 && D7 < D6 then
   		     ;Go D7 
		     cir->X = X7
 		     cir->Y = Y7
		     cir->direction= 7
   		    else
   		       if( (D0 < D7 && D0 < D6) then
 		         ;Go D0 
			 cir->X = X0
 		    	 cir->Y = Y0
		     	 cir->direction= 0
 		        else
		         ;Go D6
			 cir->X = X6
 		     	 cir->Y = Y6
		     	 cir->direction= 6 
 		       );if
   		    );if
 	         );7
  	   );caseq
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method generates the ON-GRID "circle" vertex list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generate (( cir circle ))
	   let( (count)
	   	;Initialize Members
	   	cir->vertices = '()
           	cir->direction= 0
	   	cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
		cir->X = 0.0
		cir->Y = cir->radius
		cir->orig = list(cir->X cir->Y)
		genNextVertex(cir)
		count = 0
	   	while( !( (abs(cir->X) < (cir->grid)) && (abs((cir->radius)-(cir->Y)) < (cir->grid)) )
	   	        count = count + 1
		 	genNextVertex(cir)
		 	cir->vertices = cons(list(cir->X cir->Y) cir->vertices)	  		      
	   	);while
	   	if( count > 0 then
		    ; add in origin vertex to close circle
		    ;cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
	       	    count
	   	else
		    nil
	   	);if
		; Need to add starting point for algorithms that rely upon
 		; vertice perimeter completion (start vertex = end vertex)
		setCentroid(cir list(0.0 0.0))
		setRectTran(cir)
		calculateCentroid(cir->rtran)
	   );let
) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method generates the ON-GRID "half circle" vertex list
; forming the end shapes of capsules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generateHalfCircle (( cir circle ))
	   let( (count)
	   	;Initialize Members
	   	cir->vertices = '()
           	cir->direction= 0
		cir->vertices = cons(list(0.0 0.0) cir->vertices)
	   	cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
		cir->X = 0.0
		cir->Y = cir->radius
		cir->orig = list(0.0 0.0)
		genNextVertex(cir)
		count = 0
	   	while( !( (abs(cir->X) < (cir->grid)) && ((cir->Y)+cir->radius < (cir->grid)) )
	   	        count = count + 1
		 	genNextVertex(cir)
		 	cir->vertices = cons(list(cir->X cir->Y) cir->vertices)	  		      
	   	);while
	   	if( count > 0 then
		    ; add in origin vertex to close circle
		    cir->vertices = cons(list(0.0 -1*cir->radius) cir->vertices)
;		    cir->vertices = cons(list(0.0 0.0) cir->vertices)
	   	else
		    nil
	   	);if
		; Need to add starting point for algorithms that rely upon
 		; vertice perimeter completion (start vertex = end vertex)
		setCentroid(cir list(0.0 0.0))
		setRectTran(cir)
		calculateCentroid(cir->rtran)
	   );let
) ; defMethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This method generates the ON-GRID "quarter circle" vertex list
; forming a rounded corner or arc polygon
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defmethod( generateQuarterCircle (( cir circle ))
	   let( (count)
	   	;Initialize Members
	   	cir->vertices = '()
           	cir->direction= 0
		cir->vertices = cons(list(0.0 0.0) cir->vertices)
	   	cir->vertices = cons(list(0.0 cir->radius) cir->vertices)
		cir->X = 0.0
		cir->Y = cir->radius
		cir->orig = list(0.0 0.0)
		genNextVertex(cir)
		count = 0
	   	while( !( (abs(cir->X-cir->radius) < (cir->grid)) && (abs(cir->Y) < (cir->grid)) )
	   	        count = count + 1
		 	genNextVertex(cir)
		 	cir->vertices = cons(list(cir->X cir->Y) cir->vertices)	  		      
	   	);while
	   	if( count > 0 then
		    ; add in origin vertex to close circle
		    cir->vertices = cons(list(0.0 0.0) cir->vertices)
	       	    count
	   	else
		    nil
	   	);if
		; Need to add starting point for algorithms that rely upon
 		; vertice perimeter completion (start vertex = end vertex)
		setCentroid(cir list(0.0 0.0))
		setRectTran(cir)
		calculateCentroid(cir->rtran)
	   );let
) ; defMethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;





	
;######################################################
; trirect.ils: Triangle/Rectangle combination geometry class
;              Overall centroid of this geometry is defined
;              as the centroid of the rectangular body (not 
;              the actual centroid, but conveniently defined
;              for translation and rotation purposes)
;######################################################
defclass( trirect (geometry)
   (
	  ( width @reader getWidth @writer setWidth )
	  ( height @reader getHeight @writer setHeight )
   )				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj trirect)) 
	   obj->width  = 1.0
	   obj->height = 1.0 		     
);defmethod

;######################################################
; Generates the trirect geometry
;######################################################
defmethod( generate (( tr trirect ))
  let((body head bodyTran headTran)
    body = makeInstance( 'rectangle )			
    setHeight(body tr->height)
    setWidth(body tr->width)
    generate(body)
    setCentroid(tr getCentroid(body))
    head = makeInstance( 'triangle )
    setBase(head tr->height)
    setHeight(head tr->height)
    generate(head)
    bodyTran = makeInstance( 'transform2 )
    setVertices(bodyTran getVertices(body))
    setCentroid(bodyTran getCentroid(body))
    cloneRectTran(bodyTran)
    headTran = makeInstance( 'transform2 )
    setVertices(headTran getVertices(head))
    setCentroid(headTran getCentroid(head))
    cloneRectTran(headTran)
    rotate(headTran 270.0)
    translate(headTran list((tr->width+tr->height)/2.0 0.0)) 
    addTransform(tr bodyTran)
    addTransform(tr headTran)
    rectTranUnion(tr) 	   
  );let	   
);defmethod
;######################################################
;######################################################
;######################################################;######################################################
; capsule.ils: Capsule geometry class. Inherits from 
;              rectangle and circle objects
;              Centroid of this object is geometric
;              center of mass
;######################################################
defclass( capsule (geometry)
   (
	  ( width @reader getWidth @writer setWidth )
	  ( height @reader getHeight @writer setHeight )
   )				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj capsule))
	   obj->width  = 1.0
	   obj->height = 1.0 	     
);defmethod

;#####################################################
; This method generates the vertices and translation
; of the vertices of the object
;#####################################################
defmethod( generate (( cap capsule ))
  let((body capR capL bodyTran capRTran capLTran)
    ; Body Polygon
    body = makeInstance( 'rectangle )
    setHeight(body cap->height)
    setWidth(body cap->width)
    generate(body)
    setCentroid(cap getCentroid(body))
    ; Body Transform	
    bodyTran = makeInstance( 'transform2 )
    setVertices(bodyTran getVertices(body))
    setCentroid(bodyTran getCentroid(body))
    cloneRectTran(bodyTran)
    ; Right Cap Polygon   
    capR = makeInstance( 'circle )
    setGrid(capR 0.025)
    setRadius(capR cap->height/2.0)
    generateHalfCircle(capR)
    center(capR)
    ; Rigth Cap Transform
    capRTran = makeInstance( 'transform2 )
    setVertices(capRTran getVertices(capR))
    setCentroid(capRTran getCentroid(capR))
    cloneRectTran(capRTran)
    ; Left Cap Polygon
    capL = makeInstance( 'circle )
    setGrid(capL 0.025)
    setRadius(capL cap->height/2.0)
    generateHalfCircle(capL)
    center(capL)
    ; Left Cap Transform
    capLTran = makeInstance( 'transform2 )
    setVertices(capLTran getVertices(capL))
    setCentroid(capLTran getCentroid(capL))
    cloneRectTran(capLTran)
    ; Translations and Rotation of Transforms
    rotate(capLTran 180.0)
    translate(capRTran list((cap->width+cap->height/2.0)/2.0 0.0))
    translate(capLTran list( -(cap->width+cap->height/2.0)/2.0 0.0))
    ; Add Transforms (same layer) to the Geometry (layer group)
    addTransform(cap bodyTran)
    addTransform(cap capLTran)
    addTransform(cap capRTran) 
    rectTranUnion(cap)
  );let	   
);defmethod

;######################################################
;######################################################
;######################################################
;######################################################
;  gatePad.ils: FET gate pad class.
;               Width and height variables are associated
;               with the inner gate pad capsule     
;######################################################
defclass( gatePad (assembly)
   (
	  ( widthInner @reader getWidthInner @writer setWidthInner )
	  ( heightInner @reader getHeightInner @writer setHeightInner )
	  ( widthOutter @reader getWidthOutter @writer setWidthOutter )
	  ( heightOutter @reader getHeightOutter @writer setHeightOutter )
	  ( innerLayer @reader getInnerLayer @writer setInnerLayer )
	  ( innerPurpose @reader getInnerPurpose @writer setInnerPurpose )
	  ( outterLayer @reader getOutterLayer @writer setOutterLayer )
	  ( outterPurpose @reader getOutterPurpose @writer setOutterPurpose )
	  ( bsegLayer @reader getBsegLayer @writer setBsegLayer )
	  ( bsegPurpose @reader getBsegPurpose @writer setBsegPurpose )
	  ( centroid @reader getCentroid @writer setCentroid )
   )				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj gatePad)) 
	   obj->widthInner   = 1.0
	   obj->heightInner  = 1.0
 	   obj->widthOutter  = 1.0
	   obj->heightOutter = 1.1
	   obj->innerLayer = "text"
	   obj->outterLayer = "text"
	   obj->innerPurpose = "drawing"
	   obj->outterPurpose = "drawing"
	   obj->bsegLayer = "text"
	   obj->bsegPurpose = "drawing"
	   obj->centroid = makeInstance( 'point2 )
);defmethod

;######################################################
; Generates the assembly
;######################################################
defmethod( generate (( gp gatePad ))
  capOutter = makeInstance('capsule)
  setWidth(capOutter gp->widthOutter)
  setHeight(capOutter gp->heightOutter)
  generate(capOutter)
  setLayer(capOutter getOutterLayer(gp))
  setPurpose(capOutter getOutterPurpose(gp))
  addGeometry(gp capOutter)
  rtsAdd(gp->rtrans getRectTran(capOutter))
;
  capInner = makeInstance('capsule)
  setWidth(capInner gp->widthInner)
  setHeight(capInner gp->heightInner)
  generate(capInner)
  setLayer(capInner getInnerLayer(gp))
  setPurpose(capInner getInnerPurpose(gp))
  addGeometry(gp capInner)
  rtsAdd(gp->rtrans getRectTran(capInner))
;
  bseg = makeInstance('rectangle)
  setWidth(bseg 2*gp->widthOutter)
  setHeight(bseg 2*gp->heightOutter)
  generate(bseg)
  bsegTran = makeInstance( 'transform2 )
  setVertices(bsegTran getVertices(bseg))
  setCentroid(bsegTran getCentroid(bseg))
  cloneRectTran(bsegTran)
  setLayer(bsegTran getBsegLayer(gp))
  setPurpose(bsegTran getBsegPurpose(gp))
  bsegGeom = makeInstance( 'geometry )
  addTransform(bsegGeom bsegTran)
  rectTranUnion(bsegGeom)
  addGeometry(gp bsegGeom)
  rtsAdd(gp->rtrans getRectTran(bsegGeom))
  rtsUnion(gp->rtrans)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;######################################################
; gateStem.ils: Capsule geometry class. Inherits from 
;               rectangle and circle objects
;               Centroid is defined as the center of 
;               mass of the body of the gateStem taper
;######################################################
defclass( gateStem (assembly)
   (
	  ( width @reader getWidth @writer setWidth )
	  ( length  @reader getLength @writer setLength )	  
	  ( widthTaper @reader getWidthTaper @writer setWidthTaper )
	  ( centroid @reader getCentroid @writer setCentroid )
	  ( layer @reader getLayer @writer setLayer )
	  ( purpose @reader getPurpose @writer setPurpose )
   )				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj gateStem)) 
	   obj->width  = 1.0
	   obj->length = 1.0 
	   obj->widthTaper = 1.0
	   obj->centroid = makeInstance( 'point2 )
	   obj->layer = "text"
	   obj->purpose = "drawing"
);defmethod

;######################################################
; Generates the geometry
;######################################################
defmethod( generate (( gs gateStem ))
  setCentroid(gs list(0.0 0.0))
  ; Gate Taper
  taper = makeInstance('trirect)
  setWidth(taper getWidthTaper(gs))
  setHeight(taper 3*getLength(gs))
  generate(taper)
  setLayer(taper getLayer(gs))
  setPurpose(taper getPurpose(gs))
  addGeometry(gs taper)
  rtsAdd(gs->rtrans getRectTran(taper))
  ; Gate stem
  rect = makeInstance('rectangle)
  setWidth(rect getWidth(gs))
  setHeight(rect getLength(gs))
  generate(rect)
  rectTran = makeInstance('transform2)
  addPolygon(rectTran rect)
  cloneRectTran(rectTran)
  setLayer(rectTran getLayer(gs))
  setPurpose(rectTran getPurpose(gs))
  translate(rectTran list(0.5*(getWidth(gs)+getWidthTaper(gs))+2*getLength(gs) 0.0))
  rectGeom = makeInstance('geometry)
  addTransform(rectGeom rectTran )
  rectTranUnion(rectGeom)
  addGeometry(gs rectGeom)
  rtsAdd(gs->rtrans getRectTran(rectGeom))
  rtsUnion(gs->rtrans)
  translate(gs list(8.75 0.0))
);defmethod

;######################################################
; Translates the geometry
;######################################################
defmethod( translate (( gs gateStem ) arg)
  foreach(geom getCollection(gs->geometries)
     translate(geom arg)
  );foreach
);defmethod
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; generic.ils: generic functions

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Defines the generic function for draw. Redefining a generic function
; removes all methods defined by the previous defgeneric from
defgeneric( draw (devicd)
	    t
);defgeneric;#################################################################
; PcellParam.ils: class for pcell parameters
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Defines a base class for the PCELL API with a single slot for 
; holding the PCELL master ID. This PCELL ID is the same as the
; the pcCellView variable using in the a standard SKILL Pcell
;..................................................................
; cvId will hold the pcCellView reference which is set in the 
; extremely important "setPcellParams" method
;#################################################################
defclass( PcellParam ()
  (
	(cvId @initarg cvId)
  )
);defclass

;#################################################################
; Transfers the Pcell parameters from the super master cell view to 
; a Pcell device's slots.
;
; input argument cv is the built in "pcCellView" class object's
; reference . The "pcCellView" is the standard variable, representing
; the PCELL master ID,  used in a standard SKILL Pcell.
; 
; NOTE: 
; This important method does the mapping of the desired user
; parameters between and the required built in "pcCellView" parameters.
; This ensures that the user defined pcell has full access to the
; built in class' parameters (pcCellView). During pcell compilation
; this method is called in order to update the user pcell code object from
; the parameterized inputs of the built in pcell object (pcCellView).
; Every time a pcell's parameter is changed, the user pcell is 
; recompiled and executed using the new parameter values of the built 
; in pcell object. 
;#################################################################
defmethod( setPcellParams ((device PcellParam) cv)
  when( cv && dbIsId(cv)
  	setSlotValue(device 'cvId cv)
	foreach( param cv~>parameters~>value
	  setParamValue(device concat(param~>name) param~>value)
	);foreach
  );when
);defmethod

;#################################################################
; A function to define a Pcell parameter stored as a Pcell class'
; slot. The optional argument _isParam is set to 't to indicate
; this parameter is a Pcell parameter
;#################################################################
defun( defineParam (g_type g_value @optional (_isParam t))
  list(nil 'type g_type 'value g_value 'isParam _isParam)
);defun

;#################################################################
; A method to get Pcell parameter's type
;#################################################################
defmethod( getParamType ((device PcellParam) (propName symbol))
  slotValue(device propName)->type
);defmethod

;#################################################################
; A method to get Pcell parameter's value
;#################################################################
defmethod( getParamValue ((device PcellParam) (propName symbol))
  slotValue(device propName)->value
);defmethod

;#################################################################
; A method to set Pcell parameter's value
;#################################################################
defmethod( setParamValue ((device PcellParam) (propName symbol) val)
  slotValue(device propName)->value = val
);defmethod

;#################################################################
; A method to check if the given name is a Pcell parameter. Based
; upon setting the of the isParam attribute
;#################################################################
defmethod( isParam ((device PcellParam) (propName symbol))
  slotValue(device propName)->isParam
);defmethod

;#################################################################
; A method to to get a list of Pcell parameters with their names,
; types, and values
;#################################################################
defmethod( getPcellParams ((device PcellParam) )
  let((params)
    params = setof(p device->? isParam(device p))
    params = foreach( mapcar p params 
    	              list( p getParamType(device p) getParamValue(device p))
	     );foreach
  );let
);defmethod

;#################################################################
;#################################################################
;#################################################################;############################################################################
; RING.ils: Draws a polygon that wraps around a devices' coreBBox 
;           with a griven spacing value and width of the polygon.
;           Inherits from PcellParam class
;############################################################################
defclass( RING (PcellParam)
  (
	(ringW @initform defineParam("float" 0.1))
	(ringS @initform defineParam("float" 0.1))
  )
);defclass

;#################################################################
; Draw a polygon that wraps around the devices coreBBox with a
; given spacing value and width
;#################################################################
defmethod( draw ((device RING))
  let((cv ringS ringW coreBBox llx lly urx ury pts ring)
    ringS = getParamValue(device 'ringS)
    ringW = getParamValue(device 'ringW)
    coreBBox = getCoreBBox(device)
    llx = xCoord( lowerLeft(coreBBox))
    lly = yCoord( lowerLeft(coreBBox))
    urx = xCoord( upperRight(coreBBox))
    ury = yCoord( upperRight(coreBBox))
    pts = list(
    	llx-ringS:lly-ringS ; points on inner edges
	urx+ringS:lly-ringS
	urx+ringS:ury+ringS
	llx-ringS:ury+ringS
	llx-ringS:lly-ringS-ringW         ; extending to outer edge
	llx-ringS-ringW:lly-ringS-ringW   ; points on outer edges
	llx-ringS-ringW:ury+ringS+ringW   
	urx+ringS+ringW:ury+ringS+ringW
	urx+ringS+ringW:lly-ringS-ringW
	llx-ringS:lly-ringS-ringW
	);list
    ; layer chosen for its color's visibility
    ; you can replace the layer names mentioned here with the layer
    ; name present in your library
    cv = slotValue(device 'cvId)
    ring = dbCreatePolygon(cv list("numbers" "drawing") pts)
    callNextMethod()
    );let
);defmethod

;#################################################################
; This method is called when RING is used on its own
; Returns and empty box
;#################################################################
defmethod(getCoreBBox ((device RING))
  list(0:0 0:0)
);defmethod
;#################################################################
;#################################################################
;#################################################################

;#####################################################################
; CORE.ils: core pcell class inheriting from PcellParam class
; Note: Parameter created via defineParam will be treated as
;       a Pcell parameter; otherwise it is treated as a normal
;       class slot (e.g. coreBBox is not a Pcell parameter)
;#####################################################################
; cyanW: Width of the verticle cross block
; cyanL: Lenth of the verticle cross blcok
; greenW: Width of the verticle cross block
; greenL: Lenth of the verticle cross blcok
;#####################################################################
defclass( CORE (PcellParam)
  (
	( cyanW @initform defineParam("float" 0.6) )
	( cyanL @initform defineParam("float" 0.8) )
	( greenW @initform defineParam("float" 0.2) )
	( greenL @initform defineParam("float" 0.2) )
	( coreBBox @initarg coreBBox )
  )
);defclass

;######################################################################
; Draw a simple cross represented by two rectangles
;######################################################################
defmethod( draw ((device CORE))
  let((cv cyanW cyanL greenW greenL rectId llx lly urx ury)
    cyanW = getParamValue(device 'cyanW)
    cyanL = getParamValue(device, 'cyanL)
    greenW = getParamValue(device, 'greenW)
    greenL = getParamValue(device, 'greenL)
    ; layers are choosen for their color's visibility
    ; you can replace the layer names here with the 
    ; the layer names present in the library
    cv = slotValue(device 'cvId)
    rectId = dbCreateRect(cv list("numbers" "drawing") list(0:0 greenL:greenW))
    llx = 0.5 * greenL - 0.5 * cyanL
    lly = 0.5 * greenW - 0.5 * cyanW
    urx = 0.5 * greenL + 0.5 * cyanL
    ury = 0.5 * greenW + 0.5 * cyanW
    rectId = dbCreateRect(cv list("numbers" "drawing") list(llx:lly urx:ury))
    setSlotValue(device 'coreBBox list( 0.0:lly greenL:ury))
    callNextMethod()
    );let
);defmethod

;######################################################################
; Returns CORE's bounding box which is stored in coreBBox slot
;######################################################################
defmethod( getCoreBBox ((device CORE))
  slotValue(device 'coreBBox)
);defmethod

;#######################################################################
;#######################################################################
;#######################################################################
;#############################################################
; WRAP.ils: Defines a wrapped core class that inherits both
;           CORE and RING classes
;
; Used for testing the Skill++ PCELL API 
;#############################################################
defclass( WRAP (CORE RING)
	  ()
);defclass
;#############################################################
; Draw method for WRAP is just a simple call to callNextMethod()
; Due to the specificity of WRAP's superclasses, the draw
; methods for CORE and RING will be called in this order
;#############################################################
defmethod(draw ((device WRAP))
  callNextMethod()
);defmethod
;#############################################################
;#############################################################
;#############################################################
;######################################################
; gate.ils: fet gate PCELL class. Inherits from PcellParam
;           making it a Cadence PCELL class
;######################################################
defclass( gate (PcellParam)
  (
    ( width  @initform defineParam("float" 50.0) )
    ( length @initform defineParam("float" 0.25) )
    ( stem )
    ( pad )
    ( centroid )
    ( ref @reader getRef @writer setRef )
    ( rtrans )
    ( coreBBox @initarg coreBBox )
  ) 				  
);defclass

;#####################################################
; This method initializes the class
;#####################################################
defmethod( initializeInstance @after ((obj gate)) 
	   obj->stem = makeInstance( 'gateStem )
	   obj->pad = makeInstance( 'gatePad )
	   obj->centroid = makeInstance('point2)
	   obj->rtrans = makeInstance('rectTrans)
);defmethod

;######################################################
; Draws the gate
;######################################################
defmethod( draw (( gt gate ))
  let( (width length stemRectTran padRectTran)
    width = getParamValue(gt 'width)
    length = getParamValue(gt 'length)
    setWidthInner(gt->pad 13.5)
    setHeightInner(gt->pad 4.0)
    setWidthOutter(gt->pad 13.5)
    setHeightOutter(gt->pad 5.6)
    setInnerLayer(gt->pad "resistor")
    setOutterLayer(gt->pad "membrane")
    setBsegLayer(gt->pad "thick")
    setRef(gt->pad getRef(gt))
    generate(gt->pad)
    render(gt->pad)
    setWidth(gt->stem width)
    setLength(gt->stem length)
    setWidthTaper(gt->stem 2.5)
    setLayer(gt->stem "membrane")
    setRef(gt->stem getRef(gt))
    generate(gt->stem)
    render(gt->stem)
    stemRectTran = getRectTran(gt->stem)
    padRectTran = getRectTran(gt->pad)
    rtsAdd(gt->rtrans stemRectTran) 
    rtsAdd(gt->rtrans padRectTran)
    rtsUnion(gt->rtrans)
    setSlotValue(gt 'coreBBox list( getLowerLeft(gt->rtrans->rtran) getUpperRight(gt->rtrans->rtran)))
    callNextMethod()
  );let
);defmethod

;######################################################################
; Returns gates's bounding box which is stored in coreBBox slot
;######################################################################
defmethod( getCoreBBox ((gt gate))
  slotValue(gt 'coreBBox)
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;