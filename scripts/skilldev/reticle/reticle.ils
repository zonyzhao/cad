;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;  reticle.il: Reticle Object 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( reticle (cv)
	  (
		( srRes @reader getRes @writer setRes)
		( srGrid @reader getSrGrid @writer setSrGrid)
		( overlap @reader getOverlap @writer setOverlap)
		( maxDim @reader getMaxDim @writer setMaxDim)
		( xynPadChipName @reader getPadChipName @writer setPadChipName)
		( xynPadCouponName @reader getPadCouponName @writer setPadCouponName)
		( validDim @reader getDimValid)
		( validRes @reader getResValid)
		( shiftUrq @reader getShiftUrq @writer setShiftUrq)
		( chipList @reader getChipList)
		( couponList @reader getCouponList)
		( chips @reader getChips)
		( coupons @reader getCoupons)	
		( isPartial @reader getIsPartial )
		( origin @reader getOrigin @writer setOrigin)
		( numRetChips @reader getNumRetChips @writer setNumRetChips) 
		( numRetCoups @reader getNumRetCoups @writer setNumRetCoups) 
		( numNumPads @reader getNumNumPads)				
	  )
);defClass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj reticle)) 
	   obj->srRes = nil
	   obj->srGrid = nil
	   obj->overlap = nil
	   obj->maxDim = nil
	   obj->xynPadChipName = nil
	   obj->xynPadCouponName = nil
	   obj->validDim = nil
	   obj->validRes = nil
	   obj->shiftUrq = nil
	   obj->chipList = nil  
	   obj->couponList = nil
	   obj->chips = makeInstance( 'collection )
	   obj->coupons = makeInstance( 'collection ) 
	   obj->isPartial = nil
	   obj->origin = nil 
	   obj->numRetChips = nil 
	   obj->numRetCoups = nil
	   obj->numNumPads = nil
);defmethod

;######################################################
; This method checks to make sure reticle width and 
; height do not exceed the maximum dimension (maxDim)
;######################################################
defmethod( checkDim ((ret reticle))
  ret->validDim = 't
  getbBox(ret)
  getDim(ret)
  if(getWidth(ret) > getMaxDim(ret) then
    printf("ERROR: Reticle Width %8.1f exceeds maximum dimension %f\n" float(getWidth(ret)) float(ret->maxDim) )
    ret->validDim = nil
  else
    printf("INFO: Reticle Width %8.1f is less than maximum dimension %f\n" float(getWidth(ret)) float(ret->maxDim) )
  );if
  if(getHeight(ret) > getMaxDim(ret) then
    printf("ERROR: Reticle Length %8.1f exceeds maximum dimension %f\n" float(getHeight(ret)) float(ret->maxDim) )
    ret->validDim = nil
  else
    printf("INFO: Reticle Length %8.1f is less than maximum dimension %f\n" float(getHeight(ret)) float(ret->maxDim) )
  );if
);defmethod

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for grid requirements????
; FIXME: Get grid information from TF via grid class 
;#####################################################
defmethod( checkGrid ((ret reticle))
  if( abs(quotient(getWidth(ret) ret->srGrid 1.0) - round(getWidth(ret)*10)) > 0.0 then
    printf("ERROR: Reticle Width %g NOT ON a %g um grid\n" float(getWidth(ret)) float(ret->srGrid))
  else
    printf("INFO: Reticle Width %g step is correctly on a %g um grid\n" float(getWidth(ret)) float(ret->srGrid))
  );if
  if( abs(quotient(getHeight(ret) ret->srGrid 1.0) - round(getHeight(ret)*10)) > 0.0 then
    printf("ERROR: Reticle Height %g step resolution NOT ON a %g um grid\n" ret->bb->height ret->srGrid)
  else
    printf("INFO: Reticle Height %g step is correctly on a %g um grid\n" float(getHeight(ret)) float(ret->srGrid))
  );if
);defmethod

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for Step and Repeat (S&R) value 
; provided
;#####################################################
defmethod( checkRes (( ret reticle ))
 let((rwidth rheight)
    ret->validRes = 't
    getbBox(ret)
    getDim(ret)
    rwidth =  getWidth(ret) - ret->overlap
    rheight = getHeight(ret) - ret->overlap
    printf("INFO: Reticle Overlap Setting: %5.1f\n" float(ret->overlap))
    printf("INFO: Reticle S&R Setting: %5.1f\n" float(ret->srRes))
    if(quotient(rwidth ret->srRes) - int(quotient(rwidth ret->srRes)) > 0 then
      printf("ERROR: Overlap Compensated Reticle Width %5.1f DOES NOT MEET required S&R step resolution of %3.1f\n" float(rwidth) float(ret->srRes))
      ret->validRes = nil     
    else
      printf("INFO: Overlap Compensated Reticle Width %5.1f MEETS required S&R step resolution of %3.1f\n" float(rwidth) float(ret->srRes))
    );if
    if(quotient(rwidth ret->srRes) - int(quotient(rwidth ret->srRes)) > 0 then
      printf("ERROR: Overlap Compensated Reticle Length %5.1f DOES NOT MEET required S&R step resolution of %3.1f\n" float(rheight) float(ret->srRes))
      ret->validRes = nil
    else
      printf("INFO: Overlap Compensated Reticle Length %5.1f MEETS required S&R step resolution of %3.1f\n" float(rheight) float(ret->srRes))
    );if
  );let
); defmethod

;#####################################################
; This method checks the periodicity of the inside
; streets of reticle and ensures that each inner street
; extends the full length of the reticle without any 
; jogging
; 
; 1.) generate a row/col matrix for the die sites
; 2.) find the origin of all die sites
; 3.) make sure the row,col matrix origin coordinates
;     are periodic in their respective dimension  
;#####################################################
;defmethod( periodicity (( ret reticle )) 
  ; Periodicity check of verticle streets
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Scribe line pointer
  ; xs = 0
  ; xs = getVerticalScribes(ret)
  ; 
  ; Intra-Reticle (Die Site Counter)
  ; lx = 0
  ; while( car( inst~>xy) - lx > xynpl->retW
  ;	ix = ix + length( sl)
  ;	lx = lx + xynpl->retW
  ;    )
  ;     advance to the next scribe line, 
  ;     or reset to the first scribe when we pass the right edge of reticle:
  ;    xs = or( cdr( xs) sl)
  ;x = xCoord(getOrigin(ret))
  ;while( x >= getWidth(ret) 
  ;       printf("X coordinate %L is greater than reticle width %L subtracting width" x getWidth(ret))
  ;       x = x - getWidth(ret)
  ;       printf( "New X value %L:" x )
  ;);while
  ;	   
;  nil
;);

;#####################################################
; This method checks that all vertical and horizontal
; streets are of uniform width
;#####################################################
;defmethod( getVerticalScribes (( ret reticle ))
;   let( ( sl sorted i)
;    println( "Finding Vertical Reticle Scribe Lines:")
;    foreach( chip getChipList(ret)
;      when( chip->chipType == "chip"
;        printf( "Chip Name: %L" chip->cellName)
;	 foreach( pos getOrigin(chip)
;          printf( "Chip X Position: %L" xCoord(pos))
;          ; create a list of chip unique x values
;          ; INLINE IF: if(member( car( posn) sl) sl = cons( car( posn) sl):nil)
;	   unless( member( car( posn) sl) sl = cons( car( posn) sl))
;	 )
;      )
;    )
;    sorted = sort( sl 'lessp)
;    println( "Sorted Reticle Scribe Line X Coord List:")
;    i=0
;    foreach(sort sorted
;      printf( "%L.) SL X Coord:%L" i nth(i sorted))
;      cdr(sorted)
;      i++
;    )
;  )
;  sort( sl 'lessp)
;);defmethod


;#####################################################
; This method checks that all vertical and horizontal
; streets are of uniform width
;#####################################################
defmethod( streetWidths (( ret reticle ))
  nil
);

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for Step and Repeat (S&R) value 
; provided
;#####################################################
defmethod( chipId (( ret reticle ))
  nil
);

;#####################################################
; This method searches the reticle instances for the
; xynPad. It only searches for the pad in instances
; one level below the top level reticle cellview
;#####################################################
defmethod( findXynPads (( ret reticle ))
  let((dlist cv numPadCount chipPadCount couponPadCount chip coupon cvchip)
    resetCollection(ret->chips)
    resetCollection(ret->coupons)
    numPadCount = 0
    chipPadCount = 0
    couponPadCount = 0
    dlist = '()
    clist = '()
    cv = getRef(ret)
    ;FIXME: coupons not being detected!!
    foreach( ih cv~>instHeaders
      printf("Instance Header Name: %s \n" ih~>cellName)
      foreach( inst ih~>instances
        printf("Instance Name: %s \n" inst~>cellName)
        foreach( cell inst~>master~>instances
          printf("Cell Name: %s \n" cell~>cellName)
          if(!null(strcmp(cell~>cellName ret->xynPadChipName) == 0) then
	    numPadCount++
	    chipPadCount++
            printf("%d.) XYN CHIP PAD FOUND!: %s, In chip: %s \n" numPadCount cell~>cellName inst~>cellName)
	    dlist = cons(inst~>cellName dlist)
	    chip = makeInstance( 'chip )
	    setName(chip inst~>cellName)
	    setLib(chip getLib(ret))
	    setView(chip getView(ret))
	    setOrient(chip inst~>orient)
	    setBbx(getBbx(chip) inst~>bBox)
	    getDim(getBbx(chip))
	    Origin(getBbx(chip))
	    setName(chip->numpad cell~>cellName)
            setOrient(chip->numpad cell~>orient)
	    setBbx(getBbx(chip->numpad) cell~>bBox)
	    getDim(getBbx(chip->numpad))
	    Origin(getBbx(chip->numpad))
	    ;setChipBbox(chip inst~>bbox)
	    ;setPadBbox(chip cell~>bBox)
	    ;setInstanceBbox(chip inst~>bBox)
	    ;getDim(chip)
	    addChip(ret chip)
          );
	  if(!null(strcmp(cell~>cellName ret->xynPadCouponName) == 0) then
            numPadCount++
	    couponPadCount++
            printf("%d.) XYN COUPON PAD FOUND!: %s, In coupon: %s \n" numPadCount cell~>cellName inst~>cellName)
	    clist = cons(inst~>cellName clist)
          );
        );foreach
      );foreach
    );foreach
    dlist = sort(dlist nil)
    clist = sort(clist nil)
    ret->chipList = dlist
    ret->couponList = clist
    ret->numNumPads = numPadCount
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Sorts chips based on the whether the chip is a chip or a coupon,
;              then on the naming convention adopted on 06/08
;                    Chips/Legacy Coupons: NN[N]  (e.g.  99, 970)
;                    New Standard Coupons: PPNNR  (e.g. 8099A)
;                New Experimental Coupons: XPPNNR (e.g. X8001A)
;                         Legend -  N - Number
;                                   P - Process
;                                   R - Revision
;                                  [] - Optional
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;#####################################################
; Digitizes a number (num) to a list of digits of 
; length digits
;#####################################################
defmethod( digitize (( ret reticle ) num)
  let((digits format dlist)
    ;FIXME: add a second argument for digits
    digits = 3
    format = sprintf( nil "%%0%dd" digits)
    dlist = parseString( sprintf( nil format num) "")
  );let
);defmethod

;#####################################################
; Add chip to chips collection
;#####################################################
defmethod( addChip (( ret reticle ) arg)
  if( classp( arg 'chip) then
    add(ret->chips arg)
  else
    println("ERROR(reticle): Argument must be a chip object")
  );if
);defmethod

;#####################################################
; Add coupon to couponss collection
;#####################################################
defmethod( addCoupon (( ret reticle ) arg)
  if( classp( arg 'coupon) then
    add(ret->coupons arg)
  else
    println("ERROR(reticle): Argument must be a coupon object")
  );if
);defmethod


;#####################################################
; Updates the relative position, relPos member,  of the 
; chips and pad locations within the reticle based upon
; the reticleOrigin value
;#####################################################
defmethod( update (( ret reticle ))
  nil
);defmethod

;#####################################################
; Updates the relative position, relPos member,  of the 
; chips and pad locations within the reticle based upon
; the reticleOrigin value
;#####################################################
defmethod( checkSum (( ret reticle ))
  let((psum)
    psum = getNumRetChips(ret) + getNumRetCoups(ret)
    if(!null(psum == getNumNumPads(ret)) then
       printf("INFO: Reticle Coupon Checksum Passed, Chips+Coups: %d, numPads: %d\n" psum getNumNumPads(ret))
    else
       printf("ERROR: Reticle Coupon Checksum FAILED!, Chips+Coups: %d, numPads: %d\n" psum getNumNumPads(ret))
    ); 
  );
);defmethod

;######################################################
;######################################################
;######################################################


	
