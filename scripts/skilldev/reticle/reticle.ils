;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  reticle.il: Reticle Object 
;   FIXME: After the inner streets are checked for compliance, there needs to be
;          a check to ensure that the outter streets of the combined die site 
;          outter streets are centered within the reticle outline. The combination
;          of these checks ensures that the inter and intra reticle streets are
;          periodic and can be numbered via the commutative numbering algorithm  
;  FIXME: Coupon XYNPADS need to be detected within the overhead block
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
defclass( reticle (cv)
	  (
		( srRes @reader getRes @writer setRes)
		( srGrid @reader getSrGrid @writer setSrGrid)
		( overlap @reader getOverlap @writer setOverlap)
		( maxDim @reader getMaxDim @writer setMaxDim)
		( xynPadChipName @reader getPadChipName @writer setPadChipName)
		( xynPadOverheadName @reader getPadOverheadName @writer setPadOverheadName)
		( xynPadCouponName @reader getPadCouponName @writer setPadCouponName)
		( validDim @reader getDimValid)
		( validRes @reader getResValid)
		( shiftUrq @reader getShiftUrq @writer setShiftUrq)
		( chipList @reader getChipList)
		( olist @reader getOverheadList)
		( couponList @reader getCouponList)
		( chips @reader getChips)
		( overhead @reader getOverhead)
		( coupons @reader getCoupons)	
		( isPartial @reader getIsPartial )
		( origin @reader getOrigin @writer setOrigin)
		( numRetChips @reader getNumRetChips @writer setNumRetChips) 
		( numRetOverhead @reader getNumRetOverhead @writer setNumRetOverhead)
		( numRetCoups @reader getNumRetCoups @writer setNumRetCoups) 
		( numNumPads @reader getNumNumPads)				
	  )
);defClass

;#####################################################
; Constructor Method
;#####################################################
defmethod( initializeInstance @after ((obj reticle)) 
	   obj->srRes = nil
	   obj->srGrid = nil
	   obj->overlap = nil
	   obj->maxDim = nil
	   obj->xynPadChipName = nil
	   obj->xynPadOverheadName = nil
	   obj->xynPadCouponName = nil
	   obj->validDim = nil
	   obj->validRes = nil
	   obj->shiftUrq = nil
	   obj->chipList = nil
	   obj->olist = nil 
	   obj->couponList = nil
	   obj->chips = makeInstance( 'collection )
	   obj->overhead = makeInstance( 'collection )
	   obj->coupons = makeInstance( 'collection ) 
	   obj->isPartial = nil
	   obj->origin = nil 
	   obj->numRetChips = nil 
	   obj->numRetOverhead = nil
	   obj->numRetCoups = nil
	   obj->numNumPads = nil
);defmethod

;######################################################
; This method checks to make sure reticle width and 
; height do not exceed the maximum dimension (maxDim)
;######################################################
defmethod( checkDim ((ret reticle))
  ret->validDim = 't
  getbBox(ret)
  getDim(ret)
  if(getWidth(ret) > getMaxDim(ret) then
    printf("ERROR: Reticle Width %8.1f exceeds maximum dimension %f\n" float(getWidth(ret)) float(ret->maxDim) )
    ret->validDim = nil
  else
    printf("INFO: Reticle Width %8.1f is less than maximum dimension %f\n" float(getWidth(ret)) float(ret->maxDim) )
  );if
  if(getHeight(ret) > getMaxDim(ret) then
    printf("ERROR: Reticle Length %8.1f exceeds maximum dimension %f\n" float(getHeight(ret)) float(ret->maxDim) )
    ret->validDim = nil
  else
    printf("INFO: Reticle Length %8.1f is less than maximum dimension %f\n" float(getHeight(ret)) float(ret->maxDim) )
  );if
);defmethod

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for grid requirements????
; FIXME: Get grid information from TF via grid class 
;#####################################################
defmethod( checkGrid ((ret reticle))
  if( abs(quotient(getWidth(ret) ret->srGrid 1.0) - round(getWidth(ret)*10)) > 0.0 then
    printf("ERROR: Reticle Width %g NOT ON a %g um grid\n" float(getWidth(ret)) float(ret->srGrid))
  else
    printf("INFO: Reticle Width %g step is CORRECTLY on a %g um grid\n" float(getWidth(ret)) float(ret->srGrid))
  );if
  if( abs(quotient(getHeight(ret) ret->srGrid 1.0) - round(getHeight(ret)*10)) > 0.0 then
    printf("ERROR: Reticle Height %g step resolution NOT ON a %g um grid\n" ret->bb->height ret->srGrid)
  else
    printf("INFO: Reticle Height %g step is CORRECTLY on a %g um grid\n" float(getHeight(ret)) float(ret->srGrid))
  );if
);defmethod

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for Step and Repeat (S&R) value 
; provided
;#####################################################
defmethod( checkRes (( ret reticle ))
 let((rwidth rheight)
    ret->validRes = 't
    getbBox(ret)
    getDim(ret)
    rwidth =  getWidth(ret) - ret->overlap
    rheight = getHeight(ret) - ret->overlap
    printf("INFO: Reticle Overlap Setting: %5.1f\n" float(ret->overlap))
    printf("INFO: Reticle S&R Setting: %5.1f\n" float(ret->srRes))
    if(quotient(rwidth ret->srRes) - int(quotient(rwidth ret->srRes)) > 0 then
      printf("ERROR: Overlap Compensated Reticle Width %5.1f DOES NOT MEET required S&R step resolution of %3.1f\n" float(rwidth) float(ret->srRes))
      ret->validRes = nil     
    else
      printf("INFO: Overlap Compensated Reticle Width %5.1f MEETS required S&R step resolution of %3.1f\n" float(rwidth) float(ret->srRes))
    );if
    if(quotient(rwidth ret->srRes) - int(quotient(rwidth ret->srRes)) > 0 then
      printf("ERROR: Overlap Compensated Reticle Length %5.1f DOES NOT MEET required S&R step resolution of %3.1f\n" float(rheight) float(ret->srRes))
      ret->validRes = nil
    else
      printf("INFO: Overlap Compensated Reticle Length %5.1f MEETS required S&R step resolution of %3.1f\n" float(rheight) float(ret->srRes))
    );if
  );let
); defmethod

;#####################################################
; This method checks the periodicity of the inside
; streets of reticle and ensures that each inner street
; extends the full length of the reticle without any 
; jogging
; 
; 1.) generate a row/col matrix for the die sites
; 2.) find the origin of all die sites
; 3.) make sure the row,col matrix origin coordinates
;     are periodic in their respective dimension  
;#####################################################
;defmethod( CheckPeriodicity (( ret reticle )) 
  ; Periodicity check of verticle streets
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Scribe line pointer
  ; xs = 0
  ; xs = getVerticalScribes(ret)
  ; 
  ; Intra-Reticle (Die Site Counter)
  ; lx = 0
  ; while( car( inst~>xy) - lx > xynpl->retW
  ;	ix = ix + length( sl)
  ;	lx = lx + xynpl->retW
  ;    )
  ;     advance to the next scribe line, 
  ;     or reset to the first scribe when we pass the right edge of reticle:
  ;    xs = or( cdr( xs) sl)
  ;x = xCoord(getOrigin(ret))
  ;while( x >= getWidth(ret) 
  ;       printf("X coordinate %L is greater than reticle width %L subtracting width" x getWidth(ret))
  ;       x = x - getWidth(ret)
  ;       printf( "New X value %L:" x )
  ;);while
  ;	   
;  nil
;);

;#####################################################
; This method checks that all vertical and horizontal
; streets are of uniform width
;#####################################################
defmethod( getVerticalScribes (( ret reticle ))
   let( ( sl sorted i origsx origsy)
    println( "Finding Vertical Reticle Scribe Lines:")
    ; Generate a list of all chip origins
    origsx = '()
    origsy = '()
    foreach( chip getCollection(ret->chips)
      printf( "Chip Name: %L" getName(chip))
      origsx = cons(xCoord(getOrigin(getBbx(chip))) origsx)
      origsy = cons(yCoord(getOrigin(getBbx(chip))) origsy)
    );foreach
    foreach( coup getCollection(ret->coupons)
      printf( "Coupon Name: %L" getName(coup))
      origsx = cons(xCoord(getOrigin(getBbx(coup))) origsx)
      origsy = cons(yCoord(getOrigin(getBbx(coup))) origsy)
    );foreach
    sl = '()
    printf( "Chip X Position: %L" posx)
    ; create a list of chip unique x values
    ; INLINE IF: if(member( car( posn) sl)  sl = cons( car( posn)  sl):nil)
    unless( member( car( origsx) sl) sl = cons( car( origsx) sl))
    sorted = sort( sl )
    println( "Sorted Reticle Scribe Line X Coord List:")
    i=0
    foreach(sort sorted
      printf( "%L.) SL X Coord:%L" i nth(i sorted))
      cdr(sorted)
      i++
    );foreach
    sort( sl )
  );let
);defmethod

;#####################################################
; This method checks the reticle's bbox dimensions
; (width and height) for Step and Repeat (S&R) value 
; provided
;#####################################################
defmethod( chipId (( ret reticle ))
  nil
);

;#####################################################
; This method searches the reticle instances for the
; xynPad. It only searches for the pad in instances
; one level below the top level reticle cellview
;#####################################################
defmethod( findXynPads (( ret reticle ))
  let((dlist olist clist cv numPadCount chipPadCount overheadPadCount couponPadCount chip coupon cvchip)
    resetCollection(ret->chips)
    resetCollection(ret->coupons)
    numPadCount = 0
    chipPadCount = 0
    overheadPadCount = 0
    couponPadCount = 0
    dlist = '()
    clist = '()
    cv = getRef(ret)
    foreach( ih cv~>instHeaders
      printf("Instance Header Name: %s \n" ih~>cellName)
      foreach( inst ih~>instances
        printf("Instance Name: %s \n" inst~>cellName)
        foreach( cell inst~>master~>instances
          printf("Cell Name: %s \n" cell~>cellName)
          if(!null(strcmp(cell~>cellName ret->xynPadChipName) == 0) then
	    numPadCount++
	    chipPadCount++
            printf("%d.) XYN CHIP PAD FOUND!: %s, In chip: %s \n" numPadCount cell~>cellName inst~>cellName)
	    dlist = cons(inst~>cellName dlist)
	    chip = makeInstance( 'chip )
	    setName(chip inst~>cellName)
	    setLib(chip getLib(ret))
	    setView(chip getView(ret))
	    setOrient(chip inst~>orient)
	    setBbx(getBbx(chip) inst~>bBox)
	    getDim(getBbx(chip))
	    Origin(getBbx(chip))
	    setName(chip->numpad cell~>cellName)
            setOrient(chip->numpad cell~>orient)
	    setBbx(getBbx(chip->numpad) cell~>bBox)
	    getDim(getBbx(chip->numpad))
	    Origin(getBbx(chip->numpad))
	    ;setChipBbox(chip inst~>bbox)
	    ;setPadBbox(chip cell~>bBox)
	    ;setInstanceBbox(chip inst~>bBox)
	    ;getDim(chip)
	    addChip(ret chip)
          );
	  if(!null(strcmp(cell~>cellName ret->xynPadOverheadName) == 0) then
	    numPadCount++
	    overheadPadCount++
            printf("%d.) XYN OVERHEAD PAD FOUND!: %s, In chip: %s \n" numPadCount cell~>cellName inst~>cellName)
	    olist = cons(inst~>cellName olist)
	    oh = makeInstance( 'overhead )
	    setName(oh inst~>cellName)
	    setLib(oh getLib(ret))
	    setView(oh getView(ret))
	    setOrient(oh inst~>orient)
	    setBbx(getBbx(oh) inst~>bBox)
	    getDim(getBbx(oh))
	    Origin(getBbx(oh))
	    setName(oh->numpad cell~>cellName)
            setOrient(oh->numpad cell~>orient)
	    setBbx(getBbx(oh->numpad) cell~>bBox)
	    getDim(getBbx(oh->numpad))
	    Origin(getBbx(oh->numpad))
	    ;setChipBbox(oh inst~>bbox)
	    ;setPadBbox(oh cell~>bBox)
	    ;setInstanceBbox(oh inst~>bBox)
	    ;getDim(oh)
	    addOverhead(ret oh)
          );
	  ;if(!null(strcmp(cell~>cellName ret->xynPadCouponName) == 0) then
          ;  numPadCount++
	  ;  couponPadCount++
          ;  printf("%d.) XYN COUPON PAD FOUND!: %s, In coupon: %s \n" numPadCount cell~>cellName inst~>cellName)
	  ;  clist = cons(inst~>cellName clist)
          ;);
        );foreach
      );foreach
    );foreach
    dlist = sort(dlist nil)
    clist = sort(clist nil)
    ret->chipList = dlist
    ret->olist = olist
    ret->couponList = clist
    ret->numNumPads = numPadCount
  );let
);defmethod

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Description: Sorts chips based on the whether the chip is a chip or a coupon,
;              then on the naming convention adopted on 06/08
;                    Chips/Legacy Coupons: NN[N]  (e.g.  99, 970)
;                    New Standard Coupons: PPNNR  (e.g. 8099A)
;                New Experimental Coupons: XPPNNR (e.g. X8001A)
;                         Legend -  N - Number
;                                   P - Process
;                                   R - Revision
;                                  [] - Optional
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;#####################################################
; Digitizes a number (num) to a list of digits of 
; length digits
;#####################################################
defmethod( digitize (( ret reticle ) num)
  let((digits format dlist)
    ;FIXME: add a second argument for digits
    digits = 3
    format = sprintf( nil "%%0%dd" digits)
    dlist = parseString( sprintf( nil format num) "")
  );let
);defmethod

;#####################################################
; Add chip to chips collection
;#####################################################
defmethod( addChip (( ret reticle ) arg)
  if( classp( arg 'chip) then
    add(ret->chips arg)
  else
    println("ERROR(reticle): Argument must be a chip object")
  );if
);defmethod

;#####################################################
; Add overhead to overhead collection
;#####################################################
defmethod( addOverhead (( ret reticle ) arg)
  if( classp( arg 'overhead) then
    add(ret->overhead arg)
  else
    println("ERROR(reticle): Argument must be an overhead object")
  );if
);defmethod

;#####################################################
; Add coupon to couponss collection
;#####################################################
defmethod( addCoupon (( ret reticle ) arg)
  if( classp( arg 'coupon) then
    add(ret->coupons arg)
  else
    println("ERROR(reticle): Argument must be a coupon object")
  );if
);defmethod


;#####################################################
; Updates the relative position, relPos member,  of the 
; chips and pad locations within the reticle based upon
; the reticleOrigin value
;#####################################################
defmethod( update (( ret reticle ))
  nil
);defmethod

;#####################################################
; Updates the relative position, relPos member,  of the 
; chips and pad locations within the reticle based upon
; the reticleOrigin value
;#####################################################
defmethod( checkSum (( ret reticle ))
  let((psum)
    psum = getNumRetChips(ret) + getNumRetOverhead(ret)
    if(!null(psum == getNumNumPads(ret)) then
       printf("INFO: Reticle Coupon Checksum Passed, Chips+Overhead: %d, numPads: %d\n" psum getNumNumPads(ret))
    else
       printf("ERROR: Reticle Coupon Checksum FAILED!, Chips+Overhead: %d, numPads: %d\n" psum getNumNumPads(ret))
    ); 
  );
);defmethod

;######################################################
;######################################################
;######################################################


	
