/* 
File Name     :         xyn.il
Revision      :         2.0
Part of       :         design release utilities
Client        :         Raytheon RFC
Author        :         Mark Mezger [Saxonville EDA]
Application   :         IC tools
SW Release    :         4.4.3 or later
Language      :         il
Prefix        :         xyn
 

	D e s c r i p t i o n

	user specifies primary and drop-in reticles,
	wafer size and type, number pad names

	program generates:
		wafer map cellview (can be interactively modified during run)
		full wafer cellview
		numbers mask cellview
                

        M o d i f i c a t i o n    H i s t o r y

	When		Who		What
	10/20/03	mezger		alpha 5
	10/22/03			alpha 6
	10/28/03			beta
	01/09/04			beta2
					check drop-in size, chain to prb.il
	01/27/04			change drop-in picture to plus sign,
					beta3
					now looks for wafer outline in XYnumbers lib
	01/28/04			beta4
					calc of retOffsetXm/Ym
					changed to use new wafer outline dwg
					added n+ boxes at corners of wafer dwg
	01/30/04			added a dbClose to the aeble map dwg
	02/04/04			now copy primary reticle & drop-in and
					orient the copies to their LL corners
					leaving the original reticles unchanged
	02/10/04			change to center-drop-in offset calc
					to handle unexpected GRID shapes in
					flattened partial drop-ins
	02/24/04			redefined wafer shift offsets &
					retOfsXm/Ym as appear on aeble map
	03/03/04			aeble map labels now delayed until wafer
					offsets have been determined
	03/05/04			offset map row/col numbers by 1,
					enforce correct number pad type
	04/09/04			no-shapes test removed from PresetForm1
	04/27/04			removed unexplained comment from
					xynAebleWaferOffset
	05/10/04			changes to map labeling:
					reversed waferShiftX/Y offsets,
					fixed rows & cols labels to agree w. image
	05/24/04			limit search step resolution, controlled by
					stepResolution attribute in xynpl,
					added data-extent boxes on nplus to
					numbers drawing (_wpnums/layout)
	06/03/04			final change to aeble map column labels
	06/15/04			made this program re-entrant by creating
					release/xynform.dpl file and undoing some
					of the invalidation steps
	07/09/04			changed R90 orientation of numbers to R270
	07/31/04			support 3 inch wafers,
					also fixed a bug in xynSaveForm1 which
					incorrectly wrote dpls to the xynform.dpl
					file
	08/30/04			log file now written in release/ dir
	09/27/04			modified PlaceChipNumbers so that it
					echoes progress in ciw as it runs
	09/29/04			mod to xynFindNearestDropinByCenter affecting
					the reticle offset numbers on aeble map,
					to select the drop-in site with higher row
					number (higher in y) when two sites are
					equidistance from wafer center, *think* this
					fixes an observed problem;
					added step&repeat check that insists on 10um
					resolution, can be changed in options form
	09/30/04			mod to LoadForm1 to prevent overwrite of
					editProps list from earlier runs

	01/07/05			modified xynPlaceOutline to copy the
					wafer outline from XYnumbers to the
					design lib if not already there, then
					instantiate the design-lib copy of the
					wafer outline in xyn drawings
	02/02/05			added dialog box that warns user when no
					coupons are found in reticles, this may be
					due to incorrect number pad used
	02/08/05			fix to xynCheckForCoupons,
					first cut at new output format,
					SIG change to properties stored on chip
					instances, impacts prb.il also.
					chip list file is generated immed. after
					numbers drawing generation
	02/10/05			2nd version of new output file
	03/08/05			change to number size handling viz-a-viz
					number of required digits
	07/09/05			wafer outline is now placed at y=retOlap/2,
					wafer-center cross better identified to
					discriminate it from grid shapes from 
					flattened partial reticles,
					cross is now moved when outline is shifted
					for maximum complete die,
					2714um is added to wafShiftY to account for
					wafer flat impact on outline center position.
					also noted aeble map shift to match optimum
					position was commented out, now it's handled.
	07/13/05			removed (commented) 2714um y shift
	07/13/05 B			mod to ensure wafer shift is made in aeble map
	08/23/05			fix to mod of 7/13, remove double offset of
					aeble map
	08/30/05			ui and flow rework
	09/28/05			enhanced chip/coupon list output file
	09/29/05			don't copy relDir from form dpl file,
					update drop-ins list on ui form in sync
	05/17/06 			mod to getOverlaps in PlaceCouponNumbers
	07/17/06			added wafer-offset properties:
					flatOfsX & flatOfsY
	07/17/06			added hidden file release/.flatoffsets which
					affects dialog-box flow and attempts to
					prevent using an offset when re-running an
					old design that didn't use offsets,
					minor fix to xynUpdateDropinsField()
  06/13/08 M.Conte  Revision 1.21
                    Changes to accommodate new coupon naming convention.
                    See individual functions for details.
                       Added Variables: None
                    Modified Variables: None
                       Added Functions: xynChipSort
                                        xynValidChip
                                        xynWriteFormat
                    Modified Functions: xynBuildChipList
                                        xynChipListFile
                                        xynChipListWrite
  02/06/09	mfp		procedure xynOffsetWaferOutline
					  Added code to capture capPad (ASML) Layer in wafer_4
					  Added code to move capPad Layer by  xynpl->wafOfsX : xynpl->wafOfsY
  06/19/09 M.Conte  Revision 1.23
                    Changes for forcing a specific X & Y wafer offset
                    See individual functions for details.
                       Added Variables: None
                    Modified Variables: xynpl->editProps
                       Added Functions: None
                    Modified Functions: xynInvalidate
                                        xynCreateWaferDwg

  04/27/11	mfp		procedure xynOffsetWaferOutline
					  Added code to capture  (ASML) Layer in wafer_4
					  Added code to move text,sdText,BCBLid,BCBCorral, and glass Layers by  xynpl->wafOfsX : xynpl->wafOfsY

	I s s u e s


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	C o d e   O u t l i n e

	1.) Initialization of global symbol 'xynpl holding global state variables
	2.) Main program
	3.) Main ui form definition and callback procedures
	4.) Wafer map generation
	5.) Wafer location tests
	6.) Interactive code for drop-in site selection
	7.) Number pad procedures
	8.) Search for chips in the primary and drop-in reticles
	9.) Full-wafer drawing generation
	10.) Wafer offset position selection
	11.) Numbers drawing generation
	12.) Sort methods
	13.) Log file support

*/

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-----------------------------------------------------------------------
;   1.)	Global data structure (list) definition of xynpl 
;       (npl is a disembodied property list or dpl - first entry nil)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

unless( and( boundp( 'xynpl) listp( xynpl))
  xynpl = '( nil

	version			1.23		; sw version reported in outputs

;-----	generally constant parameters:
	logfn			"xyn.log"	; log file name

	chipListFile		"chiplist.dat"	; chip list dump file
	waferLib		"reticle"	; library for wafer outlines
	numberLib		"reticle"     ; library with pads & numbers

	procTypes				; FIXME: whatever this means
	  ( "RF" "DC" "RFDC" )

	waferSizes		(		; wafer sizes in inches
	  "4"
				)

	numTypes		( 		; types of number cells
	  "numbers" "reverse"	                ; for different process families
				)

	numOffsets		( nil		; number placement positions offsets
		L		( 40 100)       ; on the xynNumPad for the different
		M		( 30 70 110)    ; sized xyn number pads
		S		( 20 45 70)
				)

	retOlap			4.0		; reticle overlap in um
	exclusionRing		5000.0		; wafer handling ring width
	outlineLyr		"resistor"	; wafer outline shape layer
	inclusionLyr		"y1"		; temporary shape layer
	exclusionLyr		"membrane"	; layer for exclusion ring
	waferCenterCrossLyr     "GRID"		; layer for "x" at center of outline
	cornerBlockLyr		"GRID"          ; 1um boxes for ebeam guys
	stepRepeatResolution	10		; expected s&r resolution

	rectUndersize		500.0		; FIXME: undersize aeblemap site rects

	searchSteps		10		; steps used in wafer position search, 0 setting overrides search
	stepResolution		0.1		; min search step resolution, um

	tmpLyr1			"y1"		; scratch layers for
	tmpLyr2			"y2"		; overlaps tests, these are
	tmpLyr3			"y3"		; system layers

	reticleLayer		"resistor"      ; reticle layer on wafer map
	dropinLayer		"numbers"	; drop-in layer on wafer map
	crossLayer		"text"		; layer for cross at drop-in sites
	ffsmapLayer1		"thick"		; rects in ffsmap drawings
	ffsmapChipLabelSize	3000		; height of chip_?? label
	ffsmapNumSize		2000		; height of number labels

	flatOfsX		500		; min wafer flat offset from grid axis
	flatOfsY		500		; ''

	editProps
	( waferLib numberLib retOlap exclusionRing rectUndersize searchSteps
	  stepResolution ffsmapChipLabelSize ffsmapNumSize stepRepeatResolution
	  flatOfsX flatOfsY wafOfsX wafOfsY
	)

	prbProps
	( libName retName dropinName mapName wafName flatName
	  exclusionRing waferLib waferCell retW retH retOlap
	  ret00X ret00Y waf00X waf00Y wafOfsX wafOfsY waferum
	  flatOfsX flatOfsY
	  nCols nRows dropinSites retChipList dropinChipList mergedChipList
	  ffsmapNumSize ffsmapLayer1 ffsmapChipLabelSize fullBound
	  dropinLayer crossLayer rectUndersize
	  chipListFile version 
	)
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;-----	parameters set during run (listed here for info):
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	logfp			nil		; log file port

						; set in inches CB:
	waferCell		nil		; name of wafer outline dwg
	wafInch			nil		; wafer in inches (string)

						; set in proc-type CB:
	procType		nil		; process type name

						; set in layers-type CB:
	numsType		nil		; mmic | hbt

						; set in library CB:
	libName			""		; reticle library name
	relDir			""		; release directory

						; set in reticle CB:
	retName			nil		; reticle cell name
	retCV			nil		; recticle cellview
	retW			nil		; reticle width um
	retH			nil		; reticle height um
	sitesName		nil		; drop-in sites drawing name
	mapName			nil		; wafer map cell name
	wafName			nil		; wafer drawing cell name
	flatName		nil		; flattened wafer cell name
	numName			nil		; numbers drawing cell name


						; set in drop-in CB:
	dropinName		nil		; name of drop-in reticle
	dropinCV		nil		; drop-in cellview

	sitesCV			nil		; for specifying drop-in sites
	mapCV			nil		; wafer map cellview
	wafCV			nil		; wafer drawing cellview
	flatCV			nil		; flattened wafer cellview
	numCV			nil		; numbers mask cellview

						; set in GetNumberPads:
	numberPads		nil		; list of num pads in des lib

						; set in number pad CB:
	padName			nil		; number pad cell name
	padCV			nil		; pad cellview
	cHeight			nil		; height of numbers
	cWidth			nil		; width of zero
	dWidth			nil		; width of dash
	cXOffset		nil		; character x offset
	cYOffset		nil		; character y offset

						; set in WaferSetup:
	ret00X			nil		; x coord of site (0 0)
	ret00Y			nil             ; y coord of site (0 0)
	waf00X			nil		; x start position of wafer outline
	waf00Y			nil             ; y start position of wafer outline
	wafOfsX			0.0		; x offset for max chip count
	wafOfsY			0.0             ; x offset for max chip count
	nCols			nil		; number of sites horizontally
	nRows			nil		; number of sites vertically
	aebleNC			nil		; FIXME: number of drawn sites horiz
	aebleNR			nil		; FIXME: number of drawn sites vert

	dropinSites		nil		; i/j pairs of drop-in sites

						; set in BuildChipLists:
	retChipList		nil		; reticle chip data list
	dropinChipList		nil		; drop-in chip data list
	mergedChipList		nil             ; primary/secondary combined chip data list
    )
);unless xynp


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynWriteDPL
;	writes a property list with data necessary for prb.il
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynWriteDPL()
  let( ( fn fp pl)

;   build a property list with the properties prb.il needs:
    pl = list( nil)
    foreach( p xynpl->prbProps
      putprop( pl get( xynpl p) p)
    )

;   open a file to write the property list to:
    when( xynpl->relDir
      fn = strcat( xynpl->relDir "xynumbers.dpl")
      fp = outfile( fn)
      cond(
        ( fp
;	  print the list to file:
	  fprintf( fp "%L" pl)
	  close( fp)
	  xynMsg( "wrote %s" fn)
	  t
        )
        ( t
	  xynErr( "failed to write file %s" fn)
	  nil
	)
      )
    )
  )
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynLogGlobals
;	writes global data dpl to log file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLogGlobals()
  let( ( p)

    xynLog( "xyn global parameters:")
    p = cdr( xynpl)
    while( p
;     don't echo list-type attributes:
      unless( cadr( p) && listp( cadr( p))
	xynLog( "   %-20s     %L" get_string( car( p)) cadr( p))
      )
      p = cddr( p)
    )
    xynLog( "end of global parameters:")
  )
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	main program
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynums()
;   create the form the first time through,
;   also preset any fields we can guess:
    unless( xynpl->form1 
      xynCreateForm1()
      xynPresetForm1()
    )

    ; This procedure call is where all the processing is done ...
    xynTriggerCBs1()

;   display the form:
    hiDisplayForm( xynpl->form1)

;   close open cellviews:
    foreach( cv '(retCV dropinCV padCV)
      when( get( xynpl cv) 
	dbClose( get( xynpl cv))
        putprop( xynpl nil cv)
      )
    )

;   write data to xynumbers.dpl for use by prb.il:
    xynWriteDPL()

;   close the log file (opened by operation buttons):
    xynLogClose()

;   write the form1 values to release/xynform.dpl:
    xynSaveForm1()

    when( xynConfirm( "Run probe file generation now?") prbout())
);procedure


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	MAIN UI FORM WITH CALLBACKS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCreateForm1()
  let( ( w1 w2 w3 y1 y2)

    w1 = 100
    w2 = 200
    w3 = 50
    y1 = 10
    y2 = y1 + 175

    xynpl->form1 = hiCreateForm( 'XYNFORM1 "XYNUMS" ""
      list(
	  list( hiCreateRadioField( ?name 'wafInch ?prompt "Wafer inches"
			?value car( last( xynpl->waferSizes))
			?choices xynpl->waferSizes
			?callback '("xynInchCB()"))
			10:y1 w1+w2+w3:25 w1)
	  list( hiCreateButton( ?name 'opts ?buttonText "Options"
			?callback "xynPLForm()")
			10+w1+w2+w3-50:y1 50:25 0)
	  list( hiCreateRadioField( ?name 'procType ?prompt "Process type"
			?value car( xynpl->procTypes)
			?choices xynpl->procTypes
			?callback '("xynProcTypeCB()"))
			10:y1+25 w1+w2+w3:25 w1)
	  list( hiCreateRadioField( ?name 'numsType ?prompt "Numbers type"
			?value car( xynpl->numTypes)
			?choices xynpl->numTypes
			?callback '("xynNumsTypeCB()"))
			10:y1+50 w1+w2+w3:25 w1)
	  list( hiCreateLabel( ?name 'l11 ?labelText "Library")
			10:y1+75+5 w1:25 0)
	  list( hiCreateButton( ?name 'libSel ?buttonText "Select"
			?callback "xynLibSelCB()")
			10+w1:y1+78 w3:25 0)
	  list( hiCreateStringField( ?name 'libName ?prompt ""
			?value ""
			?callback "xynLibCB()")
			10+w1+w3:y1+75 w2:25 0)
	  list( hiCreateLabel( ?name 'l12 ?labelText "Primary reticle")
			10:y1+100+5 w1:25 0)
	  list( hiCreateButton( ?name 'retSel ?buttonText "Select"
			?callback "xynRetSelCB()")
			10+w1:y1+103 w3:25 0)
	  list( hiCreateStringField( ?name 'retName ?prompt ""
			?value ""
			?callback "xynRetCB()")
			10+w1+w3:y1+100 w2:25 0)
	  list( hiCreateLabel( ?name 'l13 ?labelText "Drop-in reticle")
			10:y1+125+5 w1:25 0)
	  list( hiCreateButton( ?name 'dropSel ?buttonText "Select"
			?callback "xynDropSelCB()")
			10+w1:y1+128 w3:25 0)
	  list( hiCreateStringField( ?name 'dropinName ?prompt ""
			?value ""
			?callback "xynDropinCB()")
			10+w1+w3:y1+125 w2:25 0)
	  list( hiCreateLabel( ?name 'l1 ?labelText "Drop-in sites")
			10:y1+155 w1:25 0)
	  list( hiCreateButton( ?name 'mapCB ?buttonText "Choose"
			?callback "xynSitesCB()")
			10+w1:y1+153 w3:25 0)
	  list( hiCreateStringField( ?name 'dropIns ?prompt ""
			?value "" ?editable nil)
			10+w1+w3:y1+150 w2:25 0)
;	  list( hiCreateButton( ?name 'mapView ?buttonText "Edit"
;			?callback "xynMapVCB()")
;			10+w1+w2+w3:y1+178 50:25 0)
	  list( hiCreateLabel( ?name 'l1b ?labelText "Chips/Ret List")
			10:y2+5 w1:25 0)
	  list( hiCreateButton( ?name 'chipListCB ?buttonText "Create"
			?callback "xynBuildChipListCB()")
			10+w1:y2+3 w3:25 0)
	  list( hiCreateStringField( ?name 'chipList ?prompt "" ?value ""
			?editable nil)
			10+w1+w3:y2 w2:25 )
;	  list( hiCreateButton( ?name 'listView ?buttonText "View"
;			?callback "xynListVCB()")
;			10+w1+w2+w3:y2+3 50:25 0)
	  list( hiCreateLabel( ?name 'l3 ?labelText "Wafer dwg")
			10:y2+25+5 w1:25 0)
	  list( hiCreateButton( ?name 'wafCB ?buttonText "Create"
			?callback "xynWafCB()")
			10+w1:y2+28 w3:25 0)
	  list( hiCreateStringField( ?name 'wafDwg ?prompt ""
			?value "" ?editable nil)
			10+w1+w3:y2+25 w2:25 0)
;	  list( hiCreateButton( ?name 'wafView ?buttonText "View"
;			?callback "xynWafVCB()")
;			10+w1+w2+w3:y2+28 50:25 0)
	  list( hiCreateLabel( ?name 'l2 ?labelText "Numbers dwg")
			10:y2+50+5 w1:25 0)
	  list( hiCreateButton( ?name 'numCB ?buttonText "Create"
			?callback "xynNumCB()")
			10+w1:y2+53 w3:25 0)
	  list( hiCreateStringField( ?name 'numDwg ?prompt ""
			?value "" ?editable nil)
			10+w1+w3:y2+50 w2:25 0)
;	  list( hiCreateButton( ?name 'numView ?buttonText "View"
;			?callback "xynNumVCB()")
;			10+w1+w2+w3:y2+53 50:25 0)
	  list( hiCreateLabel( ?name 'l5 ?labelText "Aeble Map")
			10:y2+80 w1:25 0)
	  list( hiCreateButton( ?name 'mapVCB ?buttonText "View"
			?callback "xynMapVCB()")
			10+w1:y2+78 w3:25 0)
	  list( hiCreateStringField( ?name 'mapDwg ?prompt ""
			?value "" ?editable nil)
			10+w1+w3:y2+75 w2:25 0)
	  list( hiCreateLabel( ?name 'l6 ?labelText "Chips/Waf List")
			10:y2+105 w1:25 0)
	  list( hiCreateButton( ?name 'chipDataVCB ?buttonText "View"
			?callback "xynChipDataVCB()")
			10+w1:y2+103 w3:25 0)
	  list( hiCreateStringField( ?name 'chipData ?prompt ""
			?value "" ?editable nil)
			10+w1+w3:y2+100 w2:25 0)
	))

    hiSetFormMinMaxSize( xynpl->form1 '( 370  365) '( 370 365))
  )
);procedure


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynPresetForm1
;	considers that any open layout window is likely to be the reticle,
;	this presets the form's lib and cell to the current cellview
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPresetForm1()
  let( ( win cv)

;   a reticle layout cv will contain instances:
    win = hiGetCurrentWindow()
    when( and( win
	       hiGetWidgetType( win) == "graphics"
	       (cv = geGetWindowCellView( win))
	       cv~>viewName == "layout"
	       cv~>instances)
      xynpl->form1->libName->value = cv~>libName
      xynpl->form1->retName->value = cv~>cellName
    )
  )
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynTriggerCBs1
;	Invalidation call backs based upon latent user inputs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynTriggerCBs1()

    ;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; Invalidation call backs
    ; If user changes values during execution of the flow 
    ; then certain data generated upstream will become invalid and 
    ; have to be re-evaluatted/generated ...
    ;;;;;;;;;;;;;;;;;;;;;;;;;;
    xynpl->notInvalid = t
    xynInchCB()
    xynProcTypeCB()
    xynNumsTypeCB()
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; End of Invalidation call backs
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ; 
    xynLibCB()
    ; Run input checks on primary
    xynRetCB()
    ; Run input checks on secondary
    xynDropinCB()
    ; Everything is valid??
    xynpl->notInvalid = nil
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynSaveForm1
;	writes the form1 values in the library's release dir
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynSaveForm1()
  let( ( fn fp p)

  when( xynpl->relDir

    fn = strcat( xynpl->relDir "xynform.dpl")
    fp = outfile( fn)
    when( fp
      fprintf( fp " ( nil \n")
      foreach( pp '( wafInch procType numsType retName dropinName 
		    mapDwg chipList wafDwg numDwg chipData)
        fprintf( fp "  %s  %L \n" pp get( xynpl->form1 pp)->value)
      )
      fprintf( fp " ) \n( nil ")
      p = cdr( xynpl)
      while( p
	caseq( type( cadr( p))
;           don't echo ports, forms, windows, and dbObjects:
	  ( (port dbobject wtype formStruct)
	    nil
	  )
	  ( list
;	    only write non-nil lists:
	    when( cadr( p)
	      fprintf( fp "%s " car( p))
	      xynFormatList( fp cadr( p))
	    )
	  )
	  ( t
	    fprintf( fp "%s %L " car( p) cadr( p))
	  )
        )
        p = cddr( p)
      )
      fprintf( fp ")\n")
      close( fp)
    )
  )
  )
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynFormatList
;	formats a list, which may contain nested lists, to a file port
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynFormatList( op l)
  cond(
    ( l
      fprintf( op "( ")
      foreach( i l
        caseq( type( i)
          ( (port dbobject wtype formStruct)
	    nil
	  )
	  ( list
	    cond(
	      ( i xynFormatList( op i))
	      ( t fprintf( op "nil "))
	    )
	  )
	  ( t
	    fprintf( op "%L " i)
	  )
        )
      )
      fprintf( op ") ")
    )
    ( t
      fprintf( op "nil ")
    )
  )
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynLoadForm1
;	reads the form1 values from the library's release dir
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLoadForm1()
  let( ( fn fp dpl v p)

    fn = strcat( xynpl->relDir "xynform.dpl")
    fp = infile( fn)
    when( fp
      dpl = car( lineread( fp))
      foreach( pp '( wafInch procType numsType retName dropinName 
		    mapDwg chipList wafDwg numDwg chipData)
	v = get( dpl pp)
	when( v get( xynpl->form1 pp)->value = v)
      )
      dpl = car( lineread( fp))
      p = cdr( dpl)
      while( p
	unless( memq( car( p) '( editProps relDir)) 
	  putprop( xynpl cadr( p) car( p))
	)
	p = cddr( p)
      )
      close( fp)
      xynUpdateDropinsField()
    )
  )
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynUpdateDropinsField
;	Update the drop-in sites field.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynUpdateDropinsField()
    cond(
      ( xynpl->dropinSites
	xynpl->form1->dropIns->value = sprintf( nil "%L" xynpl->dropinSites)
      )
      ( t
	xynpl->form1->dropIns->value = ""
      )
    )
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       xynPLForm
;	form for modifying global property list values
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPLForm()
  let( ( pl fl v x y fw pw form)

;   set x position, initial y position, field width and prompt width:
    x  = 10
    y  = 10 - 25
    fw = 400
    pw = 200

;   get the list of properties that can be edited:
    pl = xynpl->editProps

;   create the list of fields from the properties:
    foreach( p pl

;     advance down the form:
      y = y + 25

;     get the property value:
      v = get( xynpl p)

;     create a field for it based on value type:
      caseq( type( v)

	( string
	  fl = cons( list( 
	    hiCreateStringField( ?name p ?prompt get_string( p) ?value v)
	    x:y fw:25 pw) fl)
	)
	( fixnum
	  fl = cons( list( 
	    hiCreateIntField( ?name p ?prompt get_string( p) ?value v)
	    x:y fw:25 pw) fl)
	)
	( flonum
	  fl = cons( list( 
	    hiCreateFloatField( ?name p ?prompt get_string( p) ?value v)
	    x:y fw:25 pw) fl)
	)
	( (list symbol)
	  cond(
	    ( v == nil || v == t
	      fl = cons( list( 
	        hiCreateBooleanButton( ?name p ?buttonText get_string( p) 
		  ?value v)
		  x:y fw:25 pw) fl)
	    )
	    ( t
	      xynErr( "Cannot support %s in properties form" get_string( p))
	    )
	  )
	)
      )
    )

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;   create the properties form here and display it
    ;   when it's OK'ed by the user, copy values back to the property list
    ;   and then deleted the ui form
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    form = hiCreateForm( 'xynProps "XYN Properties" "" fl "")
    when( hiDisplayForm( form)
      foreach( p form->fieldList
	putprop( xynpl get( form p)->value p)
      );foreach
    );when
    hiDeleteForm( form)
  );let
);procedure


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       xynLibSelCB
;	callback procs for the select buttons:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLibSelCB()
  xynpl->form1->libName->value = ""
  xynLBPopUp( xynpl->form1 'libName "Select Library" 
	      sort( ddGetLibList()~>name 'alphalessp))
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       xynRetSelCB
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynRetSelCB()
  xynpl->form1->retName->value = ""
  xynLBPopUp( xynpl->form1 'retName "Select Primary Reticle" xynLibCellList())
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;      xynDropSelCB 
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynDropSelCB()
  xynpl->form1->dropinName->value = ""
  xynLBPopUp( xynpl->form1 'dropinName "Select Drop-in" xynLibCellList())
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPadSelCB()
  xynLBPopUp( xynpl->form1 'padName "Select Number Pad Cell" xynLibCellList())
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLibCellList()
  when( parseString( xynpl->libName) 
    sort( ddGetObj( xynpl->libName)~>cells~>name 'alphalessp))
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLBPopUp( form1 symbol title choices)
  let( ( form2 v)
;   create the raw form the first time through:
    unless( xynpl->form2
      xynpl->form2 = hiCreateForm( 'XYNFORM2 "" ""
	list( list( hiCreateListBoxField( ?name 'lb ?prompt ""
			?choices '("") ?value nil)
		10:10 250:250 0)))
    )
;   inhibit this callback when the form is already up:
    unless( hiIsFormDisplayed( xynpl->form2)
;     reconfigure the form:
      form2 = xynpl->form2
      hiSetFormName( form2 title)
      form2->lb->value = nil
      form2->lb->choices = choices
      v = car( parseString( get( form1 symbol)->value))
      cond(
        ( member( v choices) 
	  form2->lb->value = list( v)
	)
	( t
	  get( form1 symbol)->value = ""
	)
      )
      cond(
;	  if the form is cancelled, do nothing:
	( null( hiDisplayForm( form2))
	  nil
	)
;	  if a value was chosen, update the parent form's field:
	( form2->lb->value
	  get( form1 symbol)->value = car( form2->lb->value)
	)
;	  if nothing was selected, set the parent's field to blank:
	( t
	  get( form1 symbol)->value = ""
	)
      )
    )
  )
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-----------------------------------------------------------------------
;	callback procs for the modifyable form fields:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynInchCB()

;   copy the wafer size from the form, invalidate anything already completed:
    xynpl->wafInch = xynpl->form1->wafInch->value
    xynInvalidate()

;   determine the wafer outline cell name:
    xynpl->waferCell = xynWaferCellName( xynpl->wafInch)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynProcTypeCB()

;   copy the process type from the form:
    xynpl->procType = xynpl->form1->procType->value

;   this doesn't actually affect anything!
;   xynInvalidate()
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynNumsTypeCB()

;   copy the numbers-type from the form:
    xynpl->numsType = xynpl->form1->numsType->value

;   invalidate the numbers drawing:
    xynInvalidate()
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLibCB()

    xynpl->libName = xynpl->form1->libName->value
    xynInvalidate()
    cond(
      ( null( parseString( xynpl->libName))
        xynpl->relDir = nil
	nil
      )
      ( null( exists( i ddGetLibList()~>name i == xynpl->libName))
        xynpl->relDir = nil
	xynErr( "library %s does not exist!" xynpl->libName)
      )
      ( t
;       determine the release directory from the library name:
        xynpl->relDir = strcat( ddGetObjReadPath( ddGetObj( xynpl->libName)) 
				"/release/")

;       ensure it exists:
        unless( or( isDir( xynpl->relDir)
	            and( xynConfirm( "Release dir not found.  Create it?")
		         createDir( xynpl->relDir) ) )
          xynErr( "no release directory available:  %s" xynpl->relDir)
	)

;	open the log file:
	xynLogOpen()

;       clear any old dropin sites:
        xynpl->dropinSites = nil

;	load any saved form1 data found in the release dir:
	xynLoadForm1() 
      )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Step 1.) Process the primary reticle
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  This procedure ensures the following:
;   
;  A.) the primary is set in the UI form
;  B.) opens up the primary reticle cell view in read mode
;  C.) makes a copy of the primary reticle cellview with and "_xyn" name extension
;      (the "_xyn" copy will be used to align the original reticle to the upper
;       left quadrant)
;  D.) Open the "_xyn" copy
;  E.) Close the original primary cellview
;  F.) Moves the "_xyn" reticle's bounding box lower left coordinate to the 
;      origin. This effectively aligns the reticle outline to the upper right
;      hand quadrant of the layout window
;  G.) Generates all the sub-view names that will be needed in further processing
;      and adds these names to the GUI form
;  H.) Measures the width and height of the reticle outline using it's bounding
;      box 
;      (FIXME: shouldn't this be done based upon the reticle outline layer???)
;  I.) Performs a Step and Repeat (S&R) check using the measured reticle outline and
;      the step and repeat resolution defined in the options form. The 
;      xynCheckRes(X,S&R_RES) function is called on both the reticle W adn L values to 
;      determine if the reticle outline is dimensioned properly for further
;      processing. The W and L values of the reticle outline must be divisible multiples
;      of the S&R resolution. For a given dimension, the following condition must be
;      satified:
;                      if(Floor(X/S&R_RES)*S&R_RES == X)
;                        true
;                      else
;                        false
; 
;      Ex 1: If the reticle W is 10,000um and the S&R_RES is 10um
;            the psuedo code above will evaluate to true
;      Ex 2: If the recticle W is 9,995um and the S&R_RES is 10um, the
;            psuedo code will evaluate to false. If the S&R resolution
;            is set to 5um, the psuedo code will evaluate to true
;
;     NOTE: The step and repeat algorithm used to maximum the number of chips
;           on a wafer uses X/S&R_RES as the maximum number of shifts before
;           ending the search. The largest number of chips that fit on the 
;           wafer after a complete shift count is used to choose the best 
;           retical array to wafer alignment to produce the maximum chip 
;           count 
;   J.) If all goes well the user is messaged that the reticle meets
;       the S&R algorithm requirements
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynRetCB()
  let( ( retName cv)

    xynpl->retName = xynpl->form1->retName->value
    xynInvalidate()
    xynMsg( "INFO: XYN VERSION 1.0" )
    cond(
;	make sure a cell name was selected:
      ( null( parseString( xynpl->retName))
	xynErr( "Cell name not set")
	nil
      )
;       open the original reticle cv:
      ( null( (cv = dbOpenCellViewByType( xynpl->libName xynpl->retName
		"layout" "maskLayout" "r")))
	xynErr( "Failed to open %s/%s/layout" xynpl->libName xynpl->retName)
      )
;       copy it to a new cellview that will be upper-right quandrantized:
      ( null( and( (retName = strcat( xynpl->retName "_xyn"))
		   dbSave( cv xynpl->libName retName "layout")))
	xynErr( "Failed to save %s/%s/layout" xynpl->libName retName)
      )
;	open the reticle cellview copy:
      ( null( (xynpl->retCV = dbOpenCellViewByType( xynpl->libName retName
		"layout" "maskLayout")))
	xynErr( "Failed to open %s/%s/layout" xynpl->libName retName)
      )
      ( t
	dbClose(cv)

;       put the reticle in the upper-right quandrant (positive x & y):
	xynUpperRightQuadrant( xynpl->retCV)

;       determine paths and names from the reticle:
	xynpl->sitesName = strcat( xynpl->retName "_sites")
	xynpl->mapName = strcat( xynpl->retName "_aeblemap")
	xynpl->numName = strcat( xynpl->retName "_wpnums")
	xynpl->wafName = strcat( xynpl->retName "_wafer")
	xynpl->flatName = strcat( xynpl->retName "_wafer_flat")

;       determine reticle step-size dimensions:
	xynpl->retW = caadr( xynpl->retCV~>bBox) - caar( xynpl->retCV~>bBox)
	 	      - xynpl->retOlap
	xynpl->retH = cadadr( xynpl->retCV~>bBox) - cadar( xynpl->retCV~>bBox) 
		      - xynpl->retOlap

;	step & repeat resolution check:
	unless( and( xynCheckRes( xynpl->retW xynpl->stepRepeatResolution)
		     xynCheckRes( xynpl->retH xynpl->stepRepeatResolution))
	  hiGetAttention()
	  ;xynErr( "ERROR: Reticle dimensions violate step & repeat resolution settings")
	  xynMsg( "Reticle Width: %g  Height: %g  S&R Resolution: %g"
		  float( xynpl->retW) float( xynpl->retH) 
		  float( xynpl->stepRepeatResolution))
	  hiDisplayAppDBox( ?name 'badReso ?dboxBanner "XYN ERROR"
		?dboxText sprintf( nil "Reticle S&R resolution is currently set to: %g"
				   float( xynpl->stepRepeatResolution)))
	  xynpl->retCV = nil
	  xynpl->retName = ""
	  xynpl->form1->retName->value = ""
	)
        xynMsg( "Valid Reticle Dimensions:  %s, Width=%f X Height=%f" xynpl->retName
		xynpl->retW xynpl->retH)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCheckRes( distance resolution)

  equal( fix( distance / resolution) * resolution 
	  distance)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Step 2.) Process the secondary reticle
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  This procedure ensures the following:
;   
;  A.) the secondart is set in the UI form
;  B.) opens up the secondary reticle cell view in read mode
;  C.) makes a copy of the secondary reticle cellview with and "_xyn" name extension
;      (the "_xyn" copy will be used to align the original reticle to the upper
;       left quadrant)
;  D.) Open the "_xyn" copy
;  E.) Close the original secondary cellview
;  H.) Measures the width and height of the reticle outline using its bounding
;      box 
;      (FIXME: shouldn't this be done based upon the reticle outline layer???)
;  I.) Moves the "_xyn" secondary reticle's bounding box lower left coordinate to the 
;      origin. This effectively aligns the reticle outline to the upper right
;      hand quadrant of the layout window 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

procedure( xynDropinCB()
  let( ( cv dropinName box w h)

    xynpl->dropinName = xynpl->form1->dropinName->value
    xynInvalidate()

    cond( 
;	make sure a cell name was selected:
      ( null( parseString( xynpl->dropinName))
	nil
      )
;       open the original dropin cv:
      ( null( (cv = dbOpenCellViewByType( xynpl->libName
			xynpl->dropinName "layout" "maskLayout")))
	xynErr( "Failed to open %s/%s/layout" xynpl->libName xynpl->dropinName)
      )
;       copy it to a new cellview that will be upper-right quandrantized:
      ( null( and( (dropinName = strcat( xynpl->dropinName "_xyn"))
		   dbSave( cv xynpl->libName dropinName "layout")))
	xynErr( "Failed to save %s/%s/layout" xynpl->libName dropinName)
      )
;	open the dropin cellview copy:
      ( null( (xynpl->dropinCV = dbOpenCellViewByType( xynpl->libName dropinName
		"layout" "maskLayout")))
	xynErr( "Failed to open %s/%s/layout" xynpl->libName dropinName)
      )
      ( t
	dbClose( cv)

        xynLog( "Secondary:      %s" xynpl->dropinName)

;	compare the drop-in's step & repeat with the primary reticle, must match:
	box = xynpl->dropinCV~>bBox
	w = caadr( box) - caar( box) - xynpl->retOlap
	h = cadadr( box) - cadar( box) - xynpl->retOlap
	cond(
	  ( or( w != xynpl->retW
		h != xynpl->retH)
	    xynErr( "Secondary Reticle Dimensions do not match Primary Reticle!")
	    xynMsg( "Secondary:  %s/%s" xynpl->libName xynpl->dropinName)
	    xynMsg( "             Width=%g  Height=%g" w h)
	    xynMsg( "Primary  :  %s/%s" xynpl->libName xynpl->retName)
	    xynMsg( "          Width=%g  Height=%g" xynpl->retW xynpl->retH)
	    xynConfirm( "Primary and Secondary Dimensions do not match")
	  )
	  ( t
	    xynMsg( "Secondary Reticle dimensions match Primary Reticle")
;	    put the drop-in in the upper-right quandrant (positive x & y):
	    xynUpperRightQuadrant( xynpl->dropinCV)
	  )
	)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Created : ---
; Revised : 06/19/09
; Revised : ---
; Version : 1.1
; Author  : Mark Mezger (Editor: Matt Conte)
; Email   : --- (Editor: Matthew_Conte@raytheon.com)
;
; Description: Invalidates run-time variables by resetting them to a 'default'
;              value. This is run when the user changes some imput data that would
;              compromise the other values accuracy.
;
; Revisions: 1.1 - (1) Added exception for invalidating X and Y wafer offsets.
;                        searchSteps = 0 :: Override of search algorithm
;               
; Usage: xynInvalidate()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynInvalidate()
  unless( xynpl->notInvalid

    xynCloseCVs()

    xynpl->form1->mapDwg->value = ""
    xynpl->form1->numDwg->value = ""
    xynpl->form1->wafDwg->value = ""
    xynpl->form1->chipList->value = ""
    xynpl->form1->chipData->value = ""

    xynpl->numDwg = nil
    xynpl->wafDwg = nil
    xynpl->retChipList = nil
    xynpl->dropinChipList = nil
    xynpl->mergedChipList = nil
    unless( xynpl->searchSteps == 0 ;Check for search algorithm override
      xynpl->wafOfsX = 0.0
      xynpl->wafOfsY = 0.0
    )

    ; let's not delete any cellviews from the library here,
    ; they'll get recreated from scratch anyway.
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCloseCVs()
  let( ( cv)

    foreach( cvn '( mapCV wafCV flatCV numCV)
      cv = get( xynpl cvn)
      ;when( cv && dbIsId( cv) dbPurge( cv))
      when( !null(cv) && dbIsId( cv) 
        dbSave( cv)
        dbClose(cv)
      );when
      putprop( xynpl nil cvn)
    )
  )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	callback procs for the major operations
;	SitesCB
;	creates the wafer site map and opens it in a window 
;       so user can modify the drop-in sites:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynSitesCB()

;   write info we have so far to the log file:
    xynLog( "Library:     %s" xynpl->libName)
    xynLog( "Release Dir  %s" xynpl->relDir)
    xynLog( "Reticle:     %s" xynpl->retName)
    xynLog( "Drop-In:     %s" xynpl->dropinName)
    xynLog( "Reticle WxH: %f x %f" xynpl->retW xynpl->retH)

;   preset center offsets to 0:
    xynpl->retOffsetXm = 0.
    xynpl->retOffsetYm = 0.

;   clear all steps:
    xynInvalidate()

    xynMsg( "[Button]  Create wafer map")
    cond(
;	must have the reticle loaded:
      ( null( xynpl->retCV)
	xynErr( "Cannot create wafer map without reticle.")
      )
;	must have the drop-in loaded:
      ( null( xynpl->dropinCV)
	xynErr( "Cannot create wafer map without drop-in.")
      )
;   	create the wafer map:
      (	xynCreateSitesMap()
	xynMsg( "Wafer map created:  %s" xynpl->sitesName)

;	allow the user to modify it:
	xynWaferMapMod()
      )
      ( t
	xynMsg( "Wafer map generation failed.")
      )
    )
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	MapCB
;	creates the aeble wafer site map
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynMapCB()

    cond(
;	must have the reticle loaded:
      ( null( xynpl->retCV)
	xynErr( "Cannot create wafer map without reticle.")
      )
;	must have the drop-in loaded:
      ( null( xynpl->dropinCV)
	xynErr( "Cannot create wafer map without drop-in.")
      )
;   	create the wafer map:
      (	xynCreateAebleMap()
	xynMsg( "Wafer map created:  %s" xynpl->mapName)
      )
      ( t
	xynMsg( "Wafer map generation failed.")
      )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	BuildChipListCB
;	identifies the chips from the list of number pads
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynBuildChipListCB()

    xynMsg( "[Button]  Build chip lists")
    xynInvalidate()

    cond(
;	must have the reticle loaded:
      ( null( xynpl->retCV)
	xynErr( "Cannot create chip list without reticle.")
      )
;	must have the drop-in loaded:
      ( null( xynpl->dropinCV)
	xynErr( "Cannot create chip list without drop-in.")
      )
;	build the list of chips for the primary and drop-in reticles:
      (	xynBuildChipLists()
	xynMsg( "Chip lists completed:  %s" xynpl->chipListFile)

;	put the chip list file name on the form to indicate it's been done:
	xynpl->form1->chipList->value = xynpl->chipListFile

;	write the lists to a file and display it:
	view( xynPrintChipLists())
      )
      ( t
	xynMsg( "Chip lists failed.")
      )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	WafCB
;	creates the wafer-size drawing containing the reticles
;	with the numbers drawing overlaid
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynWafCB()
    xynMsg( "[Button]  Create wafer drawings")
    cond(
;	must have the reticle loaded:
      ( null( xynpl->retCV)
	xynErr( "Cannot create wafer drawing without reticle.")
      )
;	must have the drop-in loaded:
      ( null( xynpl->dropinCV)
	xynErr( "Cannot create wafer drawing without drop-in.")
      )
;	must have built the chip lists:
      ( null( and( xynpl->retChipList xynpl->dropinChipList))
	xynErr( "Cannot create wafer drawing without chip lists.")
      )
;	must have specified (or defaulted) the drop-in sites:
      ( null( xynpl->dropinSites)
	xynErr( "Please specify drop-in sites before creating wafer drawings.")
      )
;	create the wafer drawings:
      ( xynCreateWaferDwg()
	xynMsg( "Wafer drawings creation completed:  %s and %s"
		xynpl->wafName xynpl->flatName)

;	put the wafer dwg name on the form to indicate it's been done:
	xynpl->form1->wafDwg->value = xynpl->wafName

;	create the aeble map drawing:
	xynCreateAebleMap()

;	put the map cellname on the form to indicate it's been done:
	xynpl->form1->mapDwg->value = xynpl->mapName

;	update the drop-in sites field:
	xynpl->form1->dropIns->value = sprintf( nil "%L" xynpl->dropinSites)

;	display the wafer drawing:
	xynWafVCB()
      )
      ( t
	xynMsg( "Wafer drawing creation failed.")
      )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynNumCB
;	1.) generates the individual number cells,
;	2.) creates the wafer-size numbers drawing
;           which is overlayed onto the wafer cellview 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynNumCB()

    xynMsg( "[Button]  Create numbers drawing")
    cond(
;	must have the reticle loaded:
      ( null( xynpl->retCV)
	xynErr( "Cannot create numbers drawing without reticle.")
      )
;	must have the drop-in loaded:
      ( null( xynpl->dropinCV)
	xynErr( "Cannot create numbers drawing without drop-in.")
      )
;	must have specified (or defaulted) the drop-in sites:
      ( null( xynpl->dropinSites)
	xynErr( "Please specify drop-in sites before creating numbers drawing.")
      )
;	must have created the wafer dwg:
      ( null( xynpl->flatCV)
	xynErr( "Cannot create numbers drawing without wafer drawing.")
      )
;	create the numbers drawing:
      (	xynCreateNumbersDwg()
	xynMsg( "Numbers generation completed:  %s" xynpl->numName)

;	put the numbers dwg name on the form to indicate it's been done:
	xynpl->form1->numDwg->value = xynpl->numName

;	create the chip data output file:
	xynChipListFile()
      )
      ( t
	xynMsg( "ERROR: Numbers generation failed.")
      )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-----------------------------------------------------------------------
;	callbacks for viewing results
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynMapVCB()
  let( ( win)

    when( xynpl->mapCV && ddGetObj( xynpl->libName xynpl->mapName "layout")
      win = hiOpenWindow()
      geOpen( ?window win ?lib xynpl->libName ?cell xynpl->mapName
	      ?view "layout" ?viewType "maskLayout")
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynListVCB()

  when( xynpl->chipListFile 
    view( xynpl->chipListFile)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;xynWafVCB: 
;          This procedure opens a cellview window that presents the
;          wafer layout with the optimized offset reticle array.
;          This is a visual output from the Step and Repeat (S&R) algorithm
;          that optimizes the number of complete chips that can 
;          be fabricated on the wafer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynWafVCB()
  let( ( win)
    xynMsg( "Entered xynWafVCB")
    when( xynpl->wafName && ddGetObj( xynpl->libName xynpl->wafName "layout")
    	  win = hiOpenWindow()
    	  geOpen( ?window win 
	  	  ?lib xynpl->libName 
		  ?cell xynpl->wafName
	     	  ?view "layout" 
		  ?viewType "maskLayout");geOpen 
    );when
    xynMsg( "Exiting xynWafVCB")
  );let
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynNumVCB()
  let( ( win)

    when( xynpl->numName && ddGetObj( xynpl->libName xynpl->numName "layout")
      win = hiOpenWindow()
      geOpen( ?window win ?lib xynpl->libName ?cell xynpl->numName
	      ?view "layout" ?viewType "maskLayout")
    )
  )
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynChipDataVCB()

    when( xynpl->chipDataFile
      view( xynpl->chipDataFile)
    )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	wafer map generation
;	xynCreateSitesMap
;	creates a wafer map using colored rectangles to represent
;	reticle and drop-in sites
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCreateSitesMap()
  let( ( cv)

    xynMsg( "creating sites map...")

;   create the wafer map drawing:
    cv = dbOpenCellViewByType( xynpl->libName xynpl->sitesName "layout"
				"maskLayout" "w")
    xynpl->sitesCV = cv

    cond(
      ( cv
;	place the wafer outline to determine its width:
	xynPlaceOutline( cv)

;       calculate the reticle site setup and initial wafer offset:
        xynWaferSetup()

;	move the wafer outline to the correct position:
	xynSetWaferPosition( cv)

;       determine the default drop-in sites:
        unless( xynpl->dropinSites xynDefaultDropSites())

;	update the dropins field on the ui:
	xynUpdateDropinsField()

;	draw the reticle sites as colored rectangles:
	xynDrawWaferSites( cv)

;	shift the wafer outline to match the wafer drawings:
	xynOffsetWaferOutline( cv)

;	save it:
	dbSave( cv)
      )
      ( t
	xynErr( "failed to create %s/%s/layout"
		xynpl->libName xynpl->sitesName)
	nil
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynCreateAebleMap
;	creates a wafer map using colored rectangles to represent
;	reticle and drop-in sites
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCreateAebleMap()
  let( ( cv)

    xynMsg( "creating aeble map...")

;   create the wafer map drawing:
    cv = dbOpenCellViewByType( xynpl->libName xynpl->mapName "layout"
				"maskLayout" "w")
    xynpl->mapCV = cv

    cond(
      ( cv
;	place the wafer outline to determine its width:
	xynPlaceOutline( cv)

;	move the wafer outline to the correct position:
	xynSetWaferPosition( cv)

;	shift the wafer outline to match the wafer drawings:
	xynOffsetWaferOutline( cv)

;	draw the reticle sites as colored rectangles:
	xynDrawWaferSites( cv)

;	label it only after the wafer offsets have been determined:
	xynLabelWaferDwg( cv)

;	save it:
	dbSave( cv)
      )
      ( t
	xynErr( "failed to create %s/%s/layout"
		xynpl->libName xynpl->mapName)
	nil
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynWaferCellName( inches)

  xynpl->waferCell = strcat( "wafer_" inches)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynPlaceOutline
;	instantiates the wafer outline drawing on the given wafer map
;       measures the width of the wafer based upon the wafer overlay/outline
;       layer in the wafer outline cellview. Subtracts a default parameter of
;       5000um from the width representing a 2500 exclusion ring on either side
;       FIXME: THIS IS NOT THE ACTUAL exclusion ring of 1500um as measured on
;              the actual wafer outline cellview (Wafer_4). Why isn't the
;              exlusion ring being measured from the actual 
;       FIXME: The bounding box IS NOT defined by the actual wafer outlin in
;              the cellview, but it is being defined by the sdText rectangles
;              that straddle the wafer outline (alignment windows?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPlaceOutline( cv)
  let( ( master inst dx dy w)
    xynMsg("Entering xynPlaceOutline")
;   first determine if the wafer outline is in the design lib,
;   if not, copy it there from XYnumbers:
    cond(
      ( ddGetObj( xynpl->libName xynpl->waferCell "layout")
	nil
      )
      ( and( (master = dbOpenCellViewByType( xynpl->waferLib xynpl->waferCell
					     "layout" "maskLayout" "r"))
	     dbSave( master xynpl->libName xynpl->waferCell "layout"))
	xynMsg( "copied %s/%s/layout to %s/%s/layout"
		xynpl->waferLib xynpl->waferCell 
		xynpl->libName xynpl->waferCell)
      )
      ( t
	xynErr( "failed to find %s/%s/layout" xynpl->waferLib xynpl->waferCell)
      )
    );cond

;   open the appropriate wafer outline:
    master = dbOpenCellViewByType( xynpl->libName xynpl->waferCell
				   "layout" "maskLayout" "r")
    cond(
      ( master

;	create an instance of the outline:
	inst = dbCreateInst( cv master nil 0:0 "R0" 1)
	dbClose( master)

;	move it to be in the upper-right quandrant (positive x & y):
	dx = 0 - caar( inst~>bBox)
	dy = 0 - cadar( inst~>bBox)
	dbMoveFig( inst cv list( dx:dy "R0"))

;	move it up 2um (or retOlap / 2) so that btm row of chips is aligned
;	with wafer outline flat:
	dbMoveFig( inst cv list( list( 0 xynpl->retOlap / 2.) "R0"))

;	determine the wafer width in microns from the overlay bBox,
;	flat may be on bottom or left, so larger dimension is the one we want:
	dx = caadr( inst~>bBox) - caar( inst~>bBox)
	dy = cadadr( inst~>bBox) - cadar( inst~>bBox)
	w = dx
	when( dy > dx w = dy)
	xynpl->waferum = w

      )
      ( t
	xynErr( "failed to open wafer outline %s/%s/layout"
		xynpl->libName xynpl->waferCell)
      )
    );cond
    xynMsg("Entering xynPlaceOutline")
  );let
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynOffsetWaferOutline
;	given the aeble map or the wafer drawing,
;	shift the outline shapes and the center cross by wafOfsX/Y
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynOffsetWaferOutline( cv)
  let( ( tform outlines ring wafer cross ASMLcapPad ASMLtext ASMLsdText ASMLglass ASMLBCBCorral ASMLBCBLid shape
         inst cd_cross ASMLgateBus)

;   transform the shapes by offsetting in x & y the amount chosen during opt:
    tform = list( xynpl->wafOfsX : xynpl->wafOfsY "R0")

;   ring and wafer are the only 2 shapes on outline layer:
    outlines = car( exists( lpp cv~>layerPurposePairs 
			    lpp~>layerName == xynpl->outlineLyr))~>shapes
;   Capture ASML capPad Layers
    ASMLcapPad = car( exists( lpp cv~>layerPurposePairs 
			    lpp~>layerName == "capPad" ))~>shapes
    ASMLtext = car( exists( lpp cv~>layerPurposePairs 
			    lpp~>layerName == "text" ))~>shapes
    ASMLsdText = car( exists( lpp cv~>layerPurposePairs 
			    lpp~>layerName == "sdText" ))~>shapes
    ASMLglass = car( exists( lpp cv~>layerPurposePairs 
			    lpp~>layerName == "glass" ))~>shapes
    ASMLBCBCorral = car( exists( lpp cv~>layerPurposePairs 
			    lpp~>layerName == "BCBCorral" ))~>shapes
    ASMLBCBLid = car( exists( lpp cv~>layerPurposePairs 
			    lpp~>layerName == "BCBLid" ))~>shapes
    ASMLgateBus = car( exists( lpp cv~>layerPurposePairs 
			    lpp~>layerName == "gateBus" ))~>shapes

    cd_cross = exists( i cv~>instances rexMatchp( "cd_cross" i~>cellName) )
    unless( length( outlines) == 2
      xynErr( "unexpected number of outline shapes, should be 2, is %d"
		  length( outlines))
    )

;   NOTE: we're not being careful to distiguish the wafer outline from the ring
;   here since we're moving both of them the same amount anyway:
;   NOTE: The separation of ring and wafer outlines is done in the "xynSetWaferPosition"
;   procedure.
    ring = car( outlines)
    when( ring dbMoveFig( ring cv tform))
    wafer = cadr( outlines)
    when( wafer dbMoveFig( wafer cv tform))

    ; Shift ASML capPad Layer
    when( ASMLcapPad
      foreach( shape ASMLcapPad
        dbMoveFig( shape cv tform)
      )
    )
    when( ASMLtext
      foreach( shape ASMLtext
        dbMoveFig( shape cv tform)
      )
    )
    when( ASMLsdText
      foreach( shape ASMLsdText
        dbMoveFig( shape cv tform)
      )
    )
    when( ASMLglass
      foreach( shape ASMLglass
        dbMoveFig( shape cv tform)
      )
    )
    when( ASMLBCBCorral
      foreach( shape ASMLBCBCorral
        dbMoveFig( shape cv tform)
      )
    )
    when( ASMLBCBLid
      foreach( shape ASMLBCBLid
        dbMoveFig( shape cv tform)
      )
    )
    when( ASMLgateBus
      foreach( shape ASMLgateBus
        dbMoveFig( shape cv tform)
      )
    )
    when( cd_cross
      foreach( inst cd_cross
        dbMoveFig( inst cv tform)
      )
    )

;   move the center cross the same amount:
    cross = xynFindCenterCross( cv)
    when( cross dbMoveFig( cross cv tform))

    dbSave( cv)
    printf( "shifted %s by %L\n" cv~>cellName tform)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynFindCenterCross
;	given the aeble map or the wafer drawing,
;	find the center cross shape considering that there may be
;	other shapes on the same layer due to partial reticle flattening
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynFindCenterCross( cv)
  let( ( grids cross)

;   find the center of the wafer outline, it's a cross (on GRID, typically):
    grids = setof( i cv~>shapes i~>layerName == xynpl->waferCenterCrossLyr)

;   there may be other shapes on the same layer from flattened partial reticles,
;   but the cross we seek will have precisely 12 vertices,
;   and it will have a square bBox:
;   ACTUALLY, it may not be perfectly square, allow .01 difference in sides:
;   (this .01 error has been observed but not really explained)
    cross = car( exists( i grids 
			 and( length( i~>points) == 12
			      abs( (caadr( i~>bBox) - caar( i~>bBox)) -
				   (cadadr( i~>bBox) - cadar( i~>bBox))) <= 0.01)))
    unless( cross
      xynErr( "failed to find cross on %s at center of wafer drawing!"
		xynpl->waferCenterCrossLyr)
    )
    cross
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynSetWaferPosition
;	moves wafer outline instance to waf00
;	outline is assumed to be on layer xynpl->outlineLyr
;	the outline shape is copied and downsized by xynpl->exclusionRing (um),
;	then a ring-shape is created covering the exclusion zone
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynSetWaferPosition( cv)
  let( ( inst wafer ring)

;   get the wafer outline instance:
    inst = car( exists( i cv~>instances i~>cellName == xynpl->waferCell))

    cond(
      ( inst

;	move it into position:
	dbMoveFig( inst cv list( list( xynpl->waf00X - caar( inst~>bBox)
				       xynpl->waf00Y - cadar( inst~>bBox)) "R0"))

;	flatten it:
	dbFlattenInst( inst 1)

;	get the two wafer outline shapes: mfp020609
	wafer = setof( i cv~>shapes (i~>layerName == xynpl->outlineLyr) )
	unless( length( wafer) == 2
	  xynErr( "Didn't get expected two shapes on %s from wafer outline!"
		  xynpl->outlineLyr)
	)

;	make 1st shape the inner ring:
	when( caadr( car( wafer)~>bBox) > caadr( cadr( wafer)~>bBox)
	  wafer = reverse( wafer)
	)

;	move the inner shape to a dummy layer:
	car( wafer)~>layerName = xynpl->inclusionLyr
	ring = car( leLayerAndNot( cv list( xynpl->outlineLyr "drawing") 
				   list( xynpl->inclusionLyr "drawing")
				   list( xynpl->exclusionLyr "drawing")))
	ring~>layerName = xynpl->outlineLyr
	xynpl->ring = ring

;	save the effective wafer outline shape:
	xynpl->wafer = cadr( wafer)
      )
      ( t
	xynErr( "failed to find wafer outline instance (%s) in %s/layout"
		xynpl->waferCell cv~>cellName)
	nil
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynWaferSetup
; 1.) Calculates the number of rows and columns in the wafer reticle array
; 2.) Based upon the reticle array dimensions determines the maximum dimensions
;     of a rectangular bounding box that fits within the exclusion ring of the
;     wafer outline.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynWaferSetup()
  let( ( x y nc nr)

;   set the 0,0 reticle site at xy=(0,0),
;   then offset the wafer outline:
    xynpl->ret00X = 0
    xynpl->ret00Y = 0
    xynpl->waf00X = 0
    xynpl->waf00Y = 0

;   determine the number of rows and columns of reticle sites:
    x = (xynpl->waferum - xynpl->ret00X) / xynpl->retW + 1
    nc = fix( x)
    when( x - nc > 0 nc = nc + 1)
    y = (xynpl->waferum - xynpl->ret00Y) / xynpl->retH + 1
    nr = fix( y)
    when( y - nr > 0 nr = nr + 1)
    xynpl->nCols = nc
    xynpl->nRows = nr

;   determine the dimensions of a fully on-wafer rect bound:
    xynpl->fullBound = (xynpl->waferum - xynpl->exclusionRing) / 4.

  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynDrawWaferSites
;	draws rects for wafer sites with iX/jY properties
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynDrawWaferSites( cv)
  let( ( l r b m)

;   determine the actual number of rows and columns drawn for labeling later:
    xynpl->aebleNR = 0
    xynpl->aebleNC = 0

;   step through the sites:
    for( i 0 xynpl->nCols - 1
      for( j 0 xynpl->nRows - 1

	when( or( xynIsFullSite( i j) xynIsPartialSite( i j))

;	  select different layers for reticles vs. drop-ins,
;	  draw a rect at die sites, a "+" in the rect at drop-in sites:
	  b =  xynSizeBox( xynSiteBox( i j) 0 - xynpl->rectUndersize)
	  cond(
	    ( xynIsDropInSite( i j)
	      l = xynpl->dropinLayer
	      m = (caar( b) + caadr( b)) / 2
	      dbCreateLine( cv xynpl->crossLayer 
		list( list( m cadar( b) + xynpl->rectUndersize)
		      list( m cadadr( b) - xynpl->rectUndersize)))
	      m = (cadar( b) + cadadr( b)) / 2
	      dbCreateLine( cv xynpl->crossLayer 
		list( list( caar( b) + xynpl->rectUndersize m)
		      list( caadr( b) - xynpl->rectUndersize m)))
	    )
	    ( t
	      l = xynpl->reticleLayer
	    )
	  )
	  r = dbCreateRect( cv l 
		xynSizeBox( xynSiteBox( i j) 0 - xynpl->rectUndersize))

;	  add coordinate properties to the rectangle (for the editor):
	  r~>iX = i
	  r~>jY = j

	  when( i > xynpl->aebleNC xynpl->aebleNC = i)
	  when( j > xynpl->aebleNR xynpl->aebleNR = j)
	)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynDefaultDropSites
;	creates the initial list of drop-in sites using rules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynDefaultDropSites()
  let( ( j row i k)

;   bottom 2 sites are separated by at least one reticle site,
    j = 0
    while( j < xynpl->nRows && null( row)
      i = 0
      while( i < xynpl->nCols && null( xynIsFullSite( i j)) i = i + 1)
      when( i < xynpl->nCols
	k = xynpl->nCols
	while( k > i + 1 && null( xynIsFullSite( k j)) k = k - 1)
	when( k > i + 1 row = j)
      )
      j = j + 1
    )

;   upper site is center/left and two rows above the bottom sites:
    xynpl->dropinSites = nil
    when( row
      xynpl->dropinSites = list( list( i row) list( k row)
		 		 list( fix( (xynpl->nCols - 2) / 2) row + 2))
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynLabelWaferDwg
;	adds text annotation to the given wafer map
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLabelWaferDwg( cv)
  let( ( x y s xa ya xw yw waferShiftX waferShiftY site retOfsX retOfsY nr nc)

;   label rows and columns:
    x = xynpl->retW / 2
    y = 0 - xynpl->ffsmapChipLabelSize / 2
    for( i 0 xynpl->aebleNC
      dbCreateLabel( cv "text" x:y sprintf( nil "%d" i)
			"upperCenter" "R0" "stick" xynpl->ffsmapChipLabelSize)
      x = x + xynpl->retW
    )

    x = 0 - xynpl->ffsmapChipLabelSize / 2
    y = xynpl->retH / 2
    for( j 0 xynpl->aebleNR
      dbCreateLabel( cv "text" x:y sprintf( nil "%d" j)
			"centerRight" "R0" "stick" xynpl->ffsmapChipLabelSize)
      y = y + xynpl->retH
    )

;   determine wafer offset dimensions WRT center of reticle array:
;   center of array:
    xa = (xynpl->aebleNC + 1) * xynpl->retW / 2.
    ya = (xynpl->aebleNR + 1) * xynpl->retH / 2.
;   center of wafer:
    s = xynFindWaferCenter( cv)
    xw = car( s)  yw = cadr( s)
    waferShiftX = xw - xa
    waferShiftY = yw - ya

;   2714um is added to y shift to account for wafer flat impact on wafer
;   center position:
;   COMMENTED 7/13/05, this appears to be redundant
;   waferShiftY = waferShiftY + 2714.

;   number of rows and columns labelled here include the "zero-th" row/col:
    nr = xynpl->aebleNR + 1
    nc = xynpl->aebleNC + 1

;   determine reticle offsets (the new way):
    site = xynFindNearestDropinByCenter( xw yw)
    retOfsX = (car( site) + 0.5) * xynpl->retW - xw
    retOfsY = (cadr( site) + 0.5) * xynpl->retH - yw

;   side labels:
    x = (xynpl->aebleNC + 1) * xynpl->retW + 2000
    y = (xynpl->aebleNR - 1) * xynpl->retH
    s = xynpl->ffsmapChipLabelSize * 1.2
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "Design Name= %s" xynpl->libName)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "retXm= %f" xynpl->retW)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "retYm= %f" xynpl->retH)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "rows= %d" nr)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "cols= %d" nc)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "retOffsetXm= %f" retOfsX)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "retOffsetYm= %f" retOfsY)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "waferShiftX= %f" waferShiftX)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "waferShiftY= %f" waferShiftY)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y
	sprintf( nil "Reticle Array Dimensions=")
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y
	sprintf( nil " %g,%g:%g,%g"
		 0 - xa, 0 - ya, xa, ya)
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    dbCreateLabel( cv "text" x:y 
	sprintf( nil "Date= %s" getCurrentTime())
	"lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
    y = y - s
    xynLabelDropinSites( cv x y s)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Labels the drop in sites in the target cellview and generates the 
; drop in site location section of the output file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLabelDropinSites( cv x y s)
  let( ( fn fp)

    fn = strcat( xynpl->relDir "dropinLocations")    ; OR TBD
    cond(
;	if 5 drop-ins or less, write their LLCs to the drawing:
      ( length( xynpl->dropinSites) <= 5
	foreach( site xynpl->dropinSites

	  dbCreateLabel( cv "text" x:y 
	    sprintf( nil "Drop-In Offset:  %g:%g"
	    car( site) * xynpl->retW  cadr( site) * xynpl->retH)
	    "lowerLeft" "R0" "stick" xynpl->ffsmapChipLabelSize)
	  y = y - s
	)
      )
      ( null( (fp = outfile( fn)))
	xynErr( "Failed to write dropin locations file:  %s" fn)
      )
      ( t
;	when > 5 drop-ins, write their LLCs to a file:
	foreach( site xynpl->dropinSites
	  fprintf( fp "%g %g\n" car( site) * xynpl->retW  cadr( site) * xynpl->retH)
	)
	close( fp)
	xynMsg( "wrote drop-in locations to file: %s" fn)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;     find the dropin site with center nearest to x,y;
;     in case of a tie, the one in the higher row wins:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynFindNearestDropinByCenter( x y)
  let( ( site d dmin )
    dmin = xynpl->waferum
    foreach( dropin xynpl->dropinSites
      d = sqrt( (x - car( dropin) * xynpl->retW)**2 +
		(y - cadr( dropin) * xynpl->retH)**2)
      when( d < dmin || d == dmin && cadr( dropin) > cadr( site)
	site = dropin
	dmin = d
      )
    )
    site
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Shifts the top level bbox instance origin of a cellview to the upper right
; hand quadrant
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynUpperRightQuadrant( cv)
  let( ( box dx dy shift)

    box = cv~>bBox
    unless( caar( box) == 0 && cadar( box) == 0
      dx = 0 - caar( box)
      dy = 0 - cadar( box)
      shift = list( list( dx dy) "R0")
      xynMsg( "NOTE:  shifting %s to upper-right quadrant" cv~>cellName)
      xynMsg( "       shift is: %f by %f" caar( shift) cadar( shift))
      dbReopen( cv "a")
      xynShiftCV( cv shift)
      dbSave( cv)
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Shifts every instance and shape within a cellview by the input argument.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynShiftCV( cv shift)

    foreach( inst cv~>instances dbMoveFig( inst cv shift))
    foreach( shape cv~>shapes   dbMoveFig( shape cv shift))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-----------------------------------------------------------------------
;	wafer location tests. Is this a drop-in (Secondary Site)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynIsDropInSite( i j)
  let( ( pair)

    pair = list( i j)
    exists( s xynpl->dropinSites s == pair)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynIsFullRect
;       This is the boolean operations that determine if a bbox is fully
;	within the INCLUSION region of the wafer, the object must overlap the 
;       INCLUSION region of the wafer (ring) and must not overlap the exclusion 
;       ring (region defined between the wafer and ring outlines)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynIsFullRect( box)

  or(
;	 to save time with layer boolean operations,
;	 if the box is within 1/4 of the exclusion-ring width of the wafer center,
;        it's considered "full":
    and(
	 abs( xynpl->waferum / 2 - caar( box))   < xynpl->fullBound
	 abs( xynpl->waferum / 2 - caadr( box))  < xynpl->fullBound
	 abs( xynpl->waferum / 2 - cadar( box))  < xynpl->fullBound
	 abs( xynpl->waferum / 2 - cadadr( box)) < xynpl->fullBound
       )

    and(
	 xynOverlaps( box xynpl->wafer)
	 null( xynOverlaps( box xynpl->ring))
       )
   )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynIsFullObject( object)

    xynIsFullRect( object~>bBox)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynIsFullSite( i j)

    xynIsFullRect( xynSiteBox( i j))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynIsPartialRect
;	to be partly "on-wafer", the object must overlap the exclusion ring
;	and the effective wafer outline:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynIsPartialRect( box)

    and(
;	 xynOverlaps( box xynpl->wafer)
	 xynOverlaps( box xynpl->ring)
       )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynIsPartialObject( object)

    xynIsPartialRect( object~>bBox)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynIsPartialSite( i j)

    xynIsPartialRect( xynSiteBox( i j))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynSiteBox
;	returns the bBox of the given site
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynSiteBox( i j)
  let( ( x y)

    x = xynpl->ret00X + float( i) * xynpl->retW
    y = xynpl->ret00Y + float( j) * xynpl->retH
    list( list( x y) list( x + xynpl->retW y + xynpl->retH))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynSiteBox
;	returns the bBox of the given site
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynSizeBox( box offset)

  list( list( caar( box) - offset	cadar( box) - offset)
	list( caadr( box) + offset	cadadr( box) + offset)
      )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynOverlaps
;	determines if the given bBox overlaps the polygon
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynOverlaps( box poly)
  let( ( cv)

    cv = poly~>cellView

;   ensure temp layers are empty:
    xynOverlapsCleanup( cv)

;   create the rect box on first layer:
    dbCreateRect( cv xynpl->tmpLyr1 box)

;   copy the polygon to 2nd layer:
    dbCopyFig( poly cv)~>layerName = xynpl->tmpLyr2

    cond(
;	when the rect ANDs with the poly onto 3rf layer, return t:
      ( leLayerAnd( cv 	list( xynpl->tmpLyr1 "drawing")
			list( xynpl->tmpLyr2 "drawing")
			list( xynpl->tmpLyr3 "drawing"))
	xynOverlapsCleanup( cv)
	t
      )
      ( t
	xynOverlapsCleanup( cv)
	nil
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	
;	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynOverlapsCleanup( cv)

    foreach( lsym '( tmpLyr1 tmpLyr2 tmpLyr3)
      xynDeleteLayer( cv get( xynpl lsym))
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynDeleteLayer
;	deletes all shapes in cellview on specified layer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynDeleteLayer( cv layerName)
  let( ( lpp)

    lpp = car( exists( l cv~>layerPurposePairs l~>layerName == layerName))
    foreach( shape lpp~>shapes dbDeleteObject( shape))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;       xynWaferMapMod
;	Interactive code for drop-in site selection.
;	Opens a window so that the wafer outline map can be "edited",
;	edits should be restricted to using the 'q' key which is
;	redefined temporarily
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynWaferMapMod()

    xynMsg( "Entering interactive map-edit mode...")
    xynMsg( "Select Window->Close when done specifying drop-in sites.")

;   change the 'q' bindkey to our local function:
    hiSetBindKey( "Layout" "<Key>q" "xynWaferMapModCB()")

;   enable the callback:
    xynpl->ModCBInhibit = nil

;   open a window to edit the wafer map,
;   when it's closed it calls our other local function to reset bindkey:
    xynpl->wafmodWin = hiOpenWindow( ?closeProc 'xynMapModCloseCB)
    geOpen( ?window xynpl->wafmodWin ?lib xynpl->libName ?cell xynpl->sitesName
		?view "layout" ?viewType "maskLayout")
)

;	xynMapModClose
;	forces the window closed when it is no longer valid

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	
;	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynMapModClose()

    when( windowp( xynpl->wafmodWin) hiUnmapWindow( xynpl->wafmodWin))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynMapModCloseCB
;	dfII calls this when the wafer map mod window is closed
;	to reset the bindkey
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynMapModCloseCB( win)

    xynMsg( "Exiting interactive map-edit mode.")
    hiSetBindKey( "Layout" "<Key>q" "leHiEditProp()")
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynWaferMapModCB
;	this is called in placed of the usual bindkey function,
;	pops-up a form to allow the selected site's use to be changed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynWaferMapModCB()
  let( ( ss r1 r2 iX jY form lyr m)

;   select what's under the cursor:
    geDeselectAll()
    geSelectPoint()
    ss = geGetSelSet()

    cond(
      ( xynpl->ModCBInhibit
	xynErr( "You are already modifying a wafer site.")
      )
;	should be only 1 object selected and it should have expected props:
      ( or( null( (r1 = car( ss)))
	    cdr( ss)
	    r1~>objType != "rect"
	    null( (iX = r1~>iX))
	    null( (jY = r1~>jY)) )
	xynErr( "Please point at a wafer site rectangle or cross.")
      )
      ( t
;	prevent another callback while the form is up:
	xynpl->ModCBInhibit = t

;	create the form first time through:
	unless( xynpl->form3 xynCreateForm3())

;	set the form values from the selected shape:
	form = xynpl->form3
	form->iX->value = iX
	form->jY->value = jY
	form->usage->value = if( r1~>layerName == xynpl->dropinLayer 
				 "drop-in" "reticle")

;	open the form, then if it's OK'ed...
	when( hiDisplayForm( form)

;	  unselect the rect:
	  geDeselectAll()

;	  if the site usage was changed...
	  lyr = if( form->usage->value == "drop-in" xynpl->dropinLayer
						    xynpl->reticleLayer)
	  unless( lyr == r1~>layerName

	    cond(
	      ( lyr == xynpl->dropinLayer
		r2 = dbCreateRect( r1~>cellView lyr r1~>bBox)
		r2~>iX = iX
		r2~>jY = jY
		m = (caar( r1~>bBox) + caadr( r1~>bBox)) / 2
		dbCreateLine( r1~>cellView xynpl->crossLayer 
		  list( list( m cadar( r1~>bBox) + xynpl->rectUndersize)
		        list( m cadadr( r1~>bBox) - xynpl->rectUndersize)))
		m = (cadar( r1~>bBox) + cadadr( r1~>bBox)) / 2
		dbCreateLine( r1~>cellView xynpl->crossLayer 
		  list( list( caar( r1~>bBox) + xynpl->rectUndersize m)
		        list( caadr( r1~>bBox) - xynpl->rectUndersize m)))
		dbDeleteObject( r1)
	      )
	      ( t
		r2 = dbCreateRect( r1~>cellView lyr r1~>bBox)
		r2~>iX = iX
		r2~>jY = jY
		m = dbGetOverlaps( r1~>cellView r1~>bBox "text")
		foreach( o m dbDeleteObject( o))
		dbDeleteObject( r1)
	      )
	    )

;	    always re-save the cv when a change is made:
	    dbSave( xynpl->sitesCV)

;	    update the dropinSite list:
	    case( form->usage->value
;		add a new drop-in site to the list:
	      ( "drop-in"
		xynpl->dropinSites = cons( list( iX jY) xynpl->dropinSites)
	      )
;		remove a drop-in site and implicitly put a reticle there:
	      ( t
		xynpl->dropinSites = remove( list( iX jY) xynpl->dropinSites)
	      )
	    )

;	    and update the drop-ins field on the ui form:
	    xynUpdateDropinsField()
	  )
	)

;	re-enable the callback:
	xynpl->ModCBInhibit = nil
      )
    )
    geDeselectAll()
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	
;	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCreateForm3()

  xynpl->form3 = hiCreateForm( 'XYNFORM3 "Site Usage" ""
    list(
	list( hiCreateIntField( ?name 'iX ?prompt "iX" ?value 0
		?editable nil)
		10:10 300:25 100)
	list( hiCreateIntField( ?name 'jY ?prompt "jY" ?value 0
		?editable nil)
		10:35 300:25 100)
	list( hiCreateRadioField( ?name 'usage ?prompt "Usage"
		?value "reticle" ?choices '("reticle" "drop-in"))
		10:60 300:25 100)
	)
    );list
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	number pad procedures
;	xynGetNumberPads
;	searches the design lib for number pads,
;	builds a list of dpl describing each pad cell
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynGetNumberPads()

    xynMsg( "Acquiring number pads...")
    xynpl->numberPads = 
      foreach( mapcar pad xynFindNumberPadCells()
        xynGetNumberPadInfo( pad)
      )
    if(null(xynpl->numberPads) then
      xynMsg( "Number pads NOT found in build library")
      xynMsg( "Copy them from the reticle library and rename them with the following pattern:")
      xynMsg( "DESIGN_REV_xyPad_XXX")
    else
      xynPrintNumberPads()
    );
   
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynFindNumberPadCells
;	find the number pads in the current library
;	assumes name pattern "DESIGN_REV_xynum_XXX"
;	returns a list of the number padd cell names
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynFindNumberPadCells()
    setof( c xynLibCellList()
	   caddr( parseString( c "_")) == "xyPad")
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynGetNumberPadInfo
;	returns a dpl for the given number pad name
;	deciphering the last part of the name into
;	chip-type, number-type, and size
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynGetNumberPadInfo( cellName )
  let( ( des chiptype numtype size)

;   get the last part of the cell name:
    des = car( last( parseString( cellName "_")))

    cond(
      ( or( null( des) strlen( des) < 3)
	xynErr( "Bad number pad cell name:  %s" cellName)
	nil
      )
      ( t
	chiptype = case( substring( des 3 1)
			 ("A" 	"chip")
			 ("B"	"coupon")
			 ( t	nil))

	numtype =  case( substring( des 1 1)
			 ("S"   "numbers")
			 ("R"   "reverse")
			 ( t	nil))

	size = substring( des 2 1)

	xynMsg( "number pad:  %-20s %-8s %-10s %s" cellName chiptype
		numtype size)

	list( nil
		'name		cellName
		'chipType	chiptype
		'numType	numtype
		'size		size)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	
;	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPrintNumberPads()

    xynMsg( "Number Pads found in library:")
    foreach( pad xynpl->numberPads
      xynMsg( "  %-40s %-10s %-10s %s" pad->name pad->chipType
		pad->numType pad->size)
    )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	search for chips in the primary and drop-in reticles
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynBuildChipLists()

;   find the number pad cells in the design lib:
    xynGetNumberPads()

;   build chip list for the primary reticle:
    xynpl->retChipList    = xynBuildChipList( xynpl->retCV)

;   build chip list for the drop-in:
    xynpl->dropinChipList = xynBuildChipList( xynpl->dropinCV)

;   build merged chip list:
    xynMergeChipLists()

;   check that number pad types match specified number type:
    xynCheckNumberPads()

;   check that one or more coupons were found, if not, warn the user:
    xynCheckForCoupons()

    t
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Created : ---
; Revised : 06/05/08
; Revised : ---
; Version : 1.1
; Author  : Mark Mezger (Editor: Matt Conte)
; Email   : --- (Editor: Matthew_Conte@raytheon.com)
;
; Description: Searches the given reticle cellview for instances containing the
;              specified xy number pad cell, returns a list of chip cells, each
;              chip has the following properties:
;                     name - the chip cell name
;                  padLocn - coordinates of the number pad
;                padOrient - pad orientation
;               chipOrient - chip orientation in reticle
;                 chipPosn - list of chip locations within the reticle
;
; Revisions: 1.1 - (1) Modified the sort routine utilized at the end of the
;                      function to accomodate the changes in coupon naming
;                      convention adopted 06/08.
;               
; Usage: xynBuildChipList( cv)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynBuildChipList( cv )
  let( ( pi cl sites nc nd ns)

;   search for each number pad, return the list of pads with their chips:
    foreach( pad xynpl->numberPads

;     search the instance masters of the given cellview:
      foreach( ih cv~>instHeaders

;       look for instances whose layout cv's contain an instance of padCell:
        when( (pi = car( exists( i car( ih~>instances)~>master~>instances
				 i~>cellName == pad->name)))

;	  sort the chip sites within the reticle:
	  sites = sort( ih~>instances~>xy 'xynXySort)

;	  determine the number of digits required:
	  nc = xynEstimateMaxChipCount( sites)
;	  nd = if( nc < 100 2 3)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;         FIXME: Why was this change implemented? Changed because "most chips will have 2 digit numbers".
;                What about the edge cases that require 3 digits? Does this utility just not work?!?!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	  CHANGED so that most chips wil have 2-digit numbers,
;	  only have 3 digits where required (and correspondingly smaller nums)
	  nd = 2

;	  determine size of numbers to use:
	  ns = pad->size
	  when( nd == 3 ns = case( ns ("L"  "M")  ("M"  "S")  ("S"  "S")))

;	  build a list of the chip cells, 
;	  each with a dpl describing the cell and its instances:
	  cl = cons( list( nil
			 'name		ih~>cellName
			 'padName       pad->name
			 'chipType	pad->chipType
			 'padSize	pad->size
			 'numType	pad->numType
			 'numSize	ns
			 'padLocn	pi~>xy
			 'padOrient	pi~>orient
			 'digits	nd
			 'chipOrient	car( ih~>instances)~>orient
			 'chipPosn	sites
			 'chipBox	car( ih~>instances)~>bBox
			)
		     cl)
        )
      )
    )

;   sort the list by chip name:
    sort( cl 'xynChipSort)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynEstimateMaxChipCount
;	sites are assumed to have already been sorted by xy.
;	figures out how high x and y chip numbers will go based on
;	the chip positions in the reticle and the nRows/nCols on the wafer,
;	returns the larger number (x or y)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynEstimateMaxChipCount( reticleSites)
  let( ( y nx ny ix sl)

;   determine the number of chip x and y-coordinates per reticle:
    y = -1  nx = 0  ny = 0  ix = 0
    sl = reticleSites
    while( sl
      unless( cadar( sl) == y
	ix = 0
	ny = ny + 1
	y = cadar( sl)
      )
      ix = ix + 1
      nx = max( nx ix)
      sl = cdr( sl)
    )

;   assume same number of chips in reticle and drop-in
;   (this may over-estimate a little)
    max( nx * xynpl->nCols
	 ny * xynpl->nRows)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPrintChipLists()
  let( ( fn op)

;   print chipList to a file:
    fn = strcat( xynpl->relDir "chipList.dat")
    cond(
      ( null( (op = outfile( fn)))
	xynErr( "failed to write file %s" fn)
      )
      ( t
	fprintf( op "Primary Reticle:  %s/%s\n" xynpl->libName xynpl->retName)
	fprintf( op "Chip                 Type   Pad                 ")
        fprintf( op "           Sites Digits\n")
	foreach( chip xynpl->retChipList
	  fprintf( op "%-20s %-6s %-30s %5d %6d\n" chip->name, chip->chipType,
		   chip->padName length( chip->chipPosn) chip->digits)
	)
	fprintf( op "\nChip Sites:\n")
	foreach( chip xynpl->retChipList
	  fprintf( op "  %s, pad at %L %s\n" chip->name
		   chip->padLocn chip->padOrient)
	  foreach( posn chip->chipPosn
	    fprintf( op "    %L\n" posn)
	  )
	)
	fprintf( op "\n\n")

	fprintf( op "Drop-in Reticle:  %s/%s\n" xynpl->libName xynpl->dropinName)
	fprintf( op "Chip                 Type   Pad                 ")
        fprintf( op "           Sites Digits\n")
	foreach( chip xynpl->dropinChipList
	  fprintf( op "%-20s %-6s %-30s %5d %6d\n" chip->name, chip->chipType,
		   chip->padName length( chip->chipPosn) chip->digits)
	)
	fprintf( op "\nChip Sites:\n")
	foreach( chip xynpl->dropinChipList
	  fprintf( op "  %s, pad at %L %s\n" chip->name
		   chip->padLocn chip->padOrient)
	  foreach( posn chip->chipPosn
	    fprintf( op "    %L\n" posn)
	  )
	)
	fprintf( op "\n\n")

	close( op)
	xynMsg( "wrote %s" fn)
      )
    )

;   return the file name:
    xynpl->chipListFile = fn
    fn
  )
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynMergeChipLists()
  let( ( cl cd)

    foreach( chip xynpl->retChipList
      cd = copy( chip)
      cd->chipPosn = copy( chip->chipPosn)
      cl = cons( cd cl)
    )
    foreach( chip xynpl->dropinChipList
      cd = car( exists( c cl c->name == chip->name))
      cond(
	( cd
	  nil
;	  cd->dropinPosn = copy( chip->chipPosn)
	)
	( t
	  cd = copy( chip)
	  cd->chipPosn = copy( chip->chipPosn)
;	  cd->chipPosn = nil
	  cl = cons( cd cl)
	)
      )
    )
    xynpl->mergedChipList = cl
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynCheckNumberPads
;	the merged chip list identifies primary & drop-in chips
;	along with their number pad type (among other things),
;	this proc compares that info with the number type selected in ui
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCheckNumberPads()
  let( ( err)

    foreach( chip xynpl->mergedChipList
      unless( chip->numType == xynpl->numsType
	xynErr( "Chip %s has number pad type:  %s" chip->name chip->numType)
	err = t
      )
    )
    when( err
      xynMsg( "Numbers type is currently set to:  %s", xynpl->numsType)
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCheckForCoupons()
  let( ( coupons)

    coupons = setof( c xynpl->mergedChipList equal( c->chipType "coupon"))
    unless( coupons
      xynConfirm( 
	strcat( "No coupons were found in either reticle.\n"
		"This may be because an incorrect number pad was used."))
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynListAllChips
;	returns a list of all the chip names found in reticle and drop-in
;	this is used to select chips for a probe pass
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynListAllChips()
  let( ( cl)

;   list all the chips in the primary reticle:
    foreach( chip xynpl->retChipList cl = cons( chip->name cl))

;   add any unique chips in the drop-in:
    foreach( chip xynpl->dropinChipList
      unless( member( chip->name cl) cl = cons( chip->name cl))
    )

;   return list of chips sorted by name:
    sort( cl 'alphalessp)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynGetChipSiteData
;	extract the sites dpl for the given chip
;	from either the reticle or drop-in chip list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynGetChipSiteData( chipName chipListName)

  car( exists( chip get( xynpl chipListName) chip->name == chipName))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-----------------------------------------------------------------------
;	full-wafer drawing generation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Created : ---
; Revised : 06/19/09
; Revised : ---
; Version : 1.1
; Author  : Mark Mezger (Editor: Matt Conte)
; Email   : --- (Editor: Matthew_Conte@raytheon.com)
;
; Description: Creates the drawing with reticles & drop-ins plus the numbers
;              overlay
;
; Revisions: 1.1 - (1) Removed the reassignment of the X & Y wafer offsets to
;                      allow for user defined setting in the options menu.
;               
; Usage: xynCreateWaferDwg()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCreateWaferDwg()
  prog( ( cv urb urx ury)
;   create the flat wafer drawing:
    cv = dbOpenCellViewByType( xynpl->libName xynpl->flatName "layout"
			       "maskLayout" "w")
    xynpl->flatCV = cv
    cond(
      ( cv
        xynMsg( "creating flat wafer drawing...")

;	place the wafer and exclusion shapes:
	xynPlaceOutline( cv)

;	derive exclusion ring:
	xynSetWaferPosition( cv)

;	place the reticles and drop-ins:
	xynPlaceWaferSites( cv t)

;	bring the chips to top level:
	xynFlattenInstances( cv)

;	select wafer offset:
	cond(
	  ( xynpl->searchSteps > 0
	    unless( xynSelectWaferOffset( cv) return( nil))
	  )
	  ( t
      xynMsg( "User Specified Wafer Offset: %10.1f %10.1f"
        xynpl->wafOfsX xynpl->wafOfsY)
;	    xynpl->wafOfsX = 0.0
;	    xynpl->wafOfsY = 0.0
	  )
	)

;	save it:
	dbSave( cv)

;	create the wafer drawing:
	cv = dbOpenCellViewByType( xynpl->libName xynpl->wafName "layout"
				   "maskLayout" "w")
	xynpl->wafCV = cv
	cond(
	  ( cv
	    xynMsg( "creating wafer drawing...")

;	    place the wafer outline:
	    xynPlaceOutline( cv)

;	    derive the exclusion ring:
	    xynSetWaferPosition( cv)

;	    offset the wafer to the best found:
	    xynOffsetWaferOutline( cv)

;	    place the reticles and drop-ins:
	    xynPlaceWaferSites( cv)

;	    flatten the partial sites:
	    xynFlattenPartialInstances( cv)

;	    add Nplus rects at LL & UR corners of array:
	    dbCreateRect( cv xynpl->cornerBlockLyr '((0 0) (1 1)))
	    urb = xynSiteBox( xynpl->maxCol xynpl->maxRow)
	    urx = caadr( urb)  ury = cadadr( urb)
	    dbCreateRect( cv xynpl->cornerBlockLyr list( list( urx ury)
							 list( urx - 1 ury - 1)))

;	    determine retOffsetXm/Ym:
	    xynFindCentermostSecondaryOffset( cv)

	    xynLabelWaferDwg( cv)	; WANT THIS HERE?
	    dbSave( cv)

	  )
	  ( t
	    xynErr( "failed to create %s/%s/layout"
		    xynpl->libName xynpl->wafName)
	    return( nil)
	  )
	)
      )
      ( t
	xynErr( "failed to create %s/%s/layout" 
	        xynpl->libName xynpl->flatName)
	return( nil)
      )
    )
    return( t)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynPlaceWaferSites
;	populates the given wafer drawing with reticle & drop-in instances
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPlaceWaferSites( cv @optional (all nil))
  let( ( x y)

;   find the upper-right-most corner of the matrix:
    xynpl->maxCol = 0
    xynpl->maxRow = 0

;   step through the grid:
    for( i 0 xynpl->nCols
      for( j 0 xynpl->nRows

;	do full and partial reticle sites:
	when( or( all xynIsFullSite( i j) xynIsPartialSite( i j))

	  x = xynpl->ret00X + float( i) * xynpl->retW
	  y = xynpl->ret00Y + float( j) * xynpl->retH

;	  instantiate appropriate cellview:
	  cond(
	    ( xynIsDropInSite( i j)
	      dbCreateInst( cv xynpl->dropinCV
			    sprintf( nil "drop_in_%d_%d" i j)
			    x:y "R0" 1)
	    )
	    ( t
	      dbCreateInst( cv xynpl->retCV
			    sprintf( nil "reticle_%d_%d" i j)
			    x:y "R0" 1)
	    )
	  )
	  when( i > xynpl->maxCol xynpl->maxCol = i)
	  when( j > xynpl->maxRow xynpl->maxRow = j)
	)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynFlattenPartialInstances( cv)
  let( ( instances box)

    instances = setof( i cv~>instances
			or( eq( i~>master xynpl->retCV)
			    eq( i~>master xynpl->dropinCV)))
    foreach( inst instances
      when( xynIsPartialObject( inst)
	box = inst~>bBox
        dbFlattenInst( inst 1)
;       delete shapes on GRID contained within reticles:
        foreach( s dbGetOverlaps( cv box list( xynpl->waferCenterCrossLyr "drawing"))
	  dbDeleteObject( s )
	);foreach
      );when
    );foreach
;    xynRemoveInvalidDieSites( cv )
  );let
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This procedure removes all invalid die from partial reciticles in
; the "_wafer" cell view
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;procedure( xynRemoveInvalidDieSites( cv )
;  let((instances sites box)
;    xynMsg( "Entered xynRemoveInvalidDieSites")
;    instances = setof( i cv~>instances or(eq( i~>master xynpl->retCV) eq( i~>master xynpl->dropinCV)))
;    foreach( inst instances
;      when( xynIsPartialObject( inst )
;        sites = inst~>instances 
;	foreach(site sites
;           box = site~>bBox
;	   if(dbGetOverlaps( cv box list( xynpl->waferCenterCrossLyr "drawing" )) then
;             dbDeleteObject( site )
;          );if
;        );foreach
;      );when
;     );foreach
;    xynMsg( "Exited xynRemoveInvalidDieSites")
;  );let
;);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynFlattenInstances( cv)
  let( ( instances exc)

    instances = setof( i cv~>instances
			or( eq( i~>master xynpl->retCV)
			    eq( i~>master xynpl->dropinCV)))

    foreach( inst instances dbFlattenInst( inst 1))

;   delete shapes contained within reticles:
    exc = list( xynpl->ring xynpl->wafer)
    foreach( s cv~>shapes
      unless( memq( s exc) dbDeleteObject( s))
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynOverlayNumbers
;	instantiates the numbers drawing over the wafer cellview (wpnums?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynOverlayNumbers()

;   if numbers are regenerated, no need to re-instantiate:
    unless( exists( i xynpl->wafCV~>instHeaders i~>cellName == xynpl->numName)

;     create an instance of the number's mask on the wafer dwg:
      dbCreateInst( xynpl->wafCV xynpl->numCV "numbers" 0:0 "R0" 1)

    )

;   resave it regardless, this avoids a bogus "Want to save changes" pop-up:
    dbSave( xynpl->wafCV)
    xynLog( "%s re-saved." xynpl->wafName)


;   if numbers are regenerated, no need to re-instantiate:
    unless( exists( i xynpl->flatCV~>instHeaders i~>cellName == xynpl->numName)

;     repeat this for the flattened wafer dwg:
      dbCreateInst( xynpl->flatCV xynpl->numCV "numbers" 0:0 "R0" 1)
    )

;   resave it:
    dbSave( xynpl->flatCV)
    xynLog( "%s re-saved." xynpl->flatName)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; xynSelectWaferOffset:
;
;   This is where the S&R optimization of valid sites are calculated
;   1.) The primary reticle is scanned to determine the chip that has
;       the highest occurance in the reticle
;   2.) The Y coordinate is held constant and the wafer outline is
;       shifted in the X coordinate base upon the S&R resolution
;   3.) At each X step, The number of the chips (selected in step 1) that are FULLY
;       in the INCLUSION ZONE of the wafer are calculated. This is limited
;       by max search steps. The X coordinate with the max chips is stored.
;   4.) With the X coordinate value determined in step 3, the wafer outline is
;       shifted in the Y coordinate base upon the S&R resolution
;   5.) At each Y step, The number of the chips (selected in step 1) that are FULLY
;       in the INCLUSION ZONE of the wafer are calculated. This is limited
;       by max search steps. The Y value with the max number of chips is stored
;   
;       
;	wafer offset search for max die count
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynSelectWaferOffset( cv)
  prog( ( chip dx dy res ofs count y x n)

;   maximize the chip that has the most instances in the primary reticle:
    chip = xynFindProductionDie()

;   confirm this operation with the user:
    unless( xynConfirmOffsetSettings( chip) return( nil))

;   determine the step size for position sweep:
    dx = (caadr(  chip->chipBox) - caar(  chip->chipBox)) / (2. * xynpl->searchSteps)
    dy = (cadadr( chip->chipBox) - cadar( chip->chipBox)) / (2. * xynpl->searchSteps)

;   limit step resolution:
    res = xynpl->stepResolution
    dx = round( dx / res) * res
    dy = round( dy / res) * res

;   search for the best position:
    xynMsg( "searching for best wafer position for %s..." chip->name)
    count = 0

    xynMsg( "      Xofs       Yofs     N")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Sweep in x with y = 0:
;   changed 7/16/06 mm:
;    x = 0. ;  - xynpl->searchSteps * dx
;    y = 0.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    x = float( xynpl->flatOfsX)
    y = float( xynpl->flatOfsY)
    for( i 0 xynpl->searchSteps

	dbMoveFig( xynpl->ring cv list( x:y "R0"))
	dbMoveFig( xynpl->wafer cv list( x:y "R0"))
        
        ; This is where the die count is stored per iteration
	n = xynCountFullDie( cv chip->name)
	xynMsg( "%10.1f %10.1f   %3d\n" x y n)

	dbMoveFig( xynpl->ring cv list( -x:-y "R0"))
	dbMoveFig( xynpl->wafer cv list( -x:-y "R0"))

	when( n > count
	  count = n
	  ofs = list( x y)
	)
	x = x + dx
    )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Sweep in y with best x:
;    y = 0. ;  - xynpl->searchSteps * dy
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    xynMsg( "INFO(xynSelectWaferOffset): Best X Shift Coordinate: %f" x)
    xynMsg( "INFO(xynSelectWaferOffset): Stepping the wafer oulines in the y direction ...")
    y = float( xynpl->flatOfsY)
    x = car( ofs)
    for( j 0 xynpl->searchSteps

	dbMoveFig( xynpl->ring cv list( x:y "R0"))
	dbMoveFig( xynpl->wafer cv list( x:y "R0"))

	n = xynCountFullDie( cv chip->name)
	xynMsg( "%10.1f %10.1f   %3d\n" x y n)

	dbMoveFig( xynpl->ring cv list( -x:-y "R0"))
	dbMoveFig( xynpl->wafer cv list( -x:-y "R0"))

        ; Count stores the maximum number of targeted chips that 
        ; are within the wafer INCLUSION ZONE
	when( n > count
	  count = n
	  ofs = list( x y)
	)
      y = y + dy
    )

    xynMsg( "best wafer offset:  %10.1f %10.1f %3d chips" 
	    car( ofs) cadr( ofs) count)

;   restore the best position:
    dbMoveFig( xynpl->ring cv list( ofs "R0"))

;   set the offsets in the dpl:
    xynpl->wafOfsX = car( ofs)
    xynpl->wafOfsY = cadr( ofs)
    return( t)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynConfirmOffsetSettings( chip)
  let( ( fn fp ok ln)

    fn = strcat( xynpl->relDir ".flatoffsets")
    cond(
;	if release/.flatoffsets exists, read the prior offset values
;	and restore the offset values:
      ( isReadable( fn)
	fp = infile( fn)
	ln = car( lineread( fp))
	close( fp)
	when( numberp( cadr( ln))   xynpl->flatOfsX = cadr( ln))
	when( numberp( cadddr( ln)) xynpl->flatOfsY = cadddr( ln))
	ok = hiDisplayAppDBox( ?name 'offsetCheck 
	  ?dboxBanner "Confirm Wafer Offset Options"
	  ?dboxText strcat( "This newer design used flat offset(s).\n"
			       "Optimized chip:  " chip->name "\n"
		   sprintf( nil "Flat Offset X:   %f\nFlat Offset Y:   %f\n"
				float( xynpl->flatOfsX)
				float( xynpl->flatOfsY))
	"Click Cancel & use the Options form if you need to change the flat offsets.\n")
	)
	when( ok xynWriteFlatOffsetsFile( fn))
	ok
      )
;	if .flatoffsets isn't there...
      ( hiDisplayAppDBox( ?name 'offsetCheck 
	  ?dboxBanner "Confirm Wafer Offset Options"
	  ?dboxText strcat( "This APPEARS to be a new design.\n"
			       "Optimized chip:  " chip->name "\n"
		   sprintf( nil "Flat Offset X:   %f\nFlat Offset Y:   %f\n"
				float( xynpl->flatOfsX)
				float( xynpl->flatOfsY))
		"If this is really an OLD design (that didn't use flat offsets)\n"
		"Click Cancel now.\n")
	  )
	xynMsg( "Wafer-flat minimum offsets are:  x = %f  y = %f"
		float( xynpl->flatOfsX) float( xynpl->flatOfsY))
	xynWriteFlatOffsetsFile( fn)
	t
      )
      ( hiDisplayAppDBox( ?name 'offsetCheck2
	  ?dboxBanner "Please Confirm Old Design"
	  ?dboxText   strcat( "Confirm you want to re-run an old design with\n"
				"zero minimum wafer flat offsets")
	)
	xynMsg( "Setting wafer-flat minimum offsets to zero for old design.")
	xynpl->flatOfsX = 0
	xynpl->flatOfsY = 0
	t
      )
      ( t
	xynMsg( "Cancelling run.")
	nil
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynWriteFlatOffsetsFile( fn)
  let( ( fp)

    fp = outfile( fn)
    cond(
      ( fp
        fprintf( fp "( flatOfsX %f flatOfsY %f )\n"
  	  float( xynpl->flatOfsX) float( xynpl->flatOfsY))
        close( fp)
	xynLog( "wrote file %s" fn)
      )
;      if we can't write the file, report error and abort run:
      ( t
        hiGetAttention()
        xynErr( "Failed to write offsets file %s" fn)
        nil
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynFindProductionDie()
  let( ( die ndie n)

    ndie = 0
    foreach( chip xynpl->retChipList
      n = length( chip->chipPosn)
      when( n > ndie
	ndie = n
	die = chip
      )
    )
    die
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCountFullDie( cv name)
  let( ( ih)

    ih = car( exists( i cv~>instHeaders i~>cellName == name))
    length( setof( i ih~>instances xynIsFullObject( i)))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynFindWaferCenter( cv)
  let( ( cross cx cy)

    cross = xynFindCenterCross( cv)
    when( cross

;     calculate the coords of the center of the cross from its bBox:
      cx = (caar( cross~>bBox) + caadr( cross~>bBox)) / 2.
      cy = (cadar( cross~>bBox) + cadadr( cross~>bBox)) / 2.

;     return the point:
      list( cx cy)
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynFindCentermostSecondaryOffset( cv)
  let( ( cross cx cy md b d dx dy cs xm ym)

    cross = xynFindWaferCenter( cv)
    cx = car( cross)  cy = cadr( cross)

;   find the drop-in site nearest this point:
    md = xynpl->waferum			; (preset minimum to a big value)
    foreach( s xynpl->dropinSites
      b = xynSiteBox( car( s) cadr( s))
      cond(
	( caar( b)  > cx   	dx = caar( b) - cx )	; right of center
	( caadr( b) < cx	dx = cx - caadr( b) )   ; left of center
	( t			dx = 0 )		; over the center
      )
      cond(
	( cadar( b) > cy	dy = cadar( b) - cy )	; above center
	( cadadr( b) < cy	dy = cy - cadadr( b))	; below center
	( t			dy = 0 )		; over the center
      )
      d = 0.
      when( dx > 0 || dy > 0 d = sqrt( dx*dx + dy*dy))

;     save the center-most site and its offset:
      when( d < md md = d cs = s)
    )

;   now the centermost drop-in is cs, find the distance to its center:
    xynMsg( "centermost drop-in site is %d %d" car( cs) cadr( cs))
    b = xynSiteBox( car( cs) cadr( cs))
    xm = (caar( b) + caadr( b)) / 2. - cx
    ym = (cadar( b) + cadadr( b)) / 2. - cy

    xynpl->retOffsetXm = xm
    xynpl->retOffsetYm = ym
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; xynCreateNumbersDwg: 
;
;     Create numbers drawing cellview
;     1.) Creates the cellview for the numbers array
;     2.) Instantiates the chip and coupon numbers at the number pad
;         positions within the numbers cellview
;     3.) Places nPlus rectangles at the ur and ll of the array??
;     4.) saves the numbers cellview
;     5.) Opens the wafer cellview and overlays the numbers array
;         cellview instance over the wafer cellview using a call to
;         "xynOverlayNumbers". Now the numbers should appear at the correct
;         number pad locations in the wafer cellview
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynCreateNumbersDwg()
  let( ( cv urb urx ury)

;   create the empty number mask cellview:
    xynpl->numCV = dbOpenCellViewByType( xynpl->libName xynpl->numName
			"layout" "maskLayout" "w")
    cv = xynpl->numCV

    cond(
      ( cv
	xynMsg( "Generating numbers cellview %s..." xynpl->numName)

;	place the numbers:
	xynPlaceChipNumbers()
	xynPlaceCouponNumbers()

;       add Nplus rects at LL & UR corners of array:
	dbCreateRect( cv xynpl->cornerBlockLyr '((0 0) (1 1)))
	urb = xynSiteBox( xynpl->maxCol xynpl->maxRow)
	urx = caadr( urb)  ury = cadadr( urb)
	dbCreateRect( cv xynpl->cornerBlockLyr list( list( urx ury)
						     list( urx - 1 ury - 1)))

;	save the cellview:
	dbSave( xynpl->numCV)
	xynMsg( "Completed %s." xynpl->numName)

;	place the numbers dwg as an instance over the wafer dwgs:
	xynMsg( "Adding numbers instance to wafer drawings...")
	xynOverlayNumbers()

	t
      )
      ( t
	xynErr( "Failed to create %s/%s/layout" xynpl->libName xynpl->numName)
	nil
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPlaceChipNumbers()
  let( ( nonCoupons chipNames sl instances ix xs jy ly x lx chip orient pp 
         nChips nd ns exceed slerror numerr)

    numerr = nil
    ;   preset the probed-chips counters to zero:
    foreach( c xynpl->mergedChipList 
      c->nChips = 0
    );foreach

    ; create the list of chip names omitting coupons:
    nonCoupons = setof( c xynpl->mergedChipList c->chipType == "chip")
    chipNames = foreach( mapcar c nonCoupons c->name)

    ; get the list of vertical scribe lines in the primary reticle:
    sl = xynGetVerticalScribes()

    xynMsg( "Numbering chips... %s" buildString( chipNames))

    ; get the instances of these chips across the wafer:
    instances = setof( i xynpl->flatCV~>instances member( i~>cellName chipNames))
    xynMsg( "Total of %d instances (not all are complete chips)" length( instances))
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;   sort them by xy position:
    ;   This sort is used to order the numbering such that the lowest x y numbers
    ;   originate in the lower left corner of the reticle array, and that the 
    ;   numbering is from left to right and bottom to top???? (Need to verify this)
    ;   UPDATE: this sorting reverses the rows and col order such that the chips
    ;           are numbered in the reverse of the labels on the wafer cellview.
    ;   FIXME: The labels in the figure should be reversed to reflect that the
    ;          the numbering has been reversed. It is way too confusing right now!!
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    instances = sort( instances 'xynInstXySort)

    slerror = 0
    jy = -1  ly = -1
    nChips = 0
    foreach( inst instances
      exceed = nil
      ; keep track of steps in the y direction:
      when( cadr( inst~>xy) > ly
        ;reset the x number to zero:
	ix = 0
	;set the scribe pointer to the first scribe line (x = 0 in reticle):
	xs = sl
	;advance the y number:
	jy = jy + 1
	;keep track of this row's y-coordinate:
	ly = cadr( inst~>xy)
	;reset the intra-reticle x-counter:
	lx = 0
      );when
      xynMsg( "Processing Chip Name: %L" inst~>cellName)
      xynMsg( "Processing Chip Instance: %L" inst~>name)
      xynMsg( "Reticle Row Index X: %L" ix)
      xynMsg( "Reticle Col Index Y: %L" jy)
      xynMsg( "Intra Reticle Row Y Coord: %L" ly)
      xynMsg( "Intra Reticle Col X Coord: %L" lx)
      ;keep track of vertical scribe lines
      ;(to handle rows that contain chips and non-chips) NON-CHIPS == COUPONS??
      ;get the chip's x-coord WRT the reticle:

      ; FIXME: inst~>xy is the origin of each chip in the reticle assigned during S&R processing
      ; lx is intra reticle column position as calculated locally in this procedure
      ; taking the differenc between the stored x coord value of chip origin and the position of the 
      ; xcoord column index and comparing it to the reticle width. If it is greater than 
      ; increment the index of the column value x by the length of the scribe line and increment
      ; the value of the intra reticle column index lx 
      while( car( inst~>xy) - lx > xynpl->retW
	ix = ix + length( sl)
	lx = lx + xynpl->retW
      );while

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; FIXME: Commented out the code below because it was confusing the numbers generation on when
      ;        using MEMS chip outlines. Appears as if this code is performing a periodicity check on
      ;        the vertical innner streets of the reticle. If it does not find a "particular" peridicity
      ;        it makes assumptions about the next die site in the reticle being a coupon. If this is 
      ;        a valid inner street periodicity check it should be performed in the reticle pre-checks
      ;        and not here. Checks should be made that the inner streets have proper periodicity and
      ;        run the complete width and height of the reticle well before numbers are printed. In addition,
      ;        only a check of verticle inner streets is performed here. What about horizontal streets? They
      ;        are not being checked here. Based upon all of this confusion about what is going on here, the
      ;        inner reticle street validity checks (both horizontal and verticle) will be performed at the 
      ;        input to xyn rather than doing it within the numbers generation procedure
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; This is where the x coordinate value is reset to zero at the end of each
      ; reticle processed. Represents the commutative behavior aligning the the periodicity of
      ; the inner streets of the reticle
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
      ; Note: the inst~>xy was given to each chip during S&R algorithm execution and is a custom
      ; property representing the chip origin
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;lx = car( inst~>xy)
      ;;new variable x is assigned from the x coordinate value - used for inter-reticle checking
      ;;against the previous street calculation
      ;x = lx
      ;while( x >= xynpl->retW 
      ;       xynMsg( "X coordinate %L is greater than reticle width %L subtracting width" x xynpl->retW )
      ;       x = x - xynpl->retW
      ;       xynMsg( "New X value %L:" x )
      ;);while

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; Watchdog Condition: When X coord value not equal to X value of the vertical scribe line position (xs)
      ;                     and the the array x index is less than 10,000 assume that the next 
      ;                     retical array location is not a chip and force an increment of the reticle
      ;                     column counter ix - Weird!!
      ;                     Chips in next reticle x index are not aligning to the vertical scribe lines??
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;while( x != car( xs) && ix < 10000
      ;  slerror++
      ;  if(null(exceed) then
      ;    xynMsg( "WARNING: MIN ONE OCCURRENCE: Coord x:%L is further right than expected as compared to vertical scribe xs:%L" x xs)
      ;	  exceed = 't
      ;    )
      ;;       FIXME: This is describing the skipping of a coupon as we are only interested in chips ...
      ;;	here x is farther right than expected, must be one or more non-chips
      ;;	was skipped in this row, so advance the x number:
      ; ; pop off the first entry in list xs and place previously popped value at the end
      ; ; circular stack
      ;	xs = or( cdr( xs) sl)
      ;	ix = ix + 1 ; Increment the Reticle column index by one
      ;      )
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ; Watchdog Condition: If x index value is 10,000 then there must have been a problem 
      ;                     error out ... 
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      when( ix == 10000 
	xynErr( "failed to find x index of chip instance %s" inst~>name)
	xynMsg( "instance x: %f  normalized x: %f\n" lx x)
	xynMsg( "vertical scribe lines %L:\n" sl)
	xynMsg( "Number of scribe line alignment errors: %d" slerror)	
	numerr = 't
      );when
      ;     add the wafer position numbers to the instance as properties:
      ;     mod 2/5/05 to ensure all chip instances have x-y numbers stored on them
      inst~>iX = ix
      inst~>jY = jy
      ;number only the complete chips:
      xynMsg( "Full Chip: %L" xynIsFullObject( inst))
      cond(
        ( xynIsFullObject( inst)
        ; new instance property indicates:  0 = off-wafer, 1 = partial, 2 = full chip
	inst~>onWafer = 2
	dbCreateProp(inst "validSite" "boolean" t)
        ; determine orientation of numbers:
        chip = car( exists( c xynpl->mergedChipList c->name == inst~>cellName))
        orient = xynMapPadOrient( chip->chipOrient chip->padOrient)
        ;map the pad origin:
	pp = dbTransformPoint( chip->padLocn list( inst~>xy inst~>orient))
        ; Check for 3rd digit, requires down-sized numbers:
        ; NOTE THIS OVERRIDES DIGITS CHOSEN DURING CHIP LISTING
	nd = if( ix > 99 || jy > 99 3 2)
	ns = chip->numSize
	when( nd == 3 ns = case( ns ("L"  "M")  ("M"  "S")  ("S"  "S")));when
	;number the site:
	;if(null(numerr) then
	xynNumberChip( ix jy car( pp) cadr( pp) nd orient chip->numType ns)
        ;else 
	;   xynErr( "Skipping number site %d,%d" ix jy)
        ;)
	chip->nChips = chip->nChips + 1
	nChips = nChips + 1
	when( mod( nChips 100) == 0 xynMsg( "%d chips done..." nChips));when
        );xynIsFullObject( inst)
	( xynIsPartialObject( inst)
	  inst~>onWafer = 1
	);xynIsPartialObject( inst)
	( t
	  inst~>onWafer = 0
	);t
      );cond
      ;advance to the next scribe line, 
      ;or reset to the first scribe when we pass the right edge of reticle:
      xs = or( cdr( xs) sl)

      ;advance the x number:
      ix = ix + 1
    );foreach( inst instances

    ;   echo number of complete chips:
    xynMsg( "Numbers completed for %d total chips:" nChips)
    foreach( c xynpl->mergedChipList
      when( c->chipType == "chip"
	xynMsg( "%-25s %4d numbered/tested chips" c->name c->nChips)
      );when
    );foreach
  );let
);procedure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynGetVerticalScribes
;	gets the list of vertical scribe coordinates for production
;	chips in the primary reticle, used to handle "odd" rows of chips
;	during numbering
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynGetVerticalScribes()
  let( ( sl sorted i)
    xynMsg( "Finding Vertical Reticle Scribe Lines:")
    foreach( chip xynpl->retChipList
      when( chip->chipType == "chip"
        xynMsg( "Chip Name: %L" chip->cellName)
	foreach( posn chip->chipPosn
          xynMsg( "Chip X Position: %L" xCoord(posn))
	  ;xynMsg( "Chip Y Position: %L" yCoord(posn))
          ; create a list of chip unique x values
          ; INLINE IF: if(member( car( posn) sl) sl = cons( car( posn) sl):nil)
	  unless( member( car( posn) sl) sl = cons( car( posn) sl))
	)
      )
    )
    sorted = sort( sl 'lessp)
    xynMsg( "Sorted Reticle Scribe Line X Coord List:")
    i=0
    foreach(sort sorted
      xynMsg( "%L.) SL X Coord:%L" i nth(i sorted))
      cdr(sorted)
      i++
    )
  )
  sort( sl 'lessp)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; xynPlaceCouponNumbers: Places the XY numbers on the XYN Pads
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPlaceCouponNumbers()
  let( ( orient inst pp nd ns)

;   creates numbers for each chip type:
    foreach( chip xynpl->mergedChipList

      when( chip->chipType == "coupon"

        xynMsg( "Numbering coupon %s..." chip->name)

;       determine orientation of numbers:
        orient = xynMapPadOrient( chip->chipOrient chip->padOrient)

;	coupon numbering is by reticle site, not chip position:
	for( jy 0 xynpl->nRows
	  for( ix 0 xynpl->nCols

;	    find the coupon instance at this reticle site:
	    inst = car( exists( i dbGetOverlaps( xynpl->flatCV 
				xynSizeBox( xynSiteBox( ix jy) -1 - xynpl->retOlap))
				i~>cellName == chip->name))

;           add the wafer position numbers to the instance as properties:
;	    mod 2/5/05 to support new output file, all chip instances have
;	    these properties:
            inst~>iX = ix
            inst~>jY = jy
	    inst~>onWafer = 0

;	    (not all sites will have the coupon)
;	    number only the complete chips:
	    when( inst && xynIsFullObject( inst)

	      inst~>onWafer = 2
;	      map the pad origin:
	      pp = dbTransformPoint( chip->padLocn
				     list( inst~>xy inst~>orient))

; 	     check for 3rd digit, requires down-sized numbers:
;	     NOTE THIS OVERRIDES DIGITS CHOSEN DURING CHIP LISTING
	     nd = if( ix > 99 || jy > 99 3 2)
	     ns = chip->numSize
	     when( nd == 3 ns = case( ns ("L"  "M")  ("M"  "S")  ("S"  "S")))

;	      number the site:
	      xynNumberChip( ix jy car( pp) cadr( pp) nd
			     orient chip->numType ns)

	      chip->nChips = chip->nChips + 1
	    )
	  )
        )
        xynMsg( "Numbers completed for %s" chip->name)
      )
    )

;   echo number of complete chips:
    xynMsg( "Numbers completed for coupons:")
    foreach( chip xynpl->mergedChipList
      when( chip->chipType == "coupon"
	xynMsg( "%-25s %4d numbered/tested chips" chip->name chip->nChips)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynMapPadOrient
;	vaguely sums the pad and chip orientations,
;	always returns either "R0" or "R270"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynMapPadOrient( chipOrient padOrient)
  let( ( no90)

    no90 = '("R0" "R180" "MX" "MY")
    cond(
      ( member( chipOrient no90)
	cond(
	  ( member( padOrient no90)	"R0")
	  ( t    "R270")
	)
      )
      ( t
	cond( 
	  ( member( padOrient no90)	"R270")
	  ( t    "R0")
	)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; xynNumberChip: Places complete XY number on a specific chip XYN Pad using the
;                cellview reference of the XYN PAD under consideration
;                xynpl->numCV
;                ix: Chip pad array x index 
;                iy: Chip pad array y index
;                xp: x Coordinate of pad origin
;                yp: y Coordinate of pad origin
;                digits: number of digits in the number ex. 4
;                numOrient: Orientation of the number ex. "R0"
;                numType: Number Type ex. "S"
;                numSize: Numuber Size ex. "M"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynNumberChip( ix jy xp yp digits numOrient numType numSize)
  let( ( ofsl format xl yl ofp)
    
    xynMsg("Numbering Chip With Number Size: %L", numSize)
    xynMsg("Chip Number Size: %L", digits)
    xynMsg("Chip Number Size FORMAT: %%0%dd", digits)
    xynMsg("Chip X Index: %L" ix)
    xynMsg("Chip Y Index: %L" jy)
    xynMsg("Pad Orientation: %L" numOrient)
    xynMsg("Number Type: %L" numType)
;   place the dash in the center of the pad:
    xynPlaceDigit( xynpl->numCV xp:yp numOrient "-" numType numSize)
   
;   get the placement offset list:
    ofsl = get( xynpl->numOffsets concat( numSize))
;   format the coordinates:
    format = sprintf( nil "%%0%dd" digits)
    
    xl = parseString( sprintf( nil format ix) "")
    yl = parseString( sprintf( nil format jy) "")

    case( numOrient
      ( "R0"
	ofp = ofsl
	foreach( digit reverse( xl)
	  xynPlaceDigit( xynpl->numCV list( xp - car( ofp) yp) 
			 numOrient digit numType numSize)
	  ofp = cdr( ofp)
	)
	ofp = ofsl
	foreach( digit yl
	  xynPlaceDigit( xynpl->numCV list( xp + car( ofp) yp) 
			 numOrient digit numType numSize)
	  ofp = cdr( ofp)
	)
      )
      ( t
	ofp = ofsl
	foreach( digit reverse( xl)
	  xynPlaceDigit( xynpl->numCV list( xp  yp + car( ofp))
			 numOrient digit numType numSize)
	  ofp = cdr( ofp)
	)
	ofp = ofsl
	foreach( digit yl
	  xynPlaceDigit( xynpl->numCV list( xp yp - car( ofp))
			 numOrient digit numType numSize)
	  ofp = cdr( ofp)
	)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; xynPlaceDigit: Places a single XYN Digit on an XYN Pad
; 1.) Get the cell name as determined by the digit ntype and size args
; 2.) Open the digit cellview in the master variable
; 3.) Instantiate the digit in the open reference cells view 
;     refereced by the cv argument
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynPlaceDigit( cv xy orient digit ntype size)
  let( ( cellName master)

    cellName = xynGetDigitCellName( digit ntype size)
    master = dbOpenCellViewByType( xynpl->numberLib cellName 
				   "layout" "maskLayout")
    dbCreateInst( cv master nil xy orient)
    dbClose( master)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; xynGetDigitWidth: Get the width of the digit from its boundary box
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynGetDigitWidth( digit ntype size)
  let( ( cellName cv w)

    cellName = xynGetDigitCellName( digit ntype size)
    cv = dbOpenCellViewByType( xynpl->numberLib cellName "layout" "maskLayout")
    w = caadr( cv~>bBox) - caar( cv~>bBox)
    dbClose( cv)
    w
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; xynGetDigitCellName: Returns the name of the digit cell in the 
;                      numbers library
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynGetDigitCellName( digit ntype size)

    xynMsg("PRINTING DIGIT: wpnums_xynum_%s%s%s"
	     upperCase( substring( ntype 1 1))
	     size digit)
    sprintf( nil "wpnums_xynum_%s%s%s"
	     upperCase( substring( ntype 1 1))
	     size digit)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-----------------------------------------------------------------------
;  new chip database output file generation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Created : ---
; Revised : 06/10/08
; Version : 1.1
; Author  : Mark Mezger (Editor: Matt Conte)
; Email   : --- (Editor: Matthew_Conte@raytheon.com)
;
; Description: Prints a chiplist ([libName]_chips.dat) based upon the data stored
;              in xynpl.
;
; Revisions: 1.1 - (1) Modified the way the paramemter line is printed to the
;                      output file.
;                      (a) Created 2 lists to allow consistent formatting between
;                          the parameter line and the data columns:
;                            params - List of parameters for the file columns.
;                            formatList - List of numbers to define how to space
;                            the columns.
;                               NOTE - formatList will need to change if either
;                                      the parameters or data size changes as this
;                                      list defines the size of the variable to
;                                      print.
;                  (2) Modified the way xynChipListWrite() is called to add the
;                      formatList variable to be passed in.
;
; Usage: xynChipListFile()
;    NOTE: The output file location is hard-coded to the release directory of the
;          library.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynChipListFile()
  let( ( fn op x params formatList)

    fn = strcat( xynpl->relDir xynpl->libName "_chips.dat")
    cond(
      ( null( (op = outfile( fn)))
        xynErr( "failed to create file %s" fn)
      )
      ( t
  xynMsg( "writing chip list file...")


  params = list("Chip" "ChipFlag" "RetX" "RetY" "ChipX" "ChipY" "X" "Y" "RetFlag")
  formatList = list(6 9 5 5 6 6 10 10 8) ; Format length for both parameter string and values

; header:
  fprintf( op "* XYNUMS Version %g %s \n" xynpl->version xynTimeStamp())
  fprintf( op "* \n")
  fprintf( op "* Mask        %s\n" xynpl->libName)
  fprintf( op "* SizeX       %g\n" xynpl->retW)
  fprintf( op "* SizeY       %g\n" xynpl->retH)
  fprintf( op "* WaferSize   %s\n" xynpl->wafInch)
  fprintf( op "* ShiftX      %g\n" xynpl->wafOfsX)
  fprintf( op "* ShiftY      %g\n" xynpl->wafOfsY)
  fprintf( op "* FlatY       2714\n")  ; ONLY WORKS FOR 4INCH WAFERS!!!!!!
  fprintf( op "* \n")
; Parameter Line
  fprintf( op "* ")
  for( x 0 (length(params)-1)
    fprintf( op sprintf(nil "%%%ds" nth(x formatList)) nth(x params))
  )
  fprintf( op "\n")

  xynChipListWrite( op "chip" formatList)
  xynChipListWrite( op "coupon" formatList)

  close( op)
  xynMsg( "wrote chip list file %s" fn)

  xynpl->chipDataFile = fn
  xynpl->form1->chipData->value = fn

  t
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynTimeStamp()
  let( ( dl ml mn)

;   reformat the CDS date/time string to MM/DD/YYYY HH:MM:SS
    dl = parseString( getCurrentTime())
    ml = '("Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec")
    mn = length( ml) - length( exists( m ml m == car( dl))) + 1

    sprintf( nil "%02d/%02d/%s %s" mn evalstring( cadr( dl)) cadddr( dl) caddr( dl))
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Created : ---
; Revised : 06/10/08
; Version : 1.1
; Author  : Mark Mezger (Editor: Matt Conte)
; Email   : --- (Editor: Matthew_Conte@raytheon.com)
;
; Description: Prints a chiplist ([libName]_chips.dat) based upon the data stored
;              in xynpl. Called from xynChipListFile().
;
; Revisions: 1.1 - (1) Modified the input arguements to add the formatList
;                      variable to be passed in.
;                  (2) Removed a legacy error check for proper chip/coupon naming
;                      as the convention has been changed.
;                      (a) Added a new error check. See xynValidChip.
;                      (b) Chips that fail the error check are named 'ERR' in the
;                          output file.
;                  (3) Modified the way the values are printed to the output file.
;                      (a) Now utilizes the passed in formatList variable to
;                          properly space the data with the parameter line.
;                          the parameter line and the data columns:
;
; Usage: xynChipListWrite(op chipType formatList)
;    NOTE: Must be called from xynChipListFile() to set header, parameter line,
;          and formatList variable correctly.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynChipListWrite( op chipType formatList)
  let( ( cn cX cY ow rf outputs)

;   step through all the reticle sites:
    for( jY 0 xynpl->nRows
      for( iX 0 xynpl->nCols

;     find all chip instances in this site,
;     for each of them...
        foreach( chip xynGetReticleSiteChipInstances( iX jY chipType)

;   get the chip number from the last part of its cell name:
    cn = car( last( parseString( chip~>cellName "_")))

    unless( xynValidChip( cn)
      xynErr( "chip cell name doesn't meet current naming convention:  %s"
        chip~>cellName)
      cn = "ERR"
    )

;   get the chip x-y numbers from the chip instance,
;   also get its onWafer property:
    cX = or( chip~>iX -1)
    cY = or( chip~>jY -1)
;   ow = 0 means off-wafer, 1 means partial, 2 mean fully on wafer:
    ow = or( chip~>onWafer 0)

;   determine the retFlag:
    case( chipType
      ( "chip"
        rf = if( xynIsDropInSite( iX jY) 2 0)
      )
      ( "coupon"
        rf = if( xynIsDropInSite( iX jY) 3 1)
      )
    )

;   write full and partial chips to the file,
;   include only partial & full chips (no fully-off-wafer chips listed),
;   here the on-wafer flag is 0 if partial chip, 1 if full chip:
    when( ow > 0
      outputs = list(cn (ow-1) iX jY cX cY car(chip~>xy) cadr(chip~>xy) rf)
      for( x 0 (length(formatList)-1)
        fprintf( op
          sprintf(nil "%%%d%s"
            ;Add 2 to the first element to account for header comment offset
            if( (x == 0) (nth(x formatList)+2) nth(x formatList) )
              xynWriteFormat(nth(x outputs))
          )
        nth(x outputs)
        )
      )
      fprintf(op "\n")
    )
        )
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Created : 06/09/08
; Revised : ---
; Version : 1.0
; Author  : Matt Conte
; Email   : Matthew_Conte@raytheon.com
;
; Description: Checks to see if the inputted chip matches the chip/coupon naming
;              convention adopted on 06/08. Included legacy support.
;                    Chips/Legacy Coupons: NN[N]  (e.g. 99, 970)
;                    New Standard Coupons: PPNNR  (e.g. 8099A)
;                New Experimental Coupons: XPPNNR (e.g. X8001A)
;                         Legend -  N - Number
;                                   P - Process
;                                   R - Revision
;                                  [] - Optional
;
; Usage: if( xynValidChip(chip) println("Valid") println("Not Valid") )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynValidChip( chip)
  cond(
    ( ( (strlen(chip) >= 2) && (strlen(chip) <= 3) ) ;Handles chips and legacy coupons
      cond(
        ( forall(x parseString(chip "") rexMatchp("[0-9]" x)) t)
      )
    )
    ( (strlen(chip) > 3) ;Handles new coupon format (06/08)
      cond(
        ( rexMatchp("^[0-9][0-9][0-9][0-9][a-zA-Z]$" chip) t ) ;Matches Type - '5199A'
        ( rexMatchp("^X[0-9][0-9][0-9][0-9][a-zA-Z]$" chip) t ) ;Matches Type - 'X8001A'
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Created : 06/09/08
; Revised : ---
; Version : 1.0
; Author  : Matt Conte
; Email   : Matthew_Conte@raytheon.com
;
; Description: Returns a format type for printing based upon the input type.
;
; Usage: fprintf( fp sprintf(nil "%%%s" xynWriteFormat(printValue)) printValue)
;    NOTE: The extra '%' at the front of the format string will with-hold the
;          evaluation of the '%' until the 'fprintf' function (instead of inside
;          the 'sprintf' function).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynWriteFormat( x)
  cond(
    ( null(numberp(x)) 's)
    ( integerp(x)      'd)
    ( floatp(x)        'g)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynGetReticleSiteChipInstances( iX jY chipType)

  setof( i
;	 get all instances in this reticle site:
	 dbGetOverlaps( xynpl->flatCV
			xynSizeBox( xynSiteBox( iX jY) -1 - xynpl->retOlap))
;	 select ones that are chips of the correct type,
;	 meaning the instance-cell is in the chips list and it is correct type:
	 car( exists( j xynpl->mergedChipList j->name == i~>cellName))->chipType
	 == chipType)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;xynXySort:
;
;   use with:  sort( listCoordinatePairs 'xynXySort)
;   sorts by x, then y
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

procedure( xynXySort( a b)
  cond(
    ( cadr( a) < cadr( b)	t)
    ( cadr( a) > cadr( b)	nil)
    ( car( a) < car( b) 	t)
    ( t                         nil)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynInstXySort
;	use with:  sort( listCoordinatePairs 'xynInstXySort)
;	sorts instances by their xy coordinates
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynInstXySort( i1 i2)
  xynXySort( i1~>xy i2~>xy)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynChipPosnSort( i1 i2)
  xynXySort( i1->chipPosn i2->chipPosn)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynYxSort( a b)
  cond(
    ( car( a) < car( b)		t)
    ( car( a) > car( b)		nil)
    ( cadr( a) < cadr( b)	t)
    ( t				nil)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynInstYxSort( i1 i2)

  xynYxSort( i1~>xy i2~>xy)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	xynNameLessp
;       use with:  sort( listOfPropListsWithName 'xynNameLessp)
;	sorts property lists alphabetically by 'name attribute
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynNameLessp( a b)

  alphalessp( a->name b->name)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Created : 06/05/08
; Revised : ---
; Version : 1.0
; Author  : Matt Conte
; Email   : Matthew_Conte@raytheon.com
;
; Description: Sorts chips based on the whether the chip is a chip or a coupon,
;              then on the naming convention adopted on 06/08
;                    Chips/Legacy Coupons: NN[N]  (e.g.  99, 970)
;                    New Standard Coupons: PPNNR  (e.g. 8099A)
;                New Experimental Coupons: XPPNNR (e.g. X8001A)
;                         Legend -  N - Number
;                                   P - Process
;                                   R - Revision
;                                  [] - Optional
;
; Usage: sortedChipList = sort(unsortedChipList 'xynChipSort)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynChipSort( a b)
  let( ( x cnums)
    cond(
      ( negativep(strcmp(a->chipType b->chipType)) t) ;   Chip < Coupon
      ( plusp(strcmp(a->chipType b->chipType)) nil)   ; Coupon > Chip
      ( zerop(strcmp(a->chipType b->chipType))        ; Same 'chipType'
        cnums = foreach(mapcar x list(a b)
                  x = car(last(parseString(x->name "_")))
                  cond(
                    ( (strlen(x) <= 3) x) ;Handles chips and legacy coupons
                    ( (strlen(x) > 3) ;Handles new coupon format (06/08)
                      cond(
                        ( fixp(atoi(substring(x 1 2))) ;First 2 characters are numbers - '51'99A
                            substring(x 3) ; Start at the third - 51'99A'
                        )
                        ( null(fixp(atoi(substring(x 1)))) x) ;First character is a letter - X8001A
                      )
                    )
                  )
                )
        alphalessp(car(cnums) cadr(cnums))
		  )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;-----------------------------------------------------------------------
;  	log file and messaging
;	xynLogOpen		opens the main log file
;	xynLogClose		closes it
;	xynConfirm		prompts user to confirm w dialog box
;	xynMsg			writes message to ciw and log file
;	xynLog			writes message to log file only
;	xynErr			writes error to ciw and log file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLogOpen()
    xynLogClose()
    cond(
      ( (xynpl->logfp = outfile( strcat( xynpl->relDir xynpl->logfn)))
	xynMsg( "%s xyn log file opened" getCurrentTime())
      )
      ( t
	xynErr( "failed to create log file %s" 
		strcat( xynpl->relDir xynpl->logfn))
      )
    )

    xynpl->errMsg = ""
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLogClose()

    when( portp( xynpl->logfp)
      xynMsg( "%s log file closed" getCurrentTime())
      close( xynpl->logfp)
      xynpl->logfp = nil
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynConfirm( s @rest r)

    s = apply( 'sprintf cons( nil cons( s r)))
    hiDisplayModalDBox( 'xynCONF "WARNING!" s "" "")
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynMsg( s @rest r)

    s = apply( 'sprintf cons( nil cons( s r)))
    printf( "xyn:  %s\n" s)
    when( xynpl->logfp fprintf( xynpl->logfp "%s\n" s))
    xynpl->errMsg = ""
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynLog( s @rest r)

    s = apply( 'sprintf cons( nil cons( s r)))
    when( xynpl->logfp fprintf( xynpl->logfp "%s\n" s))
    xynpl->errMsg = ""
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
procedure( xynErr( s @rest r)

    s = apply( 'sprintf cons( nil cons( s r)))
    unless( strcmp( s xynpl->errMsg) == 0
      hiGetAttention()
      printf( "xyn:  ERROR  %s\n" s)
      when( xynpl->logfp fprintf( xynpl->logfp "ERROR  %s\n" s))
      xynpl->errMsg = s
    )
    nil
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---- end of xyn.il
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  STAGES:
; 
;        1.) Primary and Secondary CV Entry Checks
; 
;        2.) Primary and Secondary CV pre-processing
;
;        3.) Generate a preliminary reticle array across the wafer drawing (non chip count optimized)
;
;        4.) Interactive selection of secondary position in array to meet wafer alignment mark 
;            requirements FIME: What exactly are these???
;
;        5.) Identify all chips and test coupons within the primary and secondary based upon
;            the name of the xynNumberPad cell
; 
;        6.) Generate a list of primary and secondary die. Chips, PMBs, Test Coupons (breakouts), and markers.
;            this list contains the origin of each of the items above
;